(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([[4144],{

/***/ 92871:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  DEFAULT_CONTEXT_ITEM_RANK: () => (/* binding */ DEFAULT_CONTEXT_ITEM_RANK),
  "default": () => (/* binding */ lib)
});

// EXTERNAL MODULE: consume shared module (default) @jupyterlab/application@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/application/lib/index.js)
var index_js_ = __webpack_require__(77415);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/apputils@~4.5.3 (singleton) (fallback: ../node_modules/@jupyterlab/apputils/lib/index.js)
var lib_index_js_ = __webpack_require__(94079);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/coreutils@~6.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/coreutils/lib/index.js)
var coreutils_lib_index_js_ = __webpack_require__(60649);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/property-inspector@^4.4.3 (strict) (fallback: ../node_modules/@jupyterlab/property-inspector/lib/index.js)
var property_inspector_lib_index_js_ = __webpack_require__(97852);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/settingregistry@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/settingregistry/lib/index.js)
var settingregistry_lib_index_js_ = __webpack_require__(94238);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/statedb@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/statedb/lib/index.js)
var statedb_lib_index_js_ = __webpack_require__(70870);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/statusbar@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/statusbar/lib/index.js)
var statusbar_lib_index_js_ = __webpack_require__(98338);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/translation@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/translation/lib/index.js)
var translation_lib_index_js_ = __webpack_require__(50856);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/ui-components@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/ui-components/lib/index.js)
var ui_components_lib_index_js_ = __webpack_require__(39089);
// EXTERNAL MODULE: consume shared module (default) @lumino/algorithm@~2.0.3 (singleton) (fallback: ../node_modules/@lumino/algorithm/dist/index.es6.js)
var index_es6_js_ = __webpack_require__(56114);
// EXTERNAL MODULE: consume shared module (default) @lumino/coreutils@~2.2.1 (singleton) (fallback: ../node_modules/@lumino/coreutils/dist/index.js)
var dist_index_js_ = __webpack_require__(5406);
// EXTERNAL MODULE: consume shared module (default) @lumino/commands@~2.3.2 (singleton) (fallback: ../node_modules/@lumino/commands/dist/index.es6.js)
var dist_index_es6_js_ = __webpack_require__(35538);
// EXTERNAL MODULE: consume shared module (default) @lumino/disposable@~2.1.4 (singleton) (fallback: ../node_modules/@lumino/disposable/dist/index.es6.js)
var disposable_dist_index_es6_js_ = __webpack_require__(38302);
// EXTERNAL MODULE: consume shared module (default) @lumino/widgets@~2.7.1 (singleton) (fallback: ../node_modules/@lumino/widgets/dist/index.es6.js)
var widgets_dist_index_es6_js_ = __webpack_require__(60920);
// EXTERNAL MODULE: consume shared module (default) react@~18.2.0 (singleton) (fallback: ../node_modules/react/index.js)
var react_index_js_ = __webpack_require__(78156);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application-extension/lib/topbar.js
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */




const TOPBAR_FACTORY = 'TopBar';
/**
 * A plugin adding a toolbar to the top area.
 */
const topbar = {
    id: '@jupyterlab/application-extension:top-bar',
    description: 'Adds a toolbar to the top area (next to the main menu bar).',
    autoStart: true,
    requires: [settingregistry_lib_index_js_.ISettingRegistry, lib_index_js_.IToolbarWidgetRegistry],
    optional: [translation_lib_index_js_.ITranslator],
    activate: (app, settingRegistry, toolbarRegistry, translator) => {
        const trans = (translator !== null && translator !== void 0 ? translator : translation_lib_index_js_.nullTranslator).load('jupyterlab');
        const toolbar = new ui_components_lib_index_js_.Toolbar();
        toolbar.id = 'jp-top-bar';
        toolbar.node.setAttribute('aria-label', trans.__('Topbar toolbar'));
        // Set toolbar
        (0,lib_index_js_.setToolbar)(toolbar, (0,lib_index_js_.createToolbarFactory)(toolbarRegistry, settingRegistry, TOPBAR_FACTORY, topbar.id, translator !== null && translator !== void 0 ? translator : translation_lib_index_js_.nullTranslator), toolbar);
        app.shell.add(toolbar, 'top', { rank: 900 });
    }
};
//# sourceMappingURL=topbar.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application-extension/lib/index.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * @packageDocumentation
 * @module application-extension
 */
















/**
 * Default context menu item rank
 */
const DEFAULT_CONTEXT_ITEM_RANK = 100;
/**
 * The command IDs used by the application plugin.
 */
var CommandIDs;
(function (CommandIDs) {
    CommandIDs.activateNextTab = 'application:activate-next-tab';
    CommandIDs.activatePreviousTab = 'application:activate-previous-tab';
    CommandIDs.activateNextTabBar = 'application:activate-next-tab-bar';
    CommandIDs.activatePreviousTabBar = 'application:activate-previous-tab-bar';
    CommandIDs.close = 'application:close';
    CommandIDs.closeOtherTabs = 'application:close-other-tabs';
    CommandIDs.closeRightTabs = 'application:close-right-tabs';
    CommandIDs.closeAll = 'application:close-all';
    CommandIDs.setMode = 'application:set-mode';
    CommandIDs.showPropertyPanel = 'property-inspector:show-panel';
    CommandIDs.resetLayout = 'application:reset-layout';
    CommandIDs.toggleContextMenu = 'application:toggle-context-menu';
    CommandIDs.toggleHeader = 'application:toggle-header';
    CommandIDs.toggleMode = 'application:toggle-mode';
    CommandIDs.toggleLeftArea = 'application:toggle-left-area';
    CommandIDs.toggleRightArea = 'application:toggle-right-area';
    CommandIDs.toggleSideTabBar = 'application:toggle-side-tabbar';
    CommandIDs.toggleSidebarWidget = 'application:toggle-sidebar-widget';
    CommandIDs.togglePresentationMode = 'application:toggle-presentation-mode';
    CommandIDs.toggleFullscreenMode = 'application:toggle-fullscreen-mode';
    CommandIDs.tree = 'router:tree';
    CommandIDs.switchSidebar = 'sidebar:switch';
})(CommandIDs || (CommandIDs = {}));
/**
 * A plugin to register the commands for the main application.
 */
const mainCommands = {
    id: '@jupyterlab/application-extension:commands',
    description: 'Adds commands related to the shell.',
    autoStart: true,
    requires: [translation_lib_index_js_.ITranslator],
    optional: [index_js_.ILabShell, lib_index_js_.ICommandPalette],
    activate: (app, translator, labShell, palette) => {
        var _a;
        const { commands, shell } = app;
        const trans = translator.load('jupyterlab');
        const category = trans.__('Main Area');
        // Add Command to override the JLab context menu.
        commands.addCommand(index_js_.JupyterFrontEndContextMenu.contextMenu, {
            label: trans.__('Shift+Right Click for Browser Menu'),
            isEnabled: () => false,
            execute: () => void 0
        });
        // Returns the widget associated with the most recent contextmenu event.
        const contextMenuWidget = () => {
            const test = (node) => !!node.dataset.id;
            const node = app.contextMenuHitTest(test);
            if (!node) {
                // Fall back to active widget if path cannot be obtained from event.
                return shell.currentWidget;
            }
            return ((0,index_es6_js_.find)(shell.widgets('main'), widget => widget.id === node.dataset.id) ||
                shell.currentWidget);
        };
        // Closes an array of widgets.
        const closeWidgets = (widgets) => {
            widgets.forEach(widget => widget.close());
        };
        // Find the tab area for a widget within a specific dock area.
        const findTab = (area, widget) => {
            if (area.type === 'tab-area') {
                return area.widgets.includes(widget) ? area : null;
            }
            if (area.type === 'split-area') {
                for (const child of area.children) {
                    const found = findTab(child, widget);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        };
        // Find the tab area for a widget within the main dock area.
        const tabAreaFor = (widget) => {
            var _a;
            const layout = labShell === null || labShell === void 0 ? void 0 : labShell.saveLayout();
            const mainArea = layout === null || layout === void 0 ? void 0 : layout.mainArea;
            if (!mainArea || coreutils_lib_index_js_.PageConfig.getOption('mode') !== 'multiple-document') {
                return null;
            }
            const area = (_a = mainArea.dock) === null || _a === void 0 ? void 0 : _a.main;
            return area ? findTab(area, widget) : null;
        };
        // Returns an array of all widgets to the right of a widget in a tab area.
        const widgetsRightOf = (widget) => {
            const { id } = widget;
            const tabArea = tabAreaFor(widget);
            const widgets = tabArea ? tabArea.widgets || [] : [];
            const index = widgets.findIndex(widget => widget.id === id);
            if (index < 0) {
                return [];
            }
            return widgets.slice(index + 1);
        };
        // Gets and returns the dataId of currently active tab in the specified sidebar (left or right)
        // or an empty string
        const activeSidePanelWidget = (side) => {
            // default active element is luancher (luancher-0)
            let activeTab;
            if (side != 'left' && side != 'right') {
                throw Error(`Unsupported sidebar: ${side}`);
            }
            if (side === 'left') {
                activeTab = document.querySelector('.lm-TabBar-tab.lm-mod-current');
            }
            else {
                const query = document.querySelectorAll('.lm-TabBar-tab.lm-mod-current');
                activeTab = query[query.length - 1];
            }
            const activeTabDataId = activeTab === null || activeTab === void 0 ? void 0 : activeTab.getAttribute('data-id');
            if (activeTabDataId) {
                return activeTabDataId === null || activeTabDataId === void 0 ? void 0 : activeTabDataId.toString();
            }
            else {
                return '';
            }
        };
        // Sets tab focus on the element
        function setTabFocus(focusElement) {
            if (focusElement) {
                focusElement.focus();
            }
        }
        commands.addCommand(CommandIDs.close, {
            label: () => trans.__('Close Tab'),
            isEnabled: () => {
                const widget = contextMenuWidget();
                return !!widget && widget.title.closable;
            },
            execute: () => {
                const widget = contextMenuWidget();
                if (widget) {
                    widget.close();
                }
            }
        });
        commands.addCommand(CommandIDs.closeOtherTabs, {
            label: () => trans.__('Close All Other Tabs'),
            isEnabled: () => {
                // Ensure there are at least two widgets.
                return (0,index_es6_js_.some)(shell.widgets('main'), (_, i) => i === 1);
            },
            execute: () => {
                const widget = contextMenuWidget();
                if (!widget) {
                    return;
                }
                const { id } = widget;
                for (const widget of shell.widgets('main')) {
                    if (widget.id !== id) {
                        widget.close();
                    }
                }
            }
        });
        commands.addCommand(CommandIDs.closeRightTabs, {
            label: () => trans.__('Close Tabs to Right'),
            isEnabled: () => !!contextMenuWidget() &&
                widgetsRightOf(contextMenuWidget()).length > 0,
            execute: () => {
                const widget = contextMenuWidget();
                if (!widget) {
                    return;
                }
                closeWidgets(widgetsRightOf(widget));
            }
        });
        (_a = shell.currentChanged) === null || _a === void 0 ? void 0 : _a.connect(() => {
            [
                CommandIDs.close,
                CommandIDs.closeOtherTabs,
                CommandIDs.closeRightTabs
            ].forEach(cmd => commands.notifyCommandChanged(cmd));
        });
        if (labShell) {
            commands.addCommand(CommandIDs.activateNextTab, {
                label: trans.__('Activate Next Tab'),
                execute: () => {
                    labShell.activateNextTab();
                }
            });
            commands.addCommand(CommandIDs.activatePreviousTab, {
                label: trans.__('Activate Previous Tab'),
                execute: () => {
                    labShell.activatePreviousTab();
                }
            });
            commands.addCommand(CommandIDs.activateNextTabBar, {
                label: trans.__('Activate Next Tab Bar'),
                execute: () => {
                    labShell.activateNextTabBar();
                }
            });
            commands.addCommand(CommandIDs.activatePreviousTabBar, {
                label: trans.__('Activate Previous Tab Bar'),
                execute: () => {
                    labShell.activatePreviousTabBar();
                }
            });
            commands.addCommand(CommandIDs.closeAll, {
                label: trans.__('Close All Tabs'),
                execute: () => {
                    labShell.closeAll();
                }
            });
            commands.addCommand(CommandIDs.toggleHeader, {
                label: trans.__('Show Header'),
                execute: () => {
                    if (labShell.mode === 'single-document') {
                        labShell.toggleTopInSimpleModeVisibility();
                    }
                },
                isToggled: () => labShell.isTopInSimpleModeVisible(),
                isVisible: () => labShell.mode === 'single-document'
            });
            commands.addCommand(CommandIDs.toggleLeftArea, {
                label: trans.__('Show Left Sidebar'),
                execute: () => {
                    if (labShell.leftCollapsed) {
                        labShell.expandLeft();
                    }
                    else {
                        labShell.collapseLeft();
                        if (labShell.currentWidget) {
                            labShell.activateById(labShell.currentWidget.id);
                        }
                    }
                },
                isToggled: () => !labShell.leftCollapsed,
                isEnabled: () => !labShell.isEmpty('left')
            });
            commands.addCommand(CommandIDs.toggleRightArea, {
                label: trans.__('Show Right Sidebar'),
                execute: () => {
                    if (labShell.rightCollapsed) {
                        labShell.expandRight();
                    }
                    else {
                        labShell.collapseRight();
                        if (labShell.currentWidget) {
                            labShell.activateById(labShell.currentWidget.id);
                        }
                    }
                },
                isToggled: () => !labShell.rightCollapsed,
                isEnabled: () => !labShell.isEmpty('right')
            });
            commands.addCommand(CommandIDs.toggleSidebarWidget, {
                label: args => args === undefined ||
                    args.side === undefined ||
                    args.index === undefined
                    ? trans.__('Toggle Sidebar Element')
                    : args.side === 'right'
                        ? trans.__('Toggle Element %1 in Right Sidebar', parseInt(args.index, 10) + 1)
                        : trans.__('Toggle Element %1 in Left Sidebar', parseInt(args.index, 10) + 1),
                execute: args => {
                    const index = parseInt(args.index, 10);
                    if (args.side != 'left' && args.side != 'right') {
                        throw Error(`Unsupported sidebar: ${args.side}`);
                    }
                    const widgets = Array.from(labShell.widgets(args.side));
                    if (index >= widgets.length) {
                        return;
                    }
                    const widgetId = widgets[index].id;
                    const focusElement = document.querySelector("[data-id='" + widgetId + "']");
                    if (activeSidePanelWidget(args.side) === widgetId) {
                        if (args.side == 'left') {
                            labShell.collapseLeft();
                            setTabFocus(focusElement);
                        }
                        if (args.side == 'right') {
                            labShell.collapseRight();
                            setTabFocus(focusElement);
                        }
                    }
                    else {
                        labShell.activateById(widgetId);
                        setTabFocus(focusElement);
                    }
                }
            });
            commands.addCommand(CommandIDs.toggleSideTabBar, {
                label: args => args.side === 'right'
                    ? trans.__('Show Right Activity Bar')
                    : trans.__('Show Left Activity Bar'),
                execute: args => {
                    if (args.side === 'right') {
                        labShell.toggleSideTabBarVisibility('right');
                    }
                    else {
                        labShell.toggleSideTabBarVisibility('left');
                    }
                },
                isToggled: args => args.side === 'right'
                    ? labShell.isSideTabBarVisible('right')
                    : labShell.isSideTabBarVisible('left'),
                isEnabled: args => args.side === 'right'
                    ? !labShell.isEmpty('right')
                    : !labShell.isEmpty('left')
            });
            commands.addCommand(CommandIDs.togglePresentationMode, {
                label: () => trans.__('Presentation Mode'),
                execute: () => {
                    labShell.presentationMode = !labShell.presentationMode;
                },
                isToggled: () => labShell.presentationMode,
                isVisible: () => true
            });
            commands.addCommand(CommandIDs.toggleFullscreenMode, {
                label: trans.__('Fullscreen Mode'),
                execute: () => {
                    if (document.fullscreenElement === null ||
                        document.fullscreenElement === undefined) {
                        document.documentElement.requestFullscreen().catch(reason => {
                            console.error('Failed to enter fullscreen mode.', reason);
                        });
                    }
                    else if (document.fullscreenElement !== null) {
                        document.exitFullscreen().catch(reason => {
                            console.error('Failed to exit fullscreen mode.', reason);
                        });
                    }
                },
                isToggled: () => document.fullscreenElement !== null
            });
            commands.addCommand(CommandIDs.setMode, {
                label: args => args['mode']
                    ? trans.__('Set %1 mode.', args['mode'])
                    : trans.__('Set the layout `mode`.'),
                caption: trans.__('The layout `mode` can be "single-document" or "multiple-document".'),
                isVisible: args => {
                    const mode = args['mode'];
                    return mode === 'single-document' || mode === 'multiple-document';
                },
                execute: args => {
                    const mode = args['mode'];
                    if (mode === 'single-document' || mode === 'multiple-document') {
                        labShell.mode = mode;
                        return;
                    }
                    throw new Error(`Unsupported application shell mode: ${mode}`);
                }
            });
            commands.addCommand(CommandIDs.toggleMode, {
                label: trans.__('Simple Interface'),
                isToggled: () => labShell.mode === 'single-document',
                execute: () => {
                    const args = labShell.mode === 'multiple-document'
                        ? { mode: 'single-document' }
                        : { mode: 'multiple-document' };
                    return commands.execute(CommandIDs.setMode, args);
                }
            });
            commands.addCommand(CommandIDs.resetLayout, {
                label: trans.__('Reset Default Layout'),
                execute: () => {
                    // Turn off presentation mode
                    if (labShell.presentationMode) {
                        commands
                            .execute(CommandIDs.togglePresentationMode)
                            .catch(reason => {
                            console.error('Failed to undo presentation mode.', reason);
                        });
                    }
                    // Turn off fullscreen mode
                    if (document.fullscreenElement !== null ||
                        document.fullscreenElement !== undefined) {
                        commands.execute(CommandIDs.toggleFullscreenMode).catch(reason => {
                            console.error('Failed to exit fullscreen mode.', reason);
                        });
                    }
                    // Display top header
                    if (labShell.mode === 'single-document' &&
                        !labShell.isTopInSimpleModeVisible()) {
                        commands.execute(CommandIDs.toggleHeader).catch(reason => {
                            console.error('Failed to display title header.', reason);
                        });
                    }
                    // Display side tabbar
                    ['left', 'right'].forEach(side => {
                        if (!labShell.isSideTabBarVisible(side) &&
                            !labShell.isEmpty(side)) {
                            commands
                                .execute(CommandIDs.toggleSideTabBar, { side })
                                .catch(reason => {
                                console.error(`Failed to show ${side} activity bar.`, reason);
                            });
                        }
                    });
                    // Some actions are also trigger indirectly
                    // - by listening to this command execution.
                }
            });
        }
        if (palette) {
            [
                CommandIDs.activateNextTab,
                CommandIDs.activatePreviousTab,
                CommandIDs.activateNextTabBar,
                CommandIDs.activatePreviousTabBar,
                CommandIDs.close,
                CommandIDs.closeAll,
                CommandIDs.closeOtherTabs,
                CommandIDs.closeRightTabs,
                CommandIDs.toggleHeader,
                CommandIDs.toggleLeftArea,
                CommandIDs.toggleRightArea,
                CommandIDs.togglePresentationMode,
                CommandIDs.toggleFullscreenMode,
                CommandIDs.toggleMode,
                CommandIDs.resetLayout
            ].forEach(command => palette.addItem({ command, category }));
            ['right', 'left'].forEach(side => {
                palette.addItem({
                    command: CommandIDs.toggleSideTabBar,
                    category,
                    args: { side }
                });
            });
        }
    }
};
/**
 * The main extension.
 */
const main = {
    id: '@jupyterlab/application-extension:main',
    description: 'Initializes the application and provides the URL tree path handler.',
    requires: [
        index_js_.IRouter,
        lib_index_js_.IWindowResolver,
        translation_lib_index_js_.ITranslator,
        index_js_.JupyterFrontEnd.ITreeResolver
    ],
    optional: [index_js_.IConnectionLost],
    provides: index_js_.ITreePathUpdater,
    activate: (app, router, resolver, translator, treeResolver, connectionLost) => {
        const trans = translator.load('jupyterlab');
        if (!(app instanceof index_js_.JupyterLab)) {
            throw new Error(`${main.id} must be activated in JupyterLab.`);
        }
        // These two internal state variables are used to manage the two source
        // of the tree part of the URL being updated: 1) path of the active document,
        // 2) path of the default browser if the active main area widget isn't a document.
        let _docTreePath = '';
        let _defaultBrowserTreePath = '';
        function updateTreePath(treePath) {
            // Wait for tree resolver to finish before updating the path because it use the PageConfig['treePath']
            void treeResolver.paths.then(() => {
                _defaultBrowserTreePath = treePath;
                if (!_docTreePath) {
                    const url = coreutils_lib_index_js_.PageConfig.getUrl({ treePath });
                    const path = coreutils_lib_index_js_.URLExt.parse(url).pathname;
                    router.navigate(path, { skipRouting: true });
                    // Persist the new tree path to PageConfig as it is used elsewhere at runtime.
                    coreutils_lib_index_js_.PageConfig.setOption('treePath', treePath);
                }
            });
        }
        // Requiring the window resolver guarantees that the application extension
        // only loads if there is a viable window name. Otherwise, the application
        // will short-circuit and ask the user to navigate away.
        const workspace = resolver.name;
        console.debug(`Starting application in workspace: "${workspace}"`);
        // If there were errors registering plugins, tell the user.
        if (app.registerPluginErrors.length !== 0) {
            const body = (react_index_js_.createElement("pre", null, app.registerPluginErrors.map(e => e.message).join('\n')));
            void (0,lib_index_js_.showErrorMessage)(trans.__('Error Registering Plugins'), {
                message: body
            });
        }
        // Watch the mode and update the page URL to /lab or /doc to reflect the
        // change.
        app.shell.modeChanged.connect((_, args) => {
            const url = coreutils_lib_index_js_.PageConfig.getUrl({ mode: args });
            const path = coreutils_lib_index_js_.URLExt.parse(url).pathname;
            router.navigate(path, { skipRouting: true });
            // Persist this mode change to PageConfig as it is used elsewhere at runtime.
            coreutils_lib_index_js_.PageConfig.setOption('mode', args);
        });
        // Wait for tree resolver to finish before updating the path because it use the PageConfig['treePath']
        void treeResolver.paths.then(() => {
            // Watch the path of the current widget in the main area and update the page
            // URL to reflect the change.
            app.shell.currentPathChanged.connect((_, args) => {
                const maybeTreePath = args.newValue;
                const treePath = maybeTreePath || _defaultBrowserTreePath;
                const url = coreutils_lib_index_js_.PageConfig.getUrl({ treePath: treePath });
                const path = coreutils_lib_index_js_.URLExt.parse(url).pathname;
                router.navigate(path, { skipRouting: true });
                // Persist the new tree path to PageConfig as it is used elsewhere at runtime.
                coreutils_lib_index_js_.PageConfig.setOption('treePath', treePath);
                _docTreePath = maybeTreePath;
            });
        });
        // If the connection to the server is lost, handle it with the
        // connection lost handler.
        connectionLost = connectionLost || index_js_.ConnectionLost;
        app.serviceManager.connectionFailure.connect((manager, error) => connectionLost(manager, error, translator));
        const builder = app.serviceManager.builder;
        const build = () => {
            return builder
                .build()
                .then(() => {
                return (0,lib_index_js_.showDialog)({
                    title: trans.__('Build Complete'),
                    body: (react_index_js_.createElement("div", null,
                        trans.__('Build successfully completed, reload page?'),
                        react_index_js_.createElement("br", null),
                        trans.__('You will lose any unsaved changes.'))),
                    buttons: [
                        lib_index_js_.Dialog.cancelButton({
                            label: trans.__('Reload Without Saving'),
                            actions: ['reload']
                        }),
                        lib_index_js_.Dialog.okButton({ label: trans.__('Save and Reload') })
                    ],
                    hasClose: true
                });
            })
                .then(({ button: { accept, actions } }) => {
                if (accept) {
                    void app.commands
                        .execute('docmanager:save')
                        .then(() => {
                        router.reload();
                    })
                        .catch(err => {
                        void (0,lib_index_js_.showErrorMessage)(trans.__('Save Failed'), {
                            message: react_index_js_.createElement("pre", null, err.message)
                        });
                    });
                }
                else if (actions.includes('reload')) {
                    router.reload();
                }
            })
                .catch(err => {
                void (0,lib_index_js_.showErrorMessage)(trans.__('Build Failed'), {
                    message: react_index_js_.createElement("pre", null, err.message)
                });
            });
        };
        if (builder.isAvailable && builder.shouldCheck) {
            void builder.getStatus().then(response => {
                if (response.status === 'building') {
                    return build();
                }
                if (response.status !== 'needed') {
                    return;
                }
                const body = (react_index_js_.createElement("div", null,
                    trans.__('JupyterLab build is suggested:'),
                    react_index_js_.createElement("br", null),
                    react_index_js_.createElement("pre", null, response.message)));
                void (0,lib_index_js_.showDialog)({
                    title: trans.__('Build Recommended'),
                    body,
                    buttons: [
                        lib_index_js_.Dialog.cancelButton(),
                        lib_index_js_.Dialog.okButton({ label: trans.__('Build') })
                    ]
                }).then(result => (result.button.accept ? build() : undefined));
            });
        }
        return updateTreePath;
    },
    autoStart: true
};
/**
 * Plugin to build the context menu from the settings.
 */
const contextMenuPlugin = {
    id: '@jupyterlab/application-extension:context-menu',
    description: 'Populates the context menu.',
    autoStart: true,
    requires: [settingregistry_lib_index_js_.ISettingRegistry, translation_lib_index_js_.ITranslator],
    optional: [lib_index_js_.ICommandPalette],
    activate: (app, settingRegistry, translator, palette) => {
        const trans = translator.load('jupyterlab');
        function createMenu(options) {
            const menu = new ui_components_lib_index_js_.RankedMenu({ ...options, commands: app.commands });
            if (options.label) {
                menu.title.label = trans.__(options.label);
            }
            return menu;
        }
        // Load the context menu lately so plugins are loaded.
        app.started
            .then(() => {
            return Private.loadSettingsContextMenu(app.contextMenu, app.commands, settingRegistry, createMenu, translator);
        })
            .then(() => {
            if (palette) {
                palette === null || palette === void 0 ? void 0 : palette.addItem({
                    category: trans.__('Settings'),
                    command: CommandIDs.toggleContextMenu
                });
            }
        })
            .catch(reason => {
            console.error('Failed to load context menu items from settings registry.', reason);
        });
    }
};
/**
 * Check if the application is dirty before closing the browser tab.
 */
const dirty = {
    id: '@jupyterlab/application-extension:dirty',
    description: 'Adds safeguard dialog when closing the browser tab with unsaved modifications.',
    autoStart: true,
    requires: [translation_lib_index_js_.ITranslator],
    activate: (app, translator) => {
        if (!(app instanceof index_js_.JupyterLab)) {
            throw new Error(`${dirty.id} must be activated in JupyterLab.`);
        }
        const trans = translator.load('jupyterlab');
        const message = trans.__('Are you sure you want to exit JupyterLab?\n\nAny unsaved changes will be lost.');
        // The spec for the `beforeunload` event is implemented differently by
        // the different browser vendors. Consequently, the `event.returnValue`
        // attribute needs to set in addition to a return value being returned.
        // For more information, see:
        // https://developer.mozilla.org/en/docs/Web/Events/beforeunload
        window.addEventListener('beforeunload', event => {
            if (app.status.isDirty) {
                return (event.returnValue = message);
            }
        });
    }
};
/**
 * The default layout restorer provider.
 */
const layout = {
    id: '@jupyterlab/application-extension:layout',
    description: 'Provides the shell layout restorer.',
    requires: [statedb_lib_index_js_.IStateDB, index_js_.ILabShell, settingregistry_lib_index_js_.ISettingRegistry],
    optional: [translation_lib_index_js_.ITranslator],
    activate: (app, state, labShell, settingRegistry, translator) => {
        const trans = (translator !== null && translator !== void 0 ? translator : translation_lib_index_js_.nullTranslator).load('jupyterlab');
        const first = app.started;
        const registry = app.commands;
        const mode = coreutils_lib_index_js_.PageConfig.getOption('mode');
        const restorer = new index_js_.LayoutRestorer({
            connector: state,
            first,
            registry,
            mode
        });
        settingRegistry
            .load(shell.id)
            .then(settings => {
            var _a, _b;
            // Add a layer of customization to support app shell mode
            const customizedLayout = settings.composite['layout'];
            // Restore the layout.
            void labShell
                .restoreLayout(mode, restorer, {
                'multiple-document': (_a = customizedLayout.multiple) !== null && _a !== void 0 ? _a : {},
                'single-document': (_b = customizedLayout.single) !== null && _b !== void 0 ? _b : {}
            })
                .then(() => {
                labShell.layoutModified.connect(() => {
                    void restorer.save(labShell.saveLayout());
                });
                settings.changed.connect(onSettingsChanged);
                Private.activateSidebarSwitcher(app, labShell, settings, trans);
            });
        })
            .catch(reason => {
            console.error('Fail to load settings for the layout restorer.');
            console.error(reason);
        });
        return restorer;
        async function onSettingsChanged(settings) {
            if (!dist_index_js_.JSONExt.deepEqual(settings.composite['layout'], {
                single: labShell.userLayout['single-document'],
                multiple: labShell.userLayout['multiple-document']
            })) {
                const result = await (0,lib_index_js_.showDialog)({
                    title: trans.__('Information'),
                    body: trans.__('User layout customization has changed. You may need to reload JupyterLab to see the changes.'),
                    buttons: [
                        lib_index_js_.Dialog.cancelButton(),
                        lib_index_js_.Dialog.okButton({ label: trans.__('Reload') })
                    ]
                });
                if (result.button.accept) {
                    location.reload();
                }
            }
        }
    },
    autoStart: true,
    provides: index_js_.ILayoutRestorer
};
/**
 * The default URL router provider.
 */
const router = {
    id: '@jupyterlab/application-extension:router',
    description: 'Provides the URL router',
    requires: [index_js_.JupyterFrontEnd.IPaths],
    activate: (app, paths) => {
        const { commands } = app;
        const base = paths.urls.base;
        const router = new index_js_.Router({ base, commands });
        void app.started.then(() => {
            // Route the very first request on load.
            void router.route();
            // Route all pop state events.
            window.addEventListener('popstate', () => {
                void router.route();
            });
        });
        return router;
    },
    autoStart: true,
    provides: index_js_.IRouter
};
/**
 * The default tree route resolver plugin.
 */
const tree = {
    id: '@jupyterlab/application-extension:tree-resolver',
    description: 'Provides the tree route resolver',
    autoStart: true,
    requires: [index_js_.IRouter],
    provides: index_js_.JupyterFrontEnd.ITreeResolver,
    activate: (app, router) => {
        const { commands } = app;
        const set = new disposable_dist_index_es6_js_.DisposableSet();
        const delegate = new dist_index_js_.PromiseDelegate();
        const treePattern = new RegExp('/(lab|doc)(/workspaces/[a-zA-Z0-9-_]+)?(/tree/.*)?');
        set.add(commands.addCommand(CommandIDs.tree, {
            execute: async (args) => {
                var _a;
                if (set.isDisposed) {
                    return;
                }
                const query = coreutils_lib_index_js_.URLExt.queryStringToObject((_a = args.search) !== null && _a !== void 0 ? _a : '');
                const browser = query['file-browser-path'] || '';
                // Remove the file browser path from the query string.
                delete query['file-browser-path'];
                // Clean up artifacts immediately upon routing.
                set.dispose();
                delegate.resolve({ browser, file: coreutils_lib_index_js_.PageConfig.getOption('treePath') });
            }
        }));
        set.add(router.register({ command: CommandIDs.tree, pattern: treePattern }));
        // If a route is handled by the router without the tree command being
        // invoked, resolve to `null` and clean up artifacts.
        const listener = () => {
            if (set.isDisposed) {
                return;
            }
            set.dispose();
            delegate.resolve(null);
        };
        router.routed.connect(listener);
        set.add(new disposable_dist_index_es6_js_.DisposableDelegate(() => {
            router.routed.disconnect(listener);
        }));
        return { paths: delegate.promise };
    }
};
/**
 * The default URL not found extension.
 */
const notfound = {
    id: '@jupyterlab/application-extension:notfound',
    description: 'Defines the behavior for not found URL (aka route).',
    requires: [index_js_.JupyterFrontEnd.IPaths, index_js_.IRouter, translation_lib_index_js_.ITranslator],
    activate: (_, paths, router, translator) => {
        const trans = translator.load('jupyterlab');
        const bad = paths.urls.notFound;
        if (!bad) {
            return;
        }
        const base = router.base;
        const message = trans.__('The path: %1 was not found. JupyterLab redirected to: %2', bad, base);
        // Change the URL back to the base application URL.
        router.navigate('');
        void (0,lib_index_js_.showErrorMessage)(trans.__('Path Not Found'), { message });
    },
    autoStart: true
};
/**
 * Change the favicon changing based on the busy status;
 */
const busy = {
    id: '@jupyterlab/application-extension:faviconbusy',
    description: 'Handles the favicon depending on the application status.',
    requires: [index_js_.ILabStatus],
    activate: async (_, status) => {
        status.busySignal.connect((_, isBusy) => {
            const favicon = document.querySelector(`link[rel="icon"]${isBusy ? '.idle.favicon' : '.busy.favicon'}`);
            if (!favicon) {
                return;
            }
            const newFavicon = document.querySelector(`link${isBusy ? '.busy.favicon' : '.idle.favicon'}`);
            if (!newFavicon) {
                return;
            }
            // If we have the two icons with the special classes, then toggle them.
            if (favicon !== newFavicon) {
                favicon.rel = '';
                newFavicon.rel = 'icon';
                // Firefox doesn't seem to recognize just changing rel, so we also
                // reinsert the link into the DOM.
                newFavicon.parentNode.replaceChild(newFavicon, newFavicon);
            }
        });
    },
    autoStart: true
};
/**
 * The default JupyterLab application shell.
 */
const shell = {
    id: '@jupyterlab/application-extension:shell',
    description: 'Provides the JupyterLab shell. It has an extended API compared to `app.shell`.',
    optional: [settingregistry_lib_index_js_.ISettingRegistry],
    activate: (app, settingRegistry) => {
        if (!(app.shell instanceof index_js_.LabShell)) {
            throw new Error(`${shell.id} did not find a LabShell instance.`);
        }
        if (settingRegistry) {
            void settingRegistry.load(shell.id).then(settings => {
                app.shell.updateConfig(settings.composite);
                settings.changed.connect(() => {
                    app.shell.updateConfig(settings.composite);
                });
            });
        }
        return app.shell;
    },
    autoStart: true,
    provides: index_js_.ILabShell
};
/**
 * The default JupyterLab application status provider.
 */
const lib_status = {
    id: '@jupyterlab/application-extension:status',
    description: 'Provides the application status.',
    activate: (app) => {
        if (!(app instanceof index_js_.JupyterLab)) {
            throw new Error(`${lib_status.id} must be activated in JupyterLab.`);
        }
        return app.status;
    },
    autoStart: true,
    provides: index_js_.ILabStatus
};
/**
 * The default JupyterLab application-specific information provider.
 *
 * #### Notes
 * This plugin should only be used by plugins that specifically need to access
 * JupyterLab application information, e.g., listing extensions that have been
 * loaded or deferred within JupyterLab.
 */
const info = {
    id: '@jupyterlab/application-extension:info',
    description: 'Provides the application information.',
    activate: (app) => {
        if (!(app instanceof index_js_.JupyterLab)) {
            throw new Error(`${info.id} must be activated in JupyterLab.`);
        }
        return app.info;
    },
    autoStart: true,
    provides: index_js_.JupyterLab.IInfo
};
/**
 * The default JupyterLab paths dictionary provider.
 */
const paths = {
    id: '@jupyterlab/application-extension:paths',
    description: 'Provides the application paths.',
    activate: (app) => {
        if (!(app instanceof index_js_.JupyterLab)) {
            throw new Error(`${paths.id} must be activated in JupyterLab.`);
        }
        return app.paths;
    },
    autoStart: true,
    provides: index_js_.JupyterFrontEnd.IPaths
};
/**
 * The default property inspector provider.
 */
const propertyInspector = {
    id: '@jupyterlab/application-extension:property-inspector',
    description: 'Provides the property inspector.',
    autoStart: true,
    requires: [index_js_.ILabShell, translation_lib_index_js_.ITranslator],
    optional: [index_js_.ILayoutRestorer],
    provides: property_inspector_lib_index_js_.IPropertyInspectorProvider,
    activate: (app, labshell, translator, restorer) => {
        const trans = translator.load('jupyterlab');
        const widget = new property_inspector_lib_index_js_.SideBarPropertyInspectorProvider({
            shell: labshell,
            translator
        });
        widget.title.icon = ui_components_lib_index_js_.buildIcon;
        widget.title.caption = trans.__('Property Inspector');
        widget.id = 'jp-property-inspector';
        labshell.add(widget, 'right', { rank: 100, type: 'Property Inspector' });
        app.commands.addCommand(CommandIDs.showPropertyPanel, {
            label: trans.__('Property Inspector'),
            execute: () => {
                labshell.activateById(widget.id);
            }
        });
        if (restorer) {
            restorer.add(widget, 'jp-property-inspector');
        }
        return widget;
    }
};
const jupyterLogo = {
    id: '@jupyterlab/application-extension:logo',
    description: 'Sets the application logo.',
    autoStart: true,
    requires: [index_js_.ILabShell],
    activate: (app, shell) => {
        const logo = new widgets_dist_index_es6_js_.Widget();
        ui_components_lib_index_js_.jupyterIcon.element({
            container: logo.node,
            elementPosition: 'center',
            margin: '2px 2px 2px 8px',
            height: 'auto',
            width: '16px'
        });
        logo.id = 'jp-MainLogo';
        shell.add(logo, 'top', { rank: 0 });
    }
};
/**
 * The simple interface mode switch in the status bar.
 */
const modeSwitchPlugin = {
    id: '@jupyterlab/application-extension:mode-switch',
    description: 'Adds the interface mode switch',
    requires: [index_js_.ILabShell, translation_lib_index_js_.ITranslator],
    optional: [statusbar_lib_index_js_.IStatusBar, settingregistry_lib_index_js_.ISettingRegistry],
    activate: (app, labShell, translator, statusBar, settingRegistry) => {
        if (statusBar === null) {
            // Bail early
            return;
        }
        const trans = translator.load('jupyterlab');
        const modeSwitch = new ui_components_lib_index_js_.Switch();
        modeSwitch.id = 'jp-single-document-mode';
        modeSwitch.valueChanged.connect((_, args) => {
            labShell.mode = args.newValue ? 'single-document' : 'multiple-document';
        });
        labShell.modeChanged.connect((_, mode) => {
            modeSwitch.value = mode === 'single-document';
        });
        if (settingRegistry) {
            const loadSettings = settingRegistry.load(shell.id);
            const updateSettings = (settings) => {
                const startMode = settings.get('startMode').composite;
                if (startMode) {
                    labShell.mode =
                        startMode === 'single' ? 'single-document' : 'multiple-document';
                }
            };
            Promise.all([loadSettings, app.restored])
                .then(([settings]) => {
                updateSettings(settings);
            })
                .catch((reason) => {
                console.error(reason.message);
            });
        }
        // Show the current file browser shortcut in its title.
        const updateModeSwitchTitle = () => {
            const binding = app.commands.keyBindings.find(b => b.command === 'application:toggle-mode');
            if (binding) {
                const ks = binding.keys.map(dist_index_es6_js_.CommandRegistry.formatKeystroke).join(', ');
                modeSwitch.caption = trans.__('Simple Interface (%1)', ks);
            }
            else {
                modeSwitch.caption = trans.__('Simple Interface');
            }
        };
        updateModeSwitchTitle();
        app.commands.keyBindingChanged.connect(() => {
            updateModeSwitchTitle();
        });
        modeSwitch.label = trans.__('Simple');
        statusBar.registerStatusItem(modeSwitchPlugin.id, {
            priority: 1,
            item: modeSwitch,
            align: 'left',
            rank: -1
        });
    },
    autoStart: true
};
/**
 * Export the plugins as default.
 */
const plugins = [
    contextMenuPlugin,
    dirty,
    main,
    mainCommands,
    layout,
    router,
    tree,
    notfound,
    busy,
    shell,
    lib_status,
    info,
    modeSwitchPlugin,
    paths,
    propertyInspector,
    jupyterLogo,
    topbar
];
/* harmony default export */ const lib = (plugins);
var Private;
(function (Private) {
    async function displayInformation(trans) {
        const result = await (0,lib_index_js_.showDialog)({
            title: trans.__('Information'),
            body: trans.__('Context menu customization has changed. You will need to reload JupyterLab to see the changes.'),
            buttons: [
                lib_index_js_.Dialog.cancelButton(),
                lib_index_js_.Dialog.okButton({ label: trans.__('Reload') })
            ]
        });
        if (result.button.accept) {
            location.reload();
        }
    }
    async function loadSettingsContextMenu(contextMenu, commands, registry, menuFactory, translator) {
        var _a;
        const trans = translator.load('jupyterlab');
        const pluginId = contextMenuPlugin.id;
        let canonical = null;
        let loaded = {};
        /**
         * Populate the plugin's schema defaults.
         *
         * We keep track of disabled entries in case the plugin is loaded
         * after the menu initialization.
         */
        function populate(schema) {
            var _a, _b;
            loaded = {};
            const pluginDefaults = Object.keys(registry.plugins)
                .map(plugin => {
                var _a, _b;
                const items = (_b = (_a = registry.plugins[plugin].schema['jupyter.lab.menus']) === null || _a === void 0 ? void 0 : _a.context) !== null && _b !== void 0 ? _b : [];
                loaded[plugin] = items;
                return items;
            })
                .concat([(_b = (_a = schema['jupyter.lab.menus']) === null || _a === void 0 ? void 0 : _a.context) !== null && _b !== void 0 ? _b : []])
                .reduceRight((acc, val) => settingregistry_lib_index_js_.SettingRegistry.reconcileItems(acc, val, true), []);
            // Apply default value as last step to take into account overrides.json
            // The standard default being [] as the plugin must use `jupyter.lab.menus.context`
            // to define their default value.
            schema.properties.contextMenu.default = settingregistry_lib_index_js_.SettingRegistry.reconcileItems(pluginDefaults, schema.properties.contextMenu.default, true)
                // flatten one level
                .sort((a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b.rank) !== null && _b !== void 0 ? _b : Infinity); });
        }
        // Transform the plugin object to return different schema than the default.
        registry.transform(pluginId, {
            compose: plugin => {
                var _a, _b, _c, _d;
                // Only override the canonical schema the first time.
                if (!canonical) {
                    canonical = dist_index_js_.JSONExt.deepCopy(plugin.schema);
                    populate(canonical);
                }
                const defaults = (_c = (_b = (_a = canonical.properties) === null || _a === void 0 ? void 0 : _a.contextMenu) === null || _b === void 0 ? void 0 : _b.default) !== null && _c !== void 0 ? _c : [];
                const user = {
                    ...plugin.data.user,
                    contextMenu: (_d = plugin.data.user.contextMenu) !== null && _d !== void 0 ? _d : []
                };
                const composite = {
                    ...plugin.data.composite,
                    contextMenu: settingregistry_lib_index_js_.SettingRegistry.reconcileItems(defaults, user.contextMenu, false)
                };
                plugin.data = { composite, user };
                return plugin;
            },
            fetch: plugin => {
                // Only override the canonical schema the first time.
                if (!canonical) {
                    canonical = dist_index_js_.JSONExt.deepCopy(plugin.schema);
                    populate(canonical);
                }
                return {
                    data: plugin.data,
                    id: plugin.id,
                    raw: plugin.raw,
                    schema: canonical,
                    version: plugin.version
                };
            }
        });
        // Repopulate the canonical variable after the setting registry has
        // preloaded all initial plugins.
        const settings = await registry.load(pluginId);
        // Set the suppress flag on document.body if necessary.
        const setDisabled = (settings) => {
            const root = document.body;
            const isDisabled = root.hasAttribute('data-jp-suppress-context-menu');
            const shouldDisable = settings.get('disabled').composite;
            if (isDisabled && !shouldDisable) {
                root.removeAttribute('data-jp-suppress-context-menu');
            }
            else if (shouldDisable && !isDisabled) {
                root.setAttribute('data-jp-suppress-context-menu', 'true');
            }
        };
        const contextItems = (_a = settings.composite.contextMenu) !== null && _a !== void 0 ? _a : [];
        // Create menu item for non-disabled element
        settingregistry_lib_index_js_.SettingRegistry.filterDisabledItems(contextItems).forEach(item => {
            lib_index_js_.MenuFactory.addContextItem({
                // We have to set the default rank because Lumino is sorting the visible items
                rank: DEFAULT_CONTEXT_ITEM_RANK,
                ...item
            }, contextMenu, menuFactory);
        });
        settings.changed.connect(() => {
            var _a;
            // As extension may change the context menu through API,
            // prompt the user to reload if the menu has been updated.
            const newItems = (_a = settings.composite.contextMenu) !== null && _a !== void 0 ? _a : [];
            if (!dist_index_js_.JSONExt.deepEqual(contextItems, newItems)) {
                void displayInformation(trans);
            }
            setDisabled(settings);
        });
        registry.pluginChanged.connect(async (sender, plugin) => {
            var _a, _b, _c, _d;
            if (plugin !== pluginId) {
                // If the plugin changed its menu.
                const oldItems = (_a = loaded[plugin]) !== null && _a !== void 0 ? _a : [];
                const newItems = (_c = (_b = registry.plugins[plugin].schema['jupyter.lab.menus']) === null || _b === void 0 ? void 0 : _b.context) !== null && _c !== void 0 ? _c : [];
                if (!dist_index_js_.JSONExt.deepEqual(oldItems, newItems)) {
                    if (loaded[plugin]) {
                        // The plugin has changed, request the user to reload the UI
                        await displayInformation(trans);
                    }
                    else {
                        // The plugin was not yet loaded when the menu was built => update the menu
                        loaded[plugin] = dist_index_js_.JSONExt.deepCopy(newItems);
                        // Merge potential disabled state
                        const toAdd = (_d = settingregistry_lib_index_js_.SettingRegistry.reconcileItems(newItems, contextItems, false, false)) !== null && _d !== void 0 ? _d : [];
                        settingregistry_lib_index_js_.SettingRegistry.filterDisabledItems(toAdd).forEach(item => {
                            lib_index_js_.MenuFactory.addContextItem({
                                // We have to set the default rank because Lumino is sorting the visible items
                                rank: DEFAULT_CONTEXT_ITEM_RANK,
                                ...item
                            }, contextMenu, menuFactory);
                        });
                    }
                }
            }
        });
        // Handle disabled status.
        setDisabled(settings);
        commands.addCommand(CommandIDs.toggleContextMenu, {
            label: trans.__('Enable Context Menu'),
            isToggleable: true,
            isToggled: () => !settings.get('disabled').composite,
            execute: () => void settings.set('disabled', !settings.get('disabled').composite)
        });
    }
    Private.loadSettingsContextMenu = loadSettingsContextMenu;
    function activateSidebarSwitcher(app, labShell, settings, trans) {
        // Add a command to switch a side panels's side
        app.commands.addCommand(CommandIDs.switchSidebar, {
            label: trans.__('Switch Sidebar Side'),
            execute: () => {
                // First, try to find the correct panel based on the application
                // context menu click. Bail if we don't find a sidebar for the widget.
                const contextNode = app.contextMenuHitTest(node => !!node.dataset.id);
                if (!contextNode) {
                    return;
                }
                const id = contextNode.dataset['id'];
                const leftPanel = document.getElementById('jp-left-stack');
                const node = document.getElementById(id);
                let newLayout = null;
                // Move the panel to the other side.
                if (leftPanel && node && leftPanel.contains(node)) {
                    const widget = (0,index_es6_js_.find)(labShell.widgets('left'), w => w.id === id);
                    if (widget) {
                        newLayout = labShell.move(widget, 'right');
                        labShell.activateById(widget.id);
                    }
                }
                else {
                    const widget = (0,index_es6_js_.find)(labShell.widgets('right'), w => w.id === id);
                    if (widget) {
                        newLayout = labShell.move(widget, 'left');
                        labShell.activateById(widget.id);
                    }
                }
                if (newLayout) {
                    settings
                        .set('layout', {
                        single: newLayout['single-document'],
                        multiple: newLayout['multiple-document']
                    })
                        .catch(reason => {
                        console.error('Failed to save user layout customization.', reason);
                    });
                }
            }
        });
        app.commands.commandExecuted.connect((registry, executed) => {
            if (executed.id === CommandIDs.resetLayout) {
                settings.remove('layout').catch(reason => {
                    console.error('Failed to remove user layout customization.', reason);
                });
            }
        });
    }
    Private.activateSidebarSwitcher = activateSidebarSwitcher;
})(Private || (Private = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 32723:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// EXTERNAL MODULE: ../node_modules/@lumino/widgets/style/index.js + 1 modules
var style = __webpack_require__(20959);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/ui-components/style/index.js + 1 modules
var ui_components_style = __webpack_require__(26238);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/statusbar/style/index.js + 1 modules
var statusbar_style = __webpack_require__(25066);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/application/style/index.js + 1 modules
var application_style = __webpack_require__(67663);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/property-inspector/style/index.js + 1 modules
var property_inspector_style = __webpack_require__(62374);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(94830);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(80592);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(99763);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(28915);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(80366);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(17352);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/css-loader/dist/cjs.js!../node_modules/@jupyterlab/application-extension/style/base.css
var base = __webpack_require__(6347);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application-extension/style/base.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(base/* default */.Z, options);




       /* harmony default export */ const style_base = (base/* default */.Z && base/* default */.Z.locals ? base/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application-extension/style/index.js
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* This file was auto-generated by ensurePackage() in @jupyterlab/buildutils */









/***/ }),

/***/ 76853:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ConnectionLost: () => (/* reexport */ ConnectionLost),
  IConnectionLost: () => (/* reexport */ IConnectionLost),
  ILabShell: () => (/* reexport */ ILabShell),
  ILabStatus: () => (/* reexport */ ILabStatus),
  ILayoutRestorer: () => (/* reexport */ layoutrestorer/* ILayoutRestorer */.L),
  IMimeDocumentTracker: () => (/* reexport */ mimerenderers/* IMimeDocumentTracker */.w2),
  IRouter: () => (/* reexport */ IRouter),
  ITreePathUpdater: () => (/* reexport */ ITreePathUpdater),
  JupyterFrontEnd: () => (/* reexport */ JupyterFrontEnd),
  JupyterFrontEndContextMenu: () => (/* reexport */ JupyterFrontEndContextMenu),
  JupyterLab: () => (/* reexport */ JupyterLab),
  LabShell: () => (/* reexport */ LabShell),
  LabStatus: () => (/* reexport */ lib_status/* LabStatus */.J),
  LayoutRestorer: () => (/* reexport */ layoutrestorer/* LayoutRestorer */.c),
  Router: () => (/* reexport */ Router),
  addSemanticCommand: () => (/* reexport */ addSemanticCommand),
  createRendermimePlugin: () => (/* reexport */ mimerenderers/* createRendermimePlugin */.aX),
  createRendermimePlugins: () => (/* reexport */ mimerenderers/* createRendermimePlugins */.as),
  createSemanticCommand: () => (/* reexport */ createSemanticCommand)
});

// EXTERNAL MODULE: consume shared module (default) @jupyterlab/apputils@~4.5.3 (singleton) (fallback: ../node_modules/@jupyterlab/apputils/lib/index.js)
var index_js_ = __webpack_require__(94079);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/translation@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/translation/lib/index.js)
var lib_index_js_ = __webpack_require__(50856);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/lib/connectionlost.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * A default connection lost handler, which brings up an error dialog.
 */
const ConnectionLost = async function (manager, err, translator) {
    translator = translator || lib_index_js_.nullTranslator;
    const trans = translator.load('jupyterlab');
    const title = trans.__('Server Connection Error');
    const networkMsg = trans.__('A connection to the Jupyter server could not be established.\n' +
        'JupyterLab will continue trying to reconnect.\n' +
        'Check your network connection or Jupyter server configuration.\n');
    if (!Private.displayConnectionLost) {
        return;
    }
    if (Private.serverConnectionLost) {
        // Wait for the pre-existing promise to complete
        await Private.serverConnectionLost;
        return;
    }
    const dialog = (0,index_js_.showDialog)({
        title: title,
        body: networkMsg,
        checkbox: {
            label: trans.__('Do not show this message again in this session.'),
            caption: trans.__('If checked, you will not see a dialog informing you about an issue with server connection in this session.')
        },
        buttons: [index_js_.Dialog.cancelButton({ label: trans.__('Close') })]
    })
        .then(result => {
        if (result.isChecked) {
            Private.displayConnectionLost = false;
        }
        return;
    })
        .catch(error => {
        console.error('An error occurred while showing the dialog: ', error);
    })
        .finally(() => {
        Private.serverConnectionLost = undefined;
    });
    Private.serverConnectionLost = dialog;
};
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Boolean determining if connection lost dialog is displayed.
     */
    Private.displayConnectionLost = true;
})(Private || (Private = {}));
//# sourceMappingURL=connectionlost.js.map
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/docregistry@~4.4.3 (strict) (fallback: ../node_modules/@jupyterlab/docregistry/lib/index.js)
var docregistry_lib_index_js_ = __webpack_require__(74886);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/services@~7.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/services/lib/index.js)
var services_lib_index_js_ = __webpack_require__(43234);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/ui-components@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/ui-components/lib/index.js)
var ui_components_lib_index_js_ = __webpack_require__(39089);
// EXTERNAL MODULE: consume shared module (default) @lumino/application@~2.4.4 (singleton) (fallback: ../node_modules/@lumino/application/dist/index.es6.js)
var index_es6_js_ = __webpack_require__(68257);
// EXTERNAL MODULE: consume shared module (default) @lumino/coreutils@~2.2.1 (singleton) (fallback: ../node_modules/@lumino/coreutils/dist/index.js)
var dist_index_js_ = __webpack_require__(5406);
// EXTERNAL MODULE: consume shared module (default) @lumino/signaling@~2.1.4 (singleton) (fallback: ../node_modules/@lumino/signaling/dist/index.es6.js)
var dist_index_es6_js_ = __webpack_require__(2536);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/lib/frontend.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







/**
 * The base Jupyter front-end application class.
 *
 * @typeparam `T` - The `shell` type. Defaults to `JupyterFrontEnd.IShell`.
 *
 * @typeparam `U` - The type for supported format names. Defaults to `string`.
 *
 * #### Notes
 * This type is useful as a generic application against which front-end plugins
 * can be authored. It inherits from the Lumino `Application`.
 */
class JupyterFrontEnd extends index_es6_js_.Application {
    /**
     * Construct a new JupyterFrontEnd object.
     */
    constructor(options) {
        super(options);
        this._formatChanged = new dist_index_es6_js_.Signal(this);
        // Class to scope global Jupyter CSS rules
        options.shell.addClass('jp-ThemedContainer');
        // render context menu/submenus with inline svg icon tweaks
        this.contextMenu = new ui_components_lib_index_js_.ContextMenuSvg({
            commands: this.commands,
            renderer: options.contextMenuRenderer,
            groupByTarget: false,
            sortBySelector: false
        });
        // The default restored promise if one does not exist in the options.
        const restored = new Promise(resolve => {
            requestAnimationFrame(() => {
                resolve();
            });
        });
        this.commandLinker =
            options.commandLinker || new index_js_.CommandLinker({ commands: this.commands });
        this.docRegistry = options.docRegistry || new docregistry_lib_index_js_.DocumentRegistry();
        this.restored =
            options.restored ||
                this.started.then(() => restored).catch(() => restored);
        this.serviceManager = options.serviceManager || new services_lib_index_js_.ServiceManager();
    }
    /**
     * The application form factor, e.g., `desktop` or `mobile`.
     */
    get format() {
        return this._format;
    }
    set format(format) {
        if (this._format !== format) {
            this._format = format;
            document.body.dataset['format'] = format;
            this._formatChanged.emit(format);
        }
    }
    /**
     * A signal that emits when the application form factor changes.
     */
    get formatChanged() {
        return this._formatChanged;
    }
    /**
     * Walks up the DOM hierarchy of the target of the active `contextmenu`
     * event, testing each HTMLElement ancestor for a user-supplied function. This can
     * be used to find an HTMLElement on which to operate, given a context menu click.
     *
     * @param fn - a function that takes an `HTMLElement` and returns a
     *   boolean for whether it is the element the requester is seeking.
     *
     * @returns an HTMLElement or undefined, if none is found.
     */
    contextMenuHitTest(fn) {
        if (!this._contextMenuEvent ||
            !(this._contextMenuEvent.target instanceof Node)) {
            return undefined;
        }
        let node = this._contextMenuEvent.target;
        do {
            if (node instanceof HTMLElement && fn(node)) {
                return node;
            }
            node = node.parentNode;
        } while (node && node.parentNode && node !== node.parentNode);
        return undefined;
        // TODO: we should be able to use .composedPath() to simplify this function
        // down to something like the below, but it seems like composedPath is
        // sometimes returning an empty list.
        /*
        if (this._contextMenuEvent) {
          this._contextMenuEvent
            .composedPath()
            .filter(x => x instanceof HTMLElement)
            .find(test);
        }
        return undefined;
        */
    }
    /**
     * A method invoked on a document `'contextmenu'` event.
     */
    evtContextMenu(event) {
        this._contextMenuEvent = event;
        if (event.shiftKey ||
            frontend_Private.suppressContextMenu(event.target)) {
            return;
        }
        const opened = this.contextMenu.open(event);
        if (opened) {
            const items = this.contextMenu.menu.items;
            // If only the context menu information will be shown,
            // with no real commands, close the context menu and
            // allow the native one to open.
            if (items.length === 1 &&
                items[0].command === JupyterFrontEndContextMenu.contextMenu) {
                this.contextMenu.menu.close();
                return;
            }
            // Stop propagation and allow the application context menu to show.
            event.preventDefault();
            event.stopPropagation();
        }
    }
}
/**
 * The namespace for `JupyterFrontEnd` class statics.
 */
(function (JupyterFrontEnd) {
    /**
     * Is JupyterLab in document mode?
     *
     * @param path - Full URL of JupyterLab
     * @param paths - The current IPaths object hydrated from PageConfig.
     */
    function inDocMode(path, paths) {
        const docPattern = new RegExp(`^${paths.urls.doc}`);
        const match = path.match(docPattern);
        if (match) {
            return true;
        }
        else {
            return false;
        }
    }
    JupyterFrontEnd.inDocMode = inDocMode;
    /**
     * The application paths dictionary token.
     */
    JupyterFrontEnd.IPaths = new dist_index_js_.Token('@jupyterlab/application:IPaths', `A service providing information about various
  URLs and server paths for the current application. Use this service if you want to
  assemble URLs to use the JupyterLab REST API.`);
    /**
     * The application tree resolver token.
     *
     * #### Notes
     * Not all Jupyter front-end applications will have a tree resolver
     * implemented on the client-side. This token should not be required as a
     * dependency if it is possible to make it an optional dependency.
     */
    JupyterFrontEnd.ITreeResolver = new dist_index_js_.Token('@jupyterlab/application:ITreeResolver', 'A service to resolve the tree path.');
})(JupyterFrontEnd || (JupyterFrontEnd = {}));
/**
 * A namespace for module-private functionality.
 */
var frontend_Private;
(function (Private) {
    /**
     * Returns whether the element is itself, or a child of, an element with the `jp-suppress-context-menu` data attribute.
     */
    function suppressContextMenu(element) {
        return element.closest('[data-jp-suppress-context-menu]') !== null;
    }
    Private.suppressContextMenu = suppressContextMenu;
})(frontend_Private || (frontend_Private = {}));
/**
 * A namespace for the context menu override.
 */
var JupyterFrontEndContextMenu;
(function (JupyterFrontEndContextMenu) {
    /**
     * An id for a private context-menu-info ersatz command.
     */
    JupyterFrontEndContextMenu.contextMenu = '__internal:context-menu-info';
})(JupyterFrontEndContextMenu || (JupyterFrontEndContextMenu = {}));
//# sourceMappingURL=frontend.js.map
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/coreutils@~6.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/coreutils/lib/index.js)
var coreutils_lib_index_js_ = __webpack_require__(60649);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/application/lib/mimerenderers.js
var mimerenderers = __webpack_require__(75677);
// EXTERNAL MODULE: consume shared module (default) @lumino/algorithm@~2.0.3 (singleton) (fallback: ../node_modules/@lumino/algorithm/dist/index.es6.js)
var algorithm_dist_index_es6_js_ = __webpack_require__(56114);
// EXTERNAL MODULE: consume shared module (default) @lumino/messaging@~2.0.3 (singleton) (fallback: ../node_modules/@lumino/messaging/dist/index.es6.js)
var messaging_dist_index_es6_js_ = __webpack_require__(34993);
// EXTERNAL MODULE: consume shared module (default) @lumino/polling@^2.1.4 (strict) (fallback: ../node_modules/@lumino/polling/dist/index.es6.js)
var polling_dist_index_es6_js_ = __webpack_require__(1492);
// EXTERNAL MODULE: consume shared module (default) @lumino/widgets@~2.7.1 (singleton) (fallback: ../node_modules/@lumino/widgets/dist/index.es6.js)
var widgets_dist_index_es6_js_ = __webpack_require__(60920);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/lib/shell.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.









/**
 * The class name added to AppShell instances.
 */
const APPLICATION_SHELL_CLASS = 'jp-LabShell';
/**
 * The class name added to side bar instances.
 */
const SIDEBAR_CLASS = 'jp-SideBar';
/**
 * The class name added to the current widget's title.
 */
const CURRENT_CLASS = 'jp-mod-current';
/**
 * The class name added to the active widget's title.
 */
const ACTIVE_CLASS = 'jp-mod-active';
/**
 * The default rank of items added to a sidebar.
 */
const DEFAULT_RANK = 900;
const ACTIVITY_CLASS = 'jp-Activity';
/**
 * The JupyterLab application shell token.
 */
const ILabShell = new dist_index_js_.Token('@jupyterlab/application:ILabShell', 'A service for interacting with the JupyterLab shell. The top-level ``application`` object also has a reference to the shell, but it has a restricted interface in order to be agnostic to different shell implementations on the application. Use this to get more detailed information about currently active widgets and layout state.');
/**
 * The application shell for JupyterLab.
 */
class LabShell extends widgets_dist_index_es6_js_.Widget {
    /**
     * Construct a new application shell.
     */
    constructor(options) {
        super();
        /**
         * A message hook for child add/remove messages on the main area dock panel.
         */
        this._dockChildHook = (handler, msg) => {
            switch (msg.type) {
                case 'child-added':
                    msg.child.addClass(ACTIVITY_CLASS);
                    this._tracker.add(msg.child);
                    break;
                case 'child-removed':
                    msg.child.removeClass(ACTIVITY_CLASS);
                    this._tracker.remove(msg.child);
                    break;
                default:
                    break;
            }
            return true;
        };
        this._activeChanged = new dist_index_es6_js_.Signal(this);
        this._cachedLayout = null;
        this._currentChanged = new dist_index_es6_js_.Signal(this);
        this._currentPath = '';
        this._currentPathChanged = new dist_index_es6_js_.Signal(this);
        this._modeChanged = new dist_index_es6_js_.Signal(this);
        this._isRestored = false;
        this._layoutModified = new dist_index_es6_js_.Signal(this);
        this._layoutDebouncer = new polling_dist_index_es6_js_.Debouncer(() => {
            this._layoutModified.emit(undefined);
        }, 0);
        this._restored = new dist_index_js_.PromiseDelegate();
        this._tracker = new widgets_dist_index_es6_js_.FocusTracker();
        this._topHandlerHiddenByUser = false;
        this._idTypeMap = new Map();
        this._mainOptionsCache = new Map();
        this._sideOptionsCache = new Map();
        this._delayedWidget = new Array();
        this.addClass(APPLICATION_SHELL_CLASS);
        this.id = 'main';
        if ((options === null || options === void 0 ? void 0 : options.waitForRestore) === false) {
            this._userLayout = { 'multiple-document': {}, 'single-document': {} };
        }
        // Skip Links
        const skipLinkWidget = (this._skipLinkWidget = new shell_Private.SkipLinkWidget(this));
        this._skipLinkWidget.show();
        //  Wrap the skip widget to customize its position and size
        const skipLinkWrapper = new widgets_dist_index_es6_js_.Panel();
        skipLinkWrapper.addClass('jp-skiplink-wrapper');
        skipLinkWrapper.addWidget(skipLinkWidget);
        const headerPanel = (this._headerPanel = new widgets_dist_index_es6_js_.BoxPanel());
        const menuHandler = (this._menuHandler = new shell_Private.PanelHandler());
        menuHandler.panel.node.setAttribute('role', 'navigation');
        const topHandler = (this._topHandler = new shell_Private.PanelHandler());
        topHandler.panel.node.setAttribute('role', 'banner');
        const bottomPanel = (this._bottomPanel = new widgets_dist_index_es6_js_.BoxPanel());
        bottomPanel.node.setAttribute('role', 'contentinfo');
        const hboxPanel = new widgets_dist_index_es6_js_.BoxPanel();
        const vsplitPanel = (this._vsplitPanel =
            new shell_Private.RestorableSplitPanel());
        const dockPanel = (this._dockPanel = new ui_components_lib_index_js_.DockPanelSvg({
            hiddenMode: widgets_dist_index_es6_js_.Widget.HiddenMode.Display
        }));
        messaging_dist_index_es6_js_.MessageLoop.installMessageHook(dockPanel, this._dockChildHook);
        const hsplitPanel = (this._hsplitPanel =
            new shell_Private.RestorableSplitPanel());
        const downPanel = (this._downPanel = new ui_components_lib_index_js_.TabPanelSvg({
            tabsMovable: true
        }));
        const leftHandler = (this._leftHandler = new shell_Private.SideBarHandler());
        const rightHandler = (this._rightHandler = new shell_Private.SideBarHandler());
        const rootLayout = new widgets_dist_index_es6_js_.BoxLayout();
        headerPanel.id = 'jp-header-panel';
        menuHandler.panel.id = 'jp-menu-panel';
        topHandler.panel.id = 'jp-top-panel';
        bottomPanel.id = 'jp-bottom-panel';
        hboxPanel.id = 'jp-main-content-panel';
        vsplitPanel.id = 'jp-main-vsplit-panel';
        dockPanel.id = 'jp-main-dock-panel';
        hsplitPanel.id = 'jp-main-split-panel';
        downPanel.id = 'jp-down-stack';
        leftHandler.sideBar.addClass(SIDEBAR_CLASS);
        leftHandler.sideBar.addClass('jp-mod-left');
        leftHandler.sideBar.node.setAttribute('role', 'complementary');
        leftHandler.stackedPanel.id = 'jp-left-stack';
        rightHandler.sideBar.addClass(SIDEBAR_CLASS);
        rightHandler.sideBar.addClass('jp-mod-right');
        rightHandler.sideBar.node.setAttribute('role', 'complementary');
        rightHandler.stackedPanel.id = 'jp-right-stack';
        dockPanel.node.setAttribute('role', 'main');
        hboxPanel.spacing = 0;
        vsplitPanel.spacing = 1;
        dockPanel.spacing = 5;
        hsplitPanel.spacing = 1;
        headerPanel.direction = 'top-to-bottom';
        vsplitPanel.orientation = 'vertical';
        hboxPanel.direction = 'left-to-right';
        hsplitPanel.orientation = 'horizontal';
        bottomPanel.direction = 'bottom-to-top';
        widgets_dist_index_es6_js_.SplitPanel.setStretch(leftHandler.stackedPanel, 0);
        widgets_dist_index_es6_js_.SplitPanel.setStretch(downPanel, 0);
        widgets_dist_index_es6_js_.SplitPanel.setStretch(dockPanel, 1);
        widgets_dist_index_es6_js_.SplitPanel.setStretch(rightHandler.stackedPanel, 0);
        widgets_dist_index_es6_js_.BoxPanel.setStretch(leftHandler.sideBar, 0);
        widgets_dist_index_es6_js_.BoxPanel.setStretch(hsplitPanel, 1);
        widgets_dist_index_es6_js_.BoxPanel.setStretch(rightHandler.sideBar, 0);
        widgets_dist_index_es6_js_.SplitPanel.setStretch(vsplitPanel, 1);
        hsplitPanel.addWidget(leftHandler.stackedPanel);
        hsplitPanel.addWidget(dockPanel);
        hsplitPanel.addWidget(rightHandler.stackedPanel);
        vsplitPanel.addWidget(hsplitPanel);
        vsplitPanel.addWidget(downPanel);
        hboxPanel.addWidget(leftHandler.sideBar);
        hboxPanel.addWidget(vsplitPanel);
        hboxPanel.addWidget(rightHandler.sideBar);
        rootLayout.direction = 'top-to-bottom';
        rootLayout.spacing = 0; // TODO make this configurable?
        // Use relative sizing to set the width of the side panels.
        // This will still respect the min-size of children widget in the stacked
        // panel. The default sizes will be overwritten during layout restoration.
        vsplitPanel.setRelativeSizes([3, 1]);
        hsplitPanel.setRelativeSizes([1, 2.5, 1]);
        widgets_dist_index_es6_js_.BoxLayout.setStretch(headerPanel, 0);
        widgets_dist_index_es6_js_.BoxLayout.setStretch(menuHandler.panel, 0);
        widgets_dist_index_es6_js_.BoxLayout.setStretch(topHandler.panel, 0);
        widgets_dist_index_es6_js_.BoxLayout.setStretch(hboxPanel, 1);
        widgets_dist_index_es6_js_.BoxLayout.setStretch(bottomPanel, 0);
        rootLayout.addWidget(skipLinkWrapper);
        rootLayout.addWidget(headerPanel);
        rootLayout.addWidget(topHandler.panel);
        rootLayout.addWidget(hboxPanel);
        rootLayout.addWidget(bottomPanel);
        // initially hiding header and bottom panel when no elements inside,
        this._headerPanel.hide();
        this._bottomPanel.hide();
        this._downPanel.hide();
        this.layout = rootLayout;
        // Connect change listeners.
        this._tracker.currentChanged.connect(this._onCurrentChanged, this);
        this._tracker.activeChanged.connect(this._onActiveChanged, this);
        // Connect main layout change listener.
        this._dockPanel.layoutModified.connect(this._onLayoutModified, this);
        // Connect vsplit layout change listener
        this._vsplitPanel.updated.connect(this._onLayoutModified, this);
        // Connect down panel change listeners
        this._downPanel.currentChanged.connect(this._onLayoutModified, this);
        this._downPanel.tabBar.tabMoved.connect(this._onTabPanelChanged, this);
        this._downPanel.stackedPanel.widgetRemoved.connect(this._onTabPanelChanged, this);
        // Catch current changed events on the side handlers.
        this._leftHandler.updated.connect(this._onLayoutModified, this);
        this._rightHandler.updated.connect(this._onLayoutModified, this);
        // Catch update events on the horizontal split panel
        this._hsplitPanel.updated.connect(this._onLayoutModified, this);
        // Setup single-document-mode title bar
        const titleHandler = (this._titleHandler = new shell_Private.TitleHandler(this));
        this.add(titleHandler, 'top', { rank: 100 });
        if (this._dockPanel.mode === 'multiple-document') {
            this._topHandler.addWidget(this._menuHandler.panel, 100);
            titleHandler.hide();
        }
        else {
            rootLayout.insertWidget(3, this._menuHandler.panel);
        }
        this.translator = lib_index_js_.nullTranslator;
        // Wire up signals to update the title panel of the simple interface mode to
        // follow the title of this.currentWidget
        this.currentChanged.connect((sender, args) => {
            let newValue = args.newValue;
            let oldValue = args.oldValue;
            // Stop watching the title of the previously current widget
            if (oldValue) {
                oldValue.title.changed.disconnect(this._updateTitlePanelTitle, this);
                if (oldValue instanceof docregistry_lib_index_js_.DocumentWidget) {
                    oldValue.context.pathChanged.disconnect(this._updateCurrentPath, this);
                }
            }
            // Start watching the title of the new current widget
            if (newValue) {
                newValue.title.changed.connect(this._updateTitlePanelTitle, this);
                this._updateTitlePanelTitle();
                if (newValue instanceof docregistry_lib_index_js_.DocumentWidget) {
                    newValue.context.pathChanged.connect(this._updateCurrentPath, this);
                }
            }
            this._updateCurrentPath();
        });
    }
    /**
     * A signal emitted when main area's active focus changes.
     */
    get activeChanged() {
        return this._activeChanged;
    }
    /**
     * The active widget in the shell's main area.
     */
    get activeWidget() {
        return this._tracker.activeWidget;
    }
    /**
     * Whether the add buttons for each main area tab bar are enabled.
     */
    get addButtonEnabled() {
        return this._dockPanel.addButtonEnabled;
    }
    set addButtonEnabled(value) {
        this._dockPanel.addButtonEnabled = value;
    }
    /**
     * A signal emitted when the add button on a main area tab bar is clicked.
     */
    get addRequested() {
        return this._dockPanel.addRequested;
    }
    /**
     * A signal emitted when main area's current focus changes.
     */
    get currentChanged() {
        return this._currentChanged;
    }
    /**
     * Current document path.
     */
    // FIXME deprecation `undefined` is to ensure backward compatibility in 4.x
    get currentPath() {
        return this._currentPath;
    }
    /**
     * A signal emitted when the path of the current document changes.
     *
     * This also fires when the current document itself changes.
     */
    get currentPathChanged() {
        return this._currentPathChanged;
    }
    /**
     * The current widget in the shell's main area.
     */
    get currentWidget() {
        return this._tracker.currentWidget;
    }
    /**
     * A signal emitted when the main area's layout is modified.
     */
    get layoutModified() {
        return this._layoutModified;
    }
    /**
     * Whether the left area is collapsed.
     */
    get leftCollapsed() {
        return !this._leftHandler.sideBar.currentTitle;
    }
    /**
     * Whether the left area is collapsed.
     */
    get rightCollapsed() {
        return !this._rightHandler.sideBar.currentTitle;
    }
    /**
     * Whether JupyterLab is in presentation mode with the
     * `jp-mod-presentationMode` CSS class.
     */
    get presentationMode() {
        return this.hasClass('jp-mod-presentationMode');
    }
    set presentationMode(value) {
        this.toggleClass('jp-mod-presentationMode', value);
    }
    /**
     * The main dock area's user interface mode.
     */
    get mode() {
        return this._dockPanel.mode;
    }
    set mode(mode) {
        const dock = this._dockPanel;
        if (mode === dock.mode) {
            return;
        }
        const applicationCurrentWidget = this.currentWidget;
        if (mode === 'single-document') {
            // Cache the current multi-document layout before changing the mode.
            this._cachedLayout = dock.saveLayout();
            dock.mode = mode;
            // In case the active widget in the dock panel is *not* the active widget
            // of the application, defer to the application.
            if (this.currentWidget) {
                dock.activateWidget(this.currentWidget);
            }
            // Adjust menu and title
            this.layout.insertWidget(3, this._menuHandler.panel);
            this._titleHandler.show();
            this._updateTitlePanelTitle();
            if (this._topHandlerHiddenByUser) {
                this._topHandler.panel.hide();
            }
        }
        else {
            // Cache a reference to every widget currently in the dock panel before
            // changing its mode.
            const widgets = Array.from(dock.widgets());
            dock.mode = mode;
            // Restore cached layout if possible.
            if (this._cachedLayout) {
                // Remove any disposed widgets in the cached layout and restore.
                shell_Private.normalizeAreaConfig(dock, this._cachedLayout.main);
                dock.restoreLayout(this._cachedLayout);
                this._cachedLayout = null;
            }
            // If layout restoration has been deferred, restore layout now.
            if (this._layoutRestorer.isDeferred) {
                this._layoutRestorer
                    .restoreDeferred()
                    .then(mainArea => {
                    if (mainArea) {
                        const { currentWidget, dock } = mainArea;
                        if (dock) {
                            this._dockPanel.restoreLayout(dock);
                        }
                        if (currentWidget) {
                            this.activateById(currentWidget.id);
                        }
                    }
                })
                    .catch(reason => {
                    console.error('Failed to restore the deferred layout.');
                    console.error(reason);
                });
            }
            // Add any widgets created during single document mode, which have
            // subsequently been removed from the dock panel after the multiple document
            // layout has been restored. If the widget has add options cached for
            // the widget (i.e., if it has been placed with respect to another widget),
            // then take that into account.
            widgets.forEach(widget => {
                if (!widget.parent) {
                    this._addToMainArea(widget, {
                        ...this._mainOptionsCache.get(widget),
                        activate: false
                    });
                }
            });
            this._mainOptionsCache.clear();
            // In case the active widget in the dock panel is *not* the active widget
            // of the application, defer to the application.
            if (applicationCurrentWidget) {
                dock.activateWidget(applicationCurrentWidget);
            }
            // Adjust menu and title
            this.add(this._menuHandler.panel, 'top', { rank: 100 });
            this._titleHandler.hide();
        }
        // Set the mode data attribute on the applications shell node.
        this.node.dataset.shellMode = mode;
        this._downPanel.fit();
        // Emit the mode changed signal
        this._modeChanged.emit(mode);
    }
    /**
     * A signal emitted when the shell/dock panel change modes (single/multiple document).
     */
    get modeChanged() {
        return this._modeChanged;
    }
    /**
     * Promise that resolves when state is first restored, returning layout
     * description.
     */
    get restored() {
        return this._restored.promise;
    }
    get translator() {
        var _a;
        return (_a = this._translator) !== null && _a !== void 0 ? _a : lib_index_js_.nullTranslator;
    }
    set translator(value) {
        if (value !== this._translator) {
            this._translator = value;
            // Set translator for tab bars
            ui_components_lib_index_js_.TabBarSvg.translator = value;
            const trans = value.load('jupyterlab');
            this._menuHandler.panel.node.setAttribute('aria-label', trans.__('main menu'));
            this._leftHandler.sideBar.node.setAttribute('aria-label', trans.__('main sidebar'));
            this._leftHandler.sideBar.contentNode.setAttribute('aria-label', trans.__('main sidebar'));
            this._rightHandler.sideBar.node.setAttribute('aria-label', trans.__('alternate sidebar'));
            this._rightHandler.sideBar.contentNode.setAttribute('aria-label', trans.__('alternate sidebar'));
            this._topHandler.panel.node.setAttribute('aria-label', trans.__('Top Bar'));
            this._bottomPanel.node.setAttribute('aria-label', trans.__('Bottom Panel'));
            this._dockPanel.node.setAttribute('aria-label', trans.__('Main Content'));
        }
    }
    /**
     * User customized shell layout.
     */
    get userLayout() {
        return dist_index_js_.JSONExt.deepCopy(this._userLayout);
    }
    /**
     * Activate a widget in its area.
     */
    activateById(id) {
        if (this._leftHandler.has(id)) {
            this._leftHandler.activate(id);
            return;
        }
        if (this._rightHandler.has(id)) {
            this._rightHandler.activate(id);
            return;
        }
        const tabIndex = this._downPanel.tabBar.titles.findIndex(title => title.owner.id === id);
        if (tabIndex >= 0) {
            this._downPanel.currentIndex = tabIndex;
            return;
        }
        const dock = this._dockPanel;
        const widget = (0,algorithm_dist_index_es6_js_.find)(dock.widgets(), value => value.id === id);
        if (widget) {
            dock.activateWidget(widget);
        }
    }
    /**
     * Activate widget in specified area.
     *
     * ### Notes
     * The alpha version of this method only supports activating the "main" area.
     *
     * @alpha
     * @param area Name of area to activate
     */
    activateArea(area = 'main') {
        switch (area) {
            case 'main':
                {
                    const current = this._currentTabBar();
                    if (!current) {
                        return;
                    }
                    if (current.currentTitle) {
                        current.currentTitle.owner.activate();
                    }
                }
                return;
            case 'left':
            case 'right':
            case 'header':
            case 'top':
            case 'menu':
            case 'bottom':
                console.debug(`Area: ${area} activation not yet implemented`);
                break;
            default:
                throw new Error(`Invalid area: ${area}`);
        }
    }
    /**
     * Activate the next Tab in the active TabBar.
     */
    activateNextTab() {
        const current = this._currentTabBar();
        if (!current) {
            return;
        }
        const ci = current.currentIndex;
        if (ci === -1) {
            return;
        }
        if (ci < current.titles.length - 1) {
            current.currentIndex += 1;
            if (current.currentTitle) {
                current.currentTitle.owner.activate();
            }
            return;
        }
        if (ci === current.titles.length - 1) {
            const nextBar = this._adjacentBar('next');
            if (nextBar) {
                nextBar.currentIndex = 0;
                if (nextBar.currentTitle) {
                    nextBar.currentTitle.owner.activate();
                }
            }
        }
    }
    /**
     * Activate the previous Tab in the active TabBar.
     */
    activatePreviousTab() {
        const current = this._currentTabBar();
        if (!current) {
            return;
        }
        const ci = current.currentIndex;
        if (ci === -1) {
            return;
        }
        if (ci > 0) {
            current.currentIndex -= 1;
            if (current.currentTitle) {
                current.currentTitle.owner.activate();
            }
            return;
        }
        if (ci === 0) {
            const prevBar = this._adjacentBar('previous');
            if (prevBar) {
                const len = prevBar.titles.length;
                prevBar.currentIndex = len - 1;
                if (prevBar.currentTitle) {
                    prevBar.currentTitle.owner.activate();
                }
            }
        }
    }
    /**
     * Activate the next TabBar.
     */
    activateNextTabBar() {
        const nextBar = this._adjacentBar('next');
        if (nextBar) {
            if (nextBar.currentTitle) {
                nextBar.currentTitle.owner.activate();
            }
        }
    }
    /**
     * Activate the next TabBar.
     */
    activatePreviousTabBar() {
        const nextBar = this._adjacentBar('previous');
        if (nextBar) {
            if (nextBar.currentTitle) {
                nextBar.currentTitle.owner.activate();
            }
        }
    }
    /**
     * Add a widget to the JupyterLab shell
     *
     * @param widget Widget
     * @param area Area
     * @param options Options
     */
    add(widget, area = 'main', options) {
        var _a;
        if (!this._userLayout) {
            this._delayedWidget.push({ widget, area, options });
            return;
        }
        let userPosition;
        if ((options === null || options === void 0 ? void 0 : options.type) && this._userLayout[this.mode][options.type]) {
            userPosition = this._userLayout[this.mode][options.type];
            this._idTypeMap.set(widget.id, options.type);
        }
        else {
            userPosition = this._userLayout[this.mode][widget.id];
        }
        if (options === null || options === void 0 ? void 0 : options.type) {
            this._idTypeMap.set(widget.id, options.type);
            widget.disposed.connect(() => {
                this._idTypeMap.delete(widget.id);
            });
        }
        area = (_a = userPosition === null || userPosition === void 0 ? void 0 : userPosition.area) !== null && _a !== void 0 ? _a : area;
        options =
            options || (userPosition === null || userPosition === void 0 ? void 0 : userPosition.options)
                ? {
                    ...options,
                    ...userPosition === null || userPosition === void 0 ? void 0 : userPosition.options
                }
                : undefined;
        switch (area || 'main') {
            case 'bottom':
                return this._addToBottomArea(widget, options);
            case 'down':
                return this._addToDownArea(widget, options);
            case 'header':
                return this._addToHeaderArea(widget, options);
            case 'left':
                return this._addToLeftArea(widget, options);
            case 'main':
                return this._addToMainArea(widget, options);
            case 'menu':
                return this._addToMenuArea(widget, options);
            case 'right':
                return this._addToRightArea(widget, options);
            case 'top':
                return this._addToTopArea(widget, options);
            default:
                throw new Error(`Invalid area: ${area}`);
        }
    }
    /**
     * Move a widget type to a new area.
     *
     * The type is determined from the `widget.id` and fallback to `widget.id`.
     *
     * #### Notes
     * If `mode` is undefined, both mode are updated.
     * The new layout is now persisted.
     *
     * @param widget Widget to move
     * @param area New area
     * @param mode Mode to change
     * @returns The new user layout
     */
    move(widget, area, mode) {
        var _a;
        const type = (_a = this._idTypeMap.get(widget.id)) !== null && _a !== void 0 ? _a : widget.id;
        for (const m of ['single-document', 'multiple-document'].filter(c => !mode || c === mode)) {
            this._userLayout[m][type] = {
                ...this._userLayout[m][type],
                area
            };
        }
        this.add(widget, area);
        return this._userLayout;
    }
    /**
     * Collapse the left area.
     */
    collapseLeft() {
        this._leftHandler.collapse();
        this._onLayoutModified();
    }
    /**
     * Collapse the right area.
     */
    collapseRight() {
        this._rightHandler.collapse();
        this._onLayoutModified();
    }
    /**
     * Dispose the shell.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._layoutDebouncer.dispose();
        super.dispose();
    }
    /**
     * Expand the left area.
     *
     * #### Notes
     * This will open the most recently used tab,
     * or the first tab if there is no most recently used.
     */
    expandLeft() {
        this._leftHandler.expand();
        this._onLayoutModified();
    }
    /**
     * Expand the right area.
     *
     * #### Notes
     * This will open the most recently used tab,
     * or the first tab if there is no most recently used.
     */
    expandRight() {
        this._rightHandler.expand();
        this._onLayoutModified();
    }
    /**
     * Close all widgets in the main and down area.
     */
    closeAll() {
        // Make a copy of all the widget in the dock panel (using `Array.from()`)
        // before removing them because removing them while iterating through them
        // modifies the underlying data of the iterator.
        Array.from(this._dockPanel.widgets()).forEach(widget => widget.close());
        this._downPanel.stackedPanel.widgets.forEach(widget => widget.close());
    }
    /**
     * Whether an side tab bar is visible or not.
     *
     * @param side Sidebar of interest
     * @returns Side tab bar visibility
     */
    isSideTabBarVisible(side) {
        switch (side) {
            case 'left':
                return this._leftHandler.isVisible;
            case 'right':
                return this._rightHandler.isVisible;
        }
    }
    /**
     * Whether the top bar in simple mode is visible or not.
     *
     * @returns Top bar visibility
     */
    isTopInSimpleModeVisible() {
        return !this._topHandlerHiddenByUser;
    }
    /**
     * True if the given area is empty.
     */
    isEmpty(area) {
        switch (area) {
            case 'bottom':
                return this._bottomPanel.widgets.length === 0;
            case 'down':
                return this._downPanel.stackedPanel.widgets.length === 0;
            case 'header':
                return this._headerPanel.widgets.length === 0;
            case 'left':
                return this._leftHandler.stackedPanel.widgets.length === 0;
            case 'main':
                return this._dockPanel.isEmpty;
            case 'menu':
                return this._menuHandler.panel.widgets.length === 0;
            case 'right':
                return this._rightHandler.stackedPanel.widgets.length === 0;
            case 'top':
                return this._topHandler.panel.widgets.length === 0;
            default:
                return true;
        }
    }
    /**
     * Restore the layout state and configuration for the application shell.
     *
     * #### Notes
     * This should only be called once.
     */
    async restoreLayout(mode, layoutRestorer, configuration = {}) {
        var _a, _b, _c, _d;
        // Set the configuration and add widgets added before the shell was ready.
        this._userLayout = {
            'single-document': (_a = configuration['single-document']) !== null && _a !== void 0 ? _a : {},
            'multiple-document': (_b = configuration['multiple-document']) !== null && _b !== void 0 ? _b : {}
        };
        this._delayedWidget.forEach(({ widget, area, options }) => {
            this.add(widget, area, options);
        });
        this._delayedWidget.length = 0;
        this._layoutRestorer = layoutRestorer;
        // Get the layout from the restorer
        const layout = await layoutRestorer.fetch();
        // Reset the layout
        const { mainArea, downArea, leftArea, rightArea, topArea, relativeSizes } = layout;
        // Rehydrate the main area.
        if (mainArea) {
            const { currentWidget, dock } = mainArea;
            if (dock && mode === 'multiple-document') {
                this._dockPanel.restoreLayout(dock);
            }
            if (mode) {
                this.mode = mode;
            }
            if (currentWidget) {
                this.activateById(currentWidget.id);
            }
        }
        else {
            // This is needed when loading in an empty workspace in single doc mode
            if (mode) {
                this.mode = mode;
            }
        }
        if ((topArea === null || topArea === void 0 ? void 0 : topArea.simpleVisibility) !== undefined) {
            this._topHandlerHiddenByUser = !topArea.simpleVisibility;
            if (this.mode === 'single-document') {
                this._topHandler.panel.setHidden(this._topHandlerHiddenByUser);
            }
        }
        // Rehydrate the down area
        if (downArea) {
            const { currentWidget, widgets, size } = downArea;
            const widgetIds = (_c = widgets === null || widgets === void 0 ? void 0 : widgets.map(widget => widget.id)) !== null && _c !== void 0 ? _c : [];
            // Remove absent widgets
            this._downPanel.tabBar.titles
                .filter(title => !widgetIds.includes(title.owner.id))
                .map(title => title.owner.close());
            // Add new widgets
            const titleIds = this._downPanel.tabBar.titles.map(title => title.owner.id);
            widgets === null || widgets === void 0 ? void 0 : widgets.filter(widget => !titleIds.includes(widget.id)).map(widget => this._downPanel.addWidget(widget));
            // Reorder tabs
            while (!algorithm_dist_index_es6_js_.ArrayExt.shallowEqual(widgetIds, this._downPanel.tabBar.titles.map(title => title.owner.id))) {
                this._downPanel.tabBar.titles.forEach((title, index) => {
                    const position = widgetIds.findIndex(id => title.owner.id == id);
                    if (position >= 0 && position != index) {
                        this._downPanel.tabBar.insertTab(position, title);
                    }
                });
            }
            if (currentWidget) {
                const index = this._downPanel.stackedPanel.widgets.findIndex(widget => widget.id === currentWidget.id);
                if (index) {
                    this._downPanel.currentIndex = index;
                    (_d = this._downPanel.currentWidget) === null || _d === void 0 ? void 0 : _d.activate();
                }
            }
            if (size && size > 0.0) {
                this._vsplitPanel.setRelativeSizes([1.0 - size, size]);
            }
            else {
                // Close all tabs and hide the panel
                this._downPanel.stackedPanel.widgets.forEach(widget => widget.close());
                this._downPanel.hide();
            }
        }
        // Rehydrate the left area.
        if (leftArea) {
            this._leftHandler.rehydrate(leftArea);
        }
        else {
            if (mode === 'single-document') {
                this.collapseLeft();
            }
        }
        // Rehydrate the right area.
        if (rightArea) {
            this._rightHandler.rehydrate(rightArea);
        }
        else {
            if (mode === 'single-document') {
                this.collapseRight();
            }
        }
        // Restore the relative sizes.
        if (relativeSizes) {
            this._hsplitPanel.setRelativeSizes(relativeSizes);
        }
        if (!this._isRestored) {
            // Make sure all messages in the queue are finished before notifying
            // any extensions that are waiting for the promise that guarantees the
            // application state has been restored.
            messaging_dist_index_es6_js_.MessageLoop.flush();
            this._restored.resolve(layout);
        }
    }
    /**
     * Save the dehydrated state of the application shell.
     */
    saveLayout() {
        // If the application is in single document mode, use the cached layout if
        // available. Otherwise, default to querying the dock panel for layout.
        const layout = {
            mainArea: {
                currentWidget: this._tracker.currentWidget,
                dock: this.mode === 'single-document'
                    ? this._cachedLayout || this._dockPanel.saveLayout()
                    : this._dockPanel.saveLayout()
            },
            downArea: {
                currentWidget: this._downPanel.currentWidget,
                widgets: Array.from(this._downPanel.stackedPanel.widgets),
                size: this._vsplitPanel.relativeSizes()[1]
            },
            leftArea: this._leftHandler.dehydrate(),
            rightArea: this._rightHandler.dehydrate(),
            topArea: { simpleVisibility: !this._topHandlerHiddenByUser },
            relativeSizes: this._hsplitPanel.relativeSizes()
        };
        return layout;
    }
    /**
     * Toggle top header visibility in simple mode
     *
     * Note: Does nothing in multi-document mode
     */
    toggleTopInSimpleModeVisibility() {
        if (this.mode === 'single-document') {
            if (this._topHandler.panel.isVisible) {
                this._topHandlerHiddenByUser = true;
                this._topHandler.panel.hide();
            }
            else {
                this._topHandlerHiddenByUser = false;
                this._topHandler.panel.show();
                this._updateTitlePanelTitle();
            }
            this._onLayoutModified();
        }
    }
    /**
     * Toggle side tab bar visibility
     *
     * @param side Sidebar of interest
     */
    toggleSideTabBarVisibility(side) {
        if (side === 'right') {
            if (this._rightHandler.isVisible) {
                this._rightHandler.hide();
            }
            else {
                this._rightHandler.show();
            }
        }
        else {
            if (this._leftHandler.isVisible) {
                this._leftHandler.hide();
            }
            else {
                this._leftHandler.show();
            }
        }
    }
    /**
     * Update the shell configuration.
     *
     * @param config Shell configuration
     */
    updateConfig(config) {
        if (config.hiddenMode) {
            switch (config.hiddenMode) {
                case 'display':
                    this._dockPanel.hiddenMode = widgets_dist_index_es6_js_.Widget.HiddenMode.Display;
                    break;
                case 'scale':
                    this._dockPanel.hiddenMode = widgets_dist_index_es6_js_.Widget.HiddenMode.Scale;
                    break;
                case 'contentVisibility':
                    this._dockPanel.hiddenMode = widgets_dist_index_es6_js_.Widget.HiddenMode.ContentVisibility;
                    break;
            }
        }
    }
    /**
     * Returns the widgets for an application area.
     */
    widgets(area) {
        switch (area !== null && area !== void 0 ? area : 'main') {
            case 'main':
                return this._dockPanel.widgets();
            case 'left':
                return (0,algorithm_dist_index_es6_js_.map)(this._leftHandler.sideBar.titles, t => t.owner);
            case 'right':
                return (0,algorithm_dist_index_es6_js_.map)(this._rightHandler.sideBar.titles, t => t.owner);
            case 'header':
                return this._headerPanel.children();
            case 'top':
                return this._topHandler.panel.children();
            case 'menu':
                return this._menuHandler.panel.children();
            case 'bottom':
                return this._bottomPanel.children();
            default:
                throw new Error(`Invalid area: ${area}`);
        }
    }
    /**
     * Handle `after-attach` messages for the application shell.
     */
    onAfterAttach(msg) {
        this.node.dataset.shellMode = this.mode;
    }
    /**
     * Update the title panel title based on the title of the current widget.
     */
    _updateTitlePanelTitle() {
        let current = this.currentWidget;
        const inputElement = this._titleHandler.inputElement;
        inputElement.value = current ? current.title.label : '';
        inputElement.title = current ? current.title.caption : '';
    }
    /**
     * The path of the current widget changed, fire the _currentPathChanged signal.
     */
    _updateCurrentPath() {
        let current = this.currentWidget;
        let newValue = '';
        if (current && current instanceof docregistry_lib_index_js_.DocumentWidget) {
            newValue = current.context.path;
        }
        this._currentPathChanged.emit({
            newValue: newValue,
            oldValue: this._currentPath
        });
        this._currentPath = newValue;
    }
    /**
     * Add a widget to the left content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     */
    _addToLeftArea(widget, options) {
        if (!widget.id) {
            console.error('Widgets added to app shell must have unique id property.');
            return;
        }
        options = options || this._sideOptionsCache.get(widget) || {};
        this._sideOptionsCache.set(widget, options);
        const rank = 'rank' in options ? options.rank : DEFAULT_RANK;
        this._leftHandler.addWidget(widget, rank);
        this._onLayoutModified();
    }
    /**
     * Add a widget to the main content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     * All widgets added to the main area should be disposed after removal
     * (disposal before removal will remove the widget automatically).
     *
     * In the options, `ref` defaults to `null`, `mode` defaults to `'tab-after'`,
     * and `activate` defaults to `true`.
     */
    _addToMainArea(widget, options) {
        if (!widget.id) {
            console.error('Widgets added to app shell must have unique id property.');
            return;
        }
        options = options || {};
        const dock = this._dockPanel;
        const mode = options.mode || 'tab-after';
        let ref = this.currentWidget;
        if (options.ref) {
            ref = (0,algorithm_dist_index_es6_js_.find)(dock.widgets(), value => value.id === options.ref) || null;
        }
        const { title } = widget;
        // Add widget ID to tab so that we can get a handle on the tab's widget
        // (for context menu support)
        title.dataset = { ...title.dataset, id: widget.id };
        if (title.icon instanceof ui_components_lib_index_js_.LabIcon) {
            // bind an appropriate style to the icon
            title.icon = title.icon.bindprops({
                stylesheet: 'mainAreaTab'
            });
        }
        else if (typeof title.icon === 'string' || !title.icon) {
            // add some classes to help with displaying css background imgs
            title.iconClass = (0,ui_components_lib_index_js_.classes)(title.iconClass, 'jp-Icon');
        }
        dock.addWidget(widget, { mode, ref });
        // The dock panel doesn't account for placement information while
        // in single document mode, so upon rehydrating any widgets that were
        // added will not be in the correct place. Cache the placement information
        // here so that we can later rehydrate correctly.
        if (dock.mode === 'single-document') {
            this._mainOptionsCache.set(widget, options);
        }
        if (options.activate !== false) {
            dock.activateWidget(widget);
        }
    }
    /**
     * Add a widget to the right content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     */
    _addToRightArea(widget, options) {
        if (!widget.id) {
            console.error('Widgets added to app shell must have unique id property.');
            return;
        }
        options = options || this._sideOptionsCache.get(widget) || {};
        const rank = 'rank' in options ? options.rank : DEFAULT_RANK;
        this._sideOptionsCache.set(widget, options);
        this._rightHandler.addWidget(widget, rank);
        this._onLayoutModified();
    }
    /**
     * Add a widget to the top content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     */
    _addToTopArea(widget, options) {
        var _a;
        if (!widget.id) {
            console.error('Widgets added to app shell must have unique id property.');
            return;
        }
        options = options || {};
        const rank = (_a = options.rank) !== null && _a !== void 0 ? _a : DEFAULT_RANK;
        this._topHandler.addWidget(widget, rank);
        this._onLayoutModified();
        if (this._topHandler.panel.isHidden) {
            this._topHandler.panel.show();
        }
    }
    /**
     * Add a widget to the title content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     */
    _addToMenuArea(widget, options) {
        var _a;
        if (!widget.id) {
            console.error('Widgets added to app shell must have unique id property.');
            return;
        }
        options = options || {};
        const rank = (_a = options.rank) !== null && _a !== void 0 ? _a : DEFAULT_RANK;
        this._menuHandler.addWidget(widget, rank);
        this._onLayoutModified();
        if (this._menuHandler.panel.isHidden) {
            this._menuHandler.panel.show();
        }
    }
    /**
     * Add a widget to the header content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     */
    _addToHeaderArea(widget, options) {
        if (!widget.id) {
            console.error('Widgets added to app shell must have unique id property.');
            return;
        }
        // Temporary: widgets are added to the panel in order of insertion.
        this._headerPanel.addWidget(widget);
        this._onLayoutModified();
        if (this._headerPanel.isHidden) {
            this._headerPanel.show();
        }
    }
    /**
     * Add a widget to the bottom content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     */
    _addToBottomArea(widget, options) {
        if (!widget.id) {
            console.error('Widgets added to app shell must have unique id property.');
            return;
        }
        // Temporary: widgets are added to the panel in order of insertion.
        this._bottomPanel.addWidget(widget);
        this._onLayoutModified();
        if (this._bottomPanel.isHidden) {
            this._bottomPanel.show();
        }
    }
    _addToDownArea(widget, options) {
        if (!widget.id) {
            console.error('Widgets added to app shell must have unique id property.');
            return;
        }
        options = options || {};
        const { title } = widget;
        // Add widget ID to tab so that we can get a handle on the tab's widget
        // (for context menu support)
        title.dataset = { ...title.dataset, id: widget.id };
        if (title.icon instanceof ui_components_lib_index_js_.LabIcon) {
            // bind an appropriate style to the icon
            title.icon = title.icon.bindprops({
                stylesheet: 'mainAreaTab'
            });
        }
        else if (typeof title.icon === 'string' || !title.icon) {
            // add some classes to help with displaying css background imgs
            title.iconClass = (0,ui_components_lib_index_js_.classes)(title.iconClass, 'jp-Icon');
        }
        this._downPanel.addWidget(widget);
        this._onLayoutModified();
        if (this._downPanel.isHidden) {
            this._downPanel.show();
        }
    }
    /*
     * Return the tab bar adjacent to the current TabBar or `null`.
     */
    _adjacentBar(direction) {
        const current = this._currentTabBar();
        if (!current) {
            return null;
        }
        const bars = Array.from(this._dockPanel.tabBars());
        const len = bars.length;
        const index = bars.indexOf(current);
        if (direction === 'previous') {
            return index > 0 ? bars[index - 1] : index === 0 ? bars[len - 1] : null;
        }
        // Otherwise, direction is 'next'.
        return index < len - 1
            ? bars[index + 1]
            : index === len - 1
                ? bars[0]
                : null;
    }
    /*
     * Return the TabBar that has the currently active Widget or null.
     */
    _currentTabBar() {
        const current = this._tracker.currentWidget;
        if (!current) {
            return null;
        }
        const title = current.title;
        const bars = this._dockPanel.tabBars();
        return (0,algorithm_dist_index_es6_js_.find)(bars, bar => bar.titles.indexOf(title) > -1) || null;
    }
    /**
     * Handle a change to the dock area active widget.
     */
    _onActiveChanged(sender, args) {
        if (args.newValue) {
            args.newValue.title.className += ` ${ACTIVE_CLASS}`;
        }
        if (args.oldValue) {
            args.oldValue.title.className = args.oldValue.title.className.replace(ACTIVE_CLASS, '');
        }
        this._activeChanged.emit(args);
    }
    /**
     * Handle a change to the dock area current widget.
     */
    _onCurrentChanged(sender, args) {
        if (args.newValue) {
            args.newValue.title.className += ` ${CURRENT_CLASS}`;
        }
        if (args.oldValue) {
            args.oldValue.title.className = args.oldValue.title.className.replace(CURRENT_CLASS, '');
        }
        this._currentChanged.emit(args);
        this._onLayoutModified();
    }
    /**
     * Handle a change on the down panel widgets
     */
    _onTabPanelChanged() {
        if (this._downPanel.stackedPanel.widgets.length === 0) {
            this._downPanel.hide();
        }
        this._onLayoutModified();
    }
    /**
     * Handle a change to the layout.
     */
    _onLayoutModified() {
        void this._layoutDebouncer.invoke();
    }
}
var shell_Private;
(function (Private) {
    /**
     * A less-than comparison function for side bar rank items.
     */
    function itemCmp(first, second) {
        return first.rank - second.rank;
    }
    Private.itemCmp = itemCmp;
    /**
     * Removes widgets that have been disposed from an area config, mutates area.
     */
    function normalizeAreaConfig(parent, area) {
        if (!area) {
            return;
        }
        if (area.type === 'tab-area') {
            area.widgets = area.widgets.filter(widget => !widget.isDisposed && widget.parent === parent);
            return;
        }
        area.children.forEach(child => {
            normalizeAreaConfig(parent, child);
        });
    }
    Private.normalizeAreaConfig = normalizeAreaConfig;
    /**
     * A class which manages a panel and sorts its widgets by rank.
     */
    class PanelHandler {
        constructor() {
            /**
             * A message hook for child add/remove messages on the main area dock panel.
             */
            this._panelChildHook = (handler, msg) => {
                switch (msg.type) {
                    case 'child-added':
                        {
                            const widget = msg.child;
                            // If we already know about this widget, we're done
                            if (this._items.find(v => v.widget === widget)) {
                                break;
                            }
                            // Otherwise, add to the end by default
                            const rank = this._items[this._items.length - 1].rank;
                            this._items.push({ widget, rank });
                        }
                        break;
                    case 'child-removed':
                        {
                            const widget = msg.child;
                            algorithm_dist_index_es6_js_.ArrayExt.removeFirstWhere(this._items, v => v.widget === widget);
                        }
                        break;
                    default:
                        break;
                }
                return true;
            };
            this._items = new Array();
            this._panel = new widgets_dist_index_es6_js_.Panel();
            messaging_dist_index_es6_js_.MessageLoop.installMessageHook(this._panel, this._panelChildHook);
        }
        /**
         * Get the panel managed by the handler.
         */
        get panel() {
            return this._panel;
        }
        /**
         * Add a widget to the panel.
         *
         * If the widget is already added, it will be moved.
         */
        addWidget(widget, rank) {
            widget.parent = null;
            const item = { widget, rank };
            const index = algorithm_dist_index_es6_js_.ArrayExt.upperBound(this._items, item, Private.itemCmp);
            algorithm_dist_index_es6_js_.ArrayExt.insert(this._items, index, item);
            this._panel.insertWidget(index, widget);
        }
    }
    Private.PanelHandler = PanelHandler;
    /**
     * A class which manages a side bar and related stacked panel.
     */
    class SideBarHandler {
        /**
         * Construct a new side bar handler.
         */
        constructor() {
            this._isHiddenByUser = false;
            this._items = new Array();
            this._updated = new dist_index_es6_js_.Signal(this);
            this._sideBar = new widgets_dist_index_es6_js_.TabBar({
                insertBehavior: 'none',
                removeBehavior: 'none',
                allowDeselect: true,
                orientation: 'vertical'
            });
            this._stackedPanel = new widgets_dist_index_es6_js_.StackedPanel();
            this._sideBar.hide();
            this._stackedPanel.hide();
            this._lastCurrent = null;
            this._sideBar.currentChanged.connect(this._onCurrentChanged, this);
            this._sideBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
            this._stackedPanel.widgetRemoved.connect(this._onWidgetRemoved, this);
        }
        /**
         * Whether the side bar is visible
         */
        get isVisible() {
            return this._sideBar.isVisible;
        }
        /**
         * Get the tab bar managed by the handler.
         */
        get sideBar() {
            return this._sideBar;
        }
        /**
         * Get the stacked panel managed by the handler
         */
        get stackedPanel() {
            return this._stackedPanel;
        }
        /**
         * Signal fires when the stack panel or the sidebar changes
         */
        get updated() {
            return this._updated;
        }
        /**
         * Handles a movement to the handles of a widget
         */
        _onHandleMoved() {
            return this._refreshVisibility();
        }
        /**
         * Handles changes to the expansion status of a widget
         */
        _onExpansionToggle(sender, index) {
            return this._refreshVisibility();
        }
        /**
         * Expand the sidebar.
         *
         * #### Notes
         * This will open the most recently used tab, or the first tab
         * if there is no most recently used.
         */
        expand() {
            const previous = this._lastCurrent || (this._items.length > 0 && this._items[0].widget);
            if (previous) {
                this.activate(previous.id);
            }
        }
        /**
         * Activate a widget residing in the side bar by ID.
         *
         * @param id - The widget's unique ID.
         */
        activate(id) {
            const widget = this._findWidgetByID(id);
            if (widget) {
                this._sideBar.currentTitle = widget.title;
                widget.activate();
            }
        }
        /**
         * Test whether the sidebar has the given widget by id.
         */
        has(id) {
            return this._findWidgetByID(id) !== null;
        }
        /**
         * Collapse the sidebar so no items are expanded.
         */
        collapse() {
            this._sideBar.currentTitle = null;
        }
        /**
         * Add a widget and its title to the stacked panel and side bar.
         *
         * If the widget is already added, it will be moved.
         */
        addWidget(widget, rank) {
            var _a, _b, _c, _d;
            widget.parent = null;
            widget.hide();
            const item = { widget, rank };
            const index = this._findInsertIndex(item);
            algorithm_dist_index_es6_js_.ArrayExt.insert(this._items, index, item);
            this._stackedPanel.insertWidget(index, widget);
            const title = this._sideBar.insertTab(index, widget.title);
            // Store the parent id in the title dataset
            // in order to dispatch click events to the right widget.
            title.dataset = { id: widget.id };
            if (title.icon instanceof ui_components_lib_index_js_.LabIcon) {
                // bind an appropriate style to the icon
                title.icon = title.icon.bindprops({
                    stylesheet: 'sideBar'
                });
            }
            else if (typeof title.icon === 'string' && title.icon != '') {
                // add some classes to help with displaying css background imgs
                title.iconClass = (0,ui_components_lib_index_js_.classes)(title.iconClass, 'jp-Icon', 'jp-Icon-20');
            }
            else if (!title.icon && !title.label) {
                // add a fallback icon if there is no title label nor icon
                title.icon = ui_components_lib_index_js_.tabIcon.bindprops({
                    stylesheet: 'sideBar'
                });
            }
            // @ts-expect-error sometimes widget is an Accordion Panel
            (_b = (_a = widget.content) === null || _a === void 0 ? void 0 : _a.expansionToggled) === null || _b === void 0 ? void 0 : _b.connect(this._onExpansionToggle, this);
            // @ts-expect-error sometimes widget is a SidePanel
            (_d = (_c = widget.content) === null || _c === void 0 ? void 0 : _c.handleMoved) === null || _d === void 0 ? void 0 : _d.connect(this._onHandleMoved, this);
            this._refreshVisibility();
        }
        /**
         * Dehydrate the side bar data.
         */
        dehydrate() {
            const collapsed = this._sideBar.currentTitle === null;
            const widgets = Array.from(this._stackedPanel.widgets);
            const currentWidget = widgets[this._sideBar.currentIndex];
            const widgetStates = {};
            this._stackedPanel.widgets.forEach((w) => {
                if (w.id && w.content instanceof widgets_dist_index_es6_js_.SplitPanel) {
                    widgetStates[w.id] = {
                        sizes: w.content.relativeSizes(),
                        expansionStates: w.content.widgets.map(wi => wi.isVisible)
                    };
                }
            });
            return {
                collapsed,
                currentWidget,
                visible: !this._isHiddenByUser,
                widgets,
                widgetStates
            };
        }
        /**
         * Rehydrate the side bar.
         */
        rehydrate(data) {
            if (data.currentWidget) {
                this.activate(data.currentWidget.id);
            }
            if (data.collapsed) {
                this.collapse();
            }
            if (!data.visible) {
                this.hide();
            }
            if (data.widgetStates) {
                this._stackedPanel.widgets.forEach((w) => {
                    var _a;
                    if (w.id && w.content instanceof widgets_dist_index_es6_js_.SplitPanel) {
                        const state = (_a = data.widgetStates[w.id]) !== null && _a !== void 0 ? _a : {};
                        w.content.widgets.forEach((wi, widx) => {
                            var _a;
                            const expansion = ((_a = state.expansionStates) !== null && _a !== void 0 ? _a : [])[widx];
                            if (typeof expansion === 'boolean' &&
                                w.content instanceof widgets_dist_index_es6_js_.AccordionPanel) {
                                expansion ? w.content.expand(widx) : w.content.collapse(widx);
                            }
                        });
                        if (state.sizes) {
                            w.content.setRelativeSizes(state.sizes);
                        }
                    }
                });
            }
        }
        /**
         * Hide the side bar even if it contains widgets
         */
        hide() {
            this._isHiddenByUser = true;
            this._refreshVisibility();
        }
        /**
         * Show the side bar if it contains widgets
         */
        show() {
            this._isHiddenByUser = false;
            this._refreshVisibility();
        }
        /**
         * Find the insertion index for a rank item.
         */
        _findInsertIndex(item) {
            return algorithm_dist_index_es6_js_.ArrayExt.upperBound(this._items, item, Private.itemCmp);
        }
        /**
         * Find the index of the item with the given widget, or `-1`.
         */
        _findWidgetIndex(widget) {
            return algorithm_dist_index_es6_js_.ArrayExt.findFirstIndex(this._items, i => i.widget === widget);
        }
        /**
         * Find the widget which owns the given title, or `null`.
         */
        _findWidgetByTitle(title) {
            const item = (0,algorithm_dist_index_es6_js_.find)(this._items, value => value.widget.title === title);
            return item ? item.widget : null;
        }
        /**
         * Find the widget with the given id, or `null`.
         */
        _findWidgetByID(id) {
            const item = (0,algorithm_dist_index_es6_js_.find)(this._items, value => value.widget.id === id);
            return item ? item.widget : null;
        }
        /**
         * Refresh the visibility of the side bar and stacked panel.
         */
        _refreshVisibility() {
            this._stackedPanel.setHidden(this._sideBar.currentTitle === null);
            this._sideBar.setHidden(this._isHiddenByUser || this._sideBar.titles.length === 0);
            this._updated.emit();
        }
        /**
         * Handle the `currentChanged` signal from the sidebar.
         */
        _onCurrentChanged(sender, args) {
            const oldWidget = args.previousTitle
                ? this._findWidgetByTitle(args.previousTitle)
                : null;
            const newWidget = args.currentTitle
                ? this._findWidgetByTitle(args.currentTitle)
                : null;
            if (oldWidget) {
                oldWidget.hide();
            }
            if (newWidget) {
                newWidget.show();
            }
            this._lastCurrent = newWidget || oldWidget;
            this._refreshVisibility();
        }
        /**
         * Handle a `tabActivateRequest` signal from the sidebar.
         */
        _onTabActivateRequested(sender, args) {
            args.title.owner.activate();
        }
        /*
         * Handle the `widgetRemoved` signal from the stacked panel.
         */
        _onWidgetRemoved(sender, widget) {
            if (widget === this._lastCurrent) {
                this._lastCurrent = null;
            }
            algorithm_dist_index_es6_js_.ArrayExt.removeAt(this._items, this._findWidgetIndex(widget));
            this._sideBar.removeTab(widget.title);
            this._refreshVisibility();
        }
    }
    Private.SideBarHandler = SideBarHandler;
    class SkipLinkWidget extends widgets_dist_index_es6_js_.Widget {
        /**
         * Construct a new skipLink widget.
         */
        constructor(shell) {
            super();
            this.addClass('jp-skiplink');
            this.id = 'jp-skiplink';
            this._shell = shell;
            this._createSkipLink('Skip to main panel', 'main');
        }
        handleEvent(event) {
            var _a, _b;
            switch (event.type) {
                case 'click':
                    if (event.target instanceof HTMLElement) {
                        this._shell.activateArea((_b = (_a = event.target) === null || _a === void 0 ? void 0 : _a.dataset) === null || _b === void 0 ? void 0 : _b.targetarea);
                    }
                    break;
            }
        }
        /**
         * Handle `after-attach` messages for the widget.
         */
        onAfterAttach(msg) {
            super.onAfterAttach(msg);
            this.node.addEventListener('click', this);
        }
        /**
         * A message handler invoked on a `'before-detach'`
         * message
         */
        onBeforeDetach(msg) {
            this.node.removeEventListener('click', this);
            super.onBeforeDetach(msg);
        }
        _createSkipLink(skipLinkText, area) {
            const skipLink = document.createElement('a');
            skipLink.href = '#';
            skipLink.tabIndex = 0;
            skipLink.text = skipLinkText;
            skipLink.className = 'skip-link';
            skipLink.dataset['targetarea'] = area;
            this.node.appendChild(skipLink);
        }
    }
    Private.SkipLinkWidget = SkipLinkWidget;
    class TitleHandler extends widgets_dist_index_es6_js_.Widget {
        /**
         * Construct a new title handler.
         */
        constructor(shell) {
            super();
            this._selected = false;
            const inputElement = document.createElement('input');
            inputElement.type = 'text';
            this.node.appendChild(inputElement);
            this._shell = shell;
            this.id = 'jp-title-panel-title';
        }
        /**
         * Handle `after-attach` messages for the widget.
         */
        onAfterAttach(msg) {
            super.onAfterAttach(msg);
            this.inputElement.addEventListener('keyup', this);
            this.inputElement.addEventListener('click', this);
            this.inputElement.addEventListener('blur', this);
        }
        /**
         * Handle `before-detach` messages for the widget.
         */
        onBeforeDetach(msg) {
            super.onBeforeDetach(msg);
            this.inputElement.removeEventListener('keyup', this);
            this.inputElement.removeEventListener('click', this);
            this.inputElement.removeEventListener('blur', this);
        }
        handleEvent(event) {
            switch (event.type) {
                case 'keyup':
                    void this._evtKeyUp(event);
                    break;
                case 'click':
                    this._evtClick(event);
                    break;
                case 'blur':
                    this._selected = false;
                    break;
            }
        }
        /**
         * Handle `keyup` events on the handler.
         */
        async _evtKeyUp(event) {
            if (event.key == 'Enter') {
                const widget = this._shell.currentWidget;
                if (widget == null) {
                    return;
                }
                const oldName = widget.title.label;
                const inputElement = this.inputElement;
                const newName = inputElement.value;
                inputElement.blur();
                if (newName !== oldName) {
                    widget.title.label = newName;
                }
                else {
                    inputElement.value = oldName;
                }
            }
        }
        /**
         * Handle `click` events on the handler.
         */
        _evtClick(event) {
            // only handle primary button clicks
            if (event.button !== 0 || this._selected) {
                return;
            }
            const inputElement = this.inputElement;
            event.preventDefault();
            event.stopPropagation();
            this._selected = true;
            const selectEnd = inputElement.value.indexOf('.');
            if (selectEnd === -1) {
                inputElement.select();
            }
            else {
                inputElement.setSelectionRange(0, selectEnd);
            }
        }
        /**
         * The input element containing the parent widget's title.
         */
        get inputElement() {
            return this.node.children[0];
        }
    }
    Private.TitleHandler = TitleHandler;
    class RestorableSplitPanel extends widgets_dist_index_es6_js_.SplitPanel {
        /**
         * Construct a new RestorableSplitPanel.
         */
        constructor(options = {}) {
            super(options);
            this._updated = new dist_index_es6_js_.Signal(this);
        }
        /**
         * A signal emitted when the split panel is updated.
         */
        get updated() {
            return this._updated;
        }
        /**
         * Emit 'updated' signal on 'update' requests.
         */
        onUpdateRequest(msg) {
            super.onUpdateRequest(msg);
            this._updated.emit();
        }
    }
    Private.RestorableSplitPanel = RestorableSplitPanel;
})(shell_Private || (shell_Private = {}));
//# sourceMappingURL=shell.js.map
// EXTERNAL MODULE: ../node_modules/@jupyterlab/application/lib/status.js
var lib_status = __webpack_require__(20389);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/lib/lab.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.








/**
 * JupyterLab is the main application class. It is instantiated once and shared.
 */
class JupyterLab extends JupyterFrontEnd {
    /**
     * Construct a new JupyterLab object.
     */
    constructor(options = { shell: new LabShell() }) {
        super({
            ...options,
            shell: options.shell || new LabShell(),
            serviceManager: options.serviceManager ||
                new services_lib_index_js_.ServiceManager({
                    standby: () => {
                        return !this._info.isConnected || 'when-hidden';
                    }
                })
        });
        /**
         * The name of the JupyterLab application.
         */
        this.name = coreutils_lib_index_js_.PageConfig.getOption('appName') || 'JupyterLab';
        /**
         * A namespace/prefix plugins may use to denote their provenance.
         */
        this.namespace = coreutils_lib_index_js_.PageConfig.getOption('appNamespace') || this.name;
        /**
         * A list of all errors encountered when registering plugins.
         *
         * @deprecated This is unused and may be removed in a future version.
         */
        this.registerPluginErrors = [];
        /**
         * The application busy and dirty status signals and flags.
         */
        this.status = new lib_status/* LabStatus */.J(this);
        /**
         * The version of the JupyterLab application.
         */
        this.version = coreutils_lib_index_js_.PageConfig.getOption('appVersion') || 'unknown';
        this._allPluginsActivated = new dist_index_js_.PromiseDelegate();
        // Populate application info.
        this._info = new JupyterLab.Info(options);
        this.restored = this.shell.restored
            .then(async () => {
            const activated = [];
            const deferred = this.activateDeferredPlugins().catch(error => {
                console.error('Error when activating deferred plugins\n:', error);
            });
            activated.push(deferred);
            if (this._info.deferred) {
                const customizedDeferred = Promise.all(this._info.deferred.matches.map(pluginID => this.activatePlugin(pluginID))).catch(error => {
                    console.error('Error when activating customized list of deferred plugins:\n', error);
                });
                activated.push(customizedDeferred);
            }
            Promise.all(activated)
                .then(() => {
                this._allPluginsActivated.resolve();
            })
                .catch(() => undefined);
        })
            .catch(() => undefined);
        // Populate application paths override the defaults if necessary.
        const defaultURLs = JupyterLab.defaultPaths.urls;
        const defaultDirs = JupyterLab.defaultPaths.directories;
        const optionURLs = (options.paths && options.paths.urls) || {};
        const optionDirs = (options.paths && options.paths.directories) || {};
        this._paths = {
            urls: Object.keys(defaultURLs).reduce((acc, key) => {
                if (key in optionURLs) {
                    const value = optionURLs[key];
                    acc[key] = value;
                }
                else {
                    acc[key] = defaultURLs[key];
                }
                return acc;
            }, {}),
            directories: Object.keys(JupyterLab.defaultPaths.directories).reduce((acc, key) => {
                if (key in optionDirs) {
                    const value = optionDirs[key];
                    acc[key] = value;
                }
                else {
                    acc[key] = defaultDirs[key];
                }
                return acc;
            }, {})
        };
        if (this._info.devMode) {
            this.shell.addClass('jp-mod-devMode');
        }
        // Add initial model factory.
        this.docRegistry.addModelFactory(new docregistry_lib_index_js_.Base64ModelFactory());
        if (options.mimeExtensions) {
            for (const plugin of (0,mimerenderers/* createRendermimePlugins */.as)(options.mimeExtensions)) {
                this.registerPlugin(plugin);
            }
        }
    }
    /**
     * The JupyterLab application information dictionary.
     */
    get info() {
        return this._info;
    }
    /**
     * The JupyterLab application paths dictionary.
     */
    get paths() {
        return this._paths;
    }
    /**
     * Promise that resolves when all the plugins are activated, including the deferred.
     */
    get allPluginsActivated() {
        return this._allPluginsActivated.promise;
    }
    /**
     * Register plugins from a plugin module.
     *
     * @param mod - The plugin module to register.
     *
     * @deprecated This is unused and may be removed in a future version.
     */
    registerPluginModule(mod) {
        let data = mod.default;
        // Handle commonjs exports.
        if (!mod.hasOwnProperty('__esModule')) {
            data = mod;
        }
        if (!Array.isArray(data)) {
            data = [data];
        }
        data.forEach(item => {
            try {
                this.registerPlugin(item);
            }
            catch (error) {
                this.registerPluginErrors.push(error);
            }
        });
    }
    /**
     * Register the plugins from multiple plugin modules.
     *
     * @param mods - The plugin modules to register.
     *
     * @deprecated This is unused and may be removed in a future version.
     */
    registerPluginModules(mods) {
        mods.forEach(mod => {
            this.registerPluginModule(mod);
        });
    }
    /**
     * Override keydown handling to prevent command shortcuts from preventing user input.
     *
     * This introduces a slight delay to the command invocation, but no delay to user input.
     */
    evtKeydown(keyDownEvent) {
        const permissionToExecute = new dist_index_js_.PromiseDelegate();
        // Hold the execution of any keybinding until we know if this event would cause text insertion
        this.commands.holdKeyBindingExecution(keyDownEvent, permissionToExecute.promise);
        // Process the key immediately to invoke the prevent default handlers as needed
        this.commands.processKeydownEvent(keyDownEvent);
        // If we do not know the target, we cannot check if input would be inserted
        // as there is no target to attach the `beforeinput` event listener; in that
        // case we just permit execution immediately (this may happen for programmatic
        // uses of keydown)
        const target = keyDownEvent.target;
        if (!target) {
            return permissionToExecute.resolve(true);
        }
        let onBeforeInput = null;
        let onBeforeKeyUp = null;
        const disconnectListeners = () => {
            if (onBeforeInput) {
                target.removeEventListener('beforeinput', onBeforeInput);
            }
            if (onBeforeKeyUp) {
                target.removeEventListener('keyup', onBeforeKeyUp);
            }
        };
        // Permit the execution conditionally, depending on whether the event would lead to text insertion
        const causesInputPromise = Promise.race([
            new Promise(resolve => {
                onBeforeInput = (inputEvent) => {
                    switch (inputEvent.inputType) {
                        case 'historyUndo':
                        case 'historyRedo': {
                            if (inputEvent.target instanceof Element &&
                                inputEvent.target.closest('[data-jp-undoer]')) {
                                // Allow to use custom undo/redo bindings on `jpUndoer`s
                                inputEvent.preventDefault();
                                disconnectListeners();
                                return resolve(false);
                            }
                            break;
                        }
                        case 'insertLineBreak': {
                            if (inputEvent.target instanceof Element &&
                                inputEvent.target.closest('.jp-Cell')) {
                                // Allow to override the default action of Shift + Enter on cells as this is used for cell execution
                                inputEvent.preventDefault();
                                disconnectListeners();
                                return resolve(false);
                            }
                            break;
                        }
                    }
                    disconnectListeners();
                    return resolve(true);
                };
                target.addEventListener('beforeinput', onBeforeInput, { once: true });
            }),
            new Promise(resolve => {
                onBeforeKeyUp = (keyUpEvent) => {
                    if (keyUpEvent.code === keyDownEvent.code) {
                        disconnectListeners();
                        return resolve(false);
                    }
                };
                target.addEventListener('keyup', onBeforeKeyUp, { once: true });
            }),
            new Promise(resolve => {
                setTimeout(() => {
                    disconnectListeners();
                    return resolve(false);
                }, lab_Private.INPUT_GUARD_TIMEOUT);
            })
        ]);
        causesInputPromise
            .then(willCauseInput => {
            permissionToExecute.resolve(!willCauseInput);
        })
            .catch(console.warn);
    }
}
/**
 * The namespace for `JupyterLab` class statics.
 */
(function (JupyterLab) {
    /**
     * The application info token.
     */
    JupyterLab.IInfo = new dist_index_js_.Token('@jupyterlab/application:IInfo', 'A service providing metadata about the current application, including disabled extensions and whether dev mode is enabled.');
    /**
     * The information about a JupyterLab application.
     */
    class Info {
        constructor({ connectionStatus, ...options } = {}) {
            var _a, _b, _c, _d, _e, _f, _g;
            this._connectionStatus = connectionStatus !== null && connectionStatus !== void 0 ? connectionStatus : new services_lib_index_js_.ConnectionStatus();
            this._availablePlugins =
                (_a = options.availablePlugins) !== null && _a !== void 0 ? _a : JupyterLab.defaultInfo.availablePlugins;
            this._devMode = (_b = options.devMode) !== null && _b !== void 0 ? _b : JupyterLab.defaultInfo.devMode;
            this._deferred = JSON.parse(JSON.stringify((_c = options.deferred) !== null && _c !== void 0 ? _c : JupyterLab.defaultInfo.deferred));
            this._disabled = JSON.parse(JSON.stringify((_d = options.disabled) !== null && _d !== void 0 ? _d : JupyterLab.defaultInfo.disabled));
            this._filesCached =
                (_e = options.filesCached) !== null && _e !== void 0 ? _e : JupyterLab.defaultInfo.filesCached;
            this._mimeExtensions = JSON.parse(JSON.stringify((_f = options.mimeExtensions) !== null && _f !== void 0 ? _f : JupyterLab.defaultInfo.mimeExtensions));
            this.isConnected =
                (_g = options.isConnected) !== null && _g !== void 0 ? _g : JupyterLab.defaultInfo.isConnected;
        }
        /**
         * The information about available plugins.
         */
        get availablePlugins() {
            return this._availablePlugins;
        }
        /**
         * Whether the application is in dev mode.
         */
        get devMode() {
            return this._devMode;
        }
        /**
         * The collection of deferred extension patterns and matched extensions.
         */
        get deferred() {
            return this._deferred;
        }
        /**
         * The collection of disabled extension patterns and matched extensions.
         */
        get disabled() {
            return this._disabled;
        }
        /**
         * Whether files are cached on the server.
         */
        get filesCached() {
            return this._filesCached;
        }
        /**
         * Every periodic network polling should be paused while this is set
         * to `false`. Extensions should use this value to decide whether to proceed
         * with the polling.
         * The extensions may also set this value to `false` if there is no need to
         * fetch anything from the server backend basing on some conditions
         * (e.g. when an error message dialog is displayed).
         * At the same time, the extensions are responsible for setting this value
         * back to `true`.
         */
        get isConnected() {
            return this._connectionStatus.isConnected;
        }
        set isConnected(v) {
            this._connectionStatus.isConnected = v;
        }
        /**
         * The mime renderer extensions.
         */
        get mimeExtensions() {
            return this._mimeExtensions;
        }
    }
    JupyterLab.Info = Info;
    /**
     * The default JupyterLab application info.
     */
    JupyterLab.defaultInfo = {
        devMode: coreutils_lib_index_js_.PageConfig.getOption('devMode').toLowerCase() === 'true',
        deferred: { patterns: [], matches: [] },
        disabled: { patterns: [], matches: [] },
        mimeExtensions: [],
        availablePlugins: [],
        filesCached: coreutils_lib_index_js_.PageConfig.getOption('cacheFiles').toLowerCase() === 'true',
        isConnected: true
    };
    /**
     * The default JupyterLab application paths.
     */
    JupyterLab.defaultPaths = {
        urls: {
            base: coreutils_lib_index_js_.PageConfig.getOption('baseUrl'),
            notFound: coreutils_lib_index_js_.PageConfig.getOption('notFoundUrl'),
            app: coreutils_lib_index_js_.PageConfig.getOption('appUrl'),
            doc: coreutils_lib_index_js_.PageConfig.getOption('docUrl'),
            static: coreutils_lib_index_js_.PageConfig.getOption('staticUrl'),
            settings: coreutils_lib_index_js_.PageConfig.getOption('settingsUrl'),
            themes: coreutils_lib_index_js_.PageConfig.getOption('themesUrl'),
            translations: coreutils_lib_index_js_.PageConfig.getOption('translationsApiUrl'),
            hubHost: coreutils_lib_index_js_.PageConfig.getOption('hubHost') || undefined,
            hubPrefix: coreutils_lib_index_js_.PageConfig.getOption('hubPrefix') || undefined,
            hubUser: coreutils_lib_index_js_.PageConfig.getOption('hubUser') || undefined,
            hubServerName: coreutils_lib_index_js_.PageConfig.getOption('hubServerName') || undefined
        },
        directories: {
            appSettings: coreutils_lib_index_js_.PageConfig.getOption('appSettingsDir'),
            schemas: coreutils_lib_index_js_.PageConfig.getOption('schemasDir'),
            static: coreutils_lib_index_js_.PageConfig.getOption('staticDir'),
            templates: coreutils_lib_index_js_.PageConfig.getOption('templatesDir'),
            themes: coreutils_lib_index_js_.PageConfig.getOption('themesDir'),
            userSettings: coreutils_lib_index_js_.PageConfig.getOption('userSettingsDir'),
            serverRoot: coreutils_lib_index_js_.PageConfig.getOption('serverRoot'),
            workspaces: coreutils_lib_index_js_.PageConfig.getOption('workspacesDir')
        }
    };
})(JupyterLab || (JupyterLab = {}));
/**
 * A namespace for module-private functionality.
 */
var lab_Private;
(function (Private) {
    /**
     * The delay for invoking a command introduced by user input guard.
     * Decreasing this value may lead to commands incorrectly triggering
     * on user input. Increasing this value will lead to longer delay for
     * command invocation. Note that user input is never delayed.
     *
     * The value represents the number in milliseconds.
     */
    Private.INPUT_GUARD_TIMEOUT = 10;
})(lab_Private || (lab_Private = {}));
//# sourceMappingURL=lab.js.map
// EXTERNAL MODULE: ../node_modules/@jupyterlab/application/lib/layoutrestorer.js
var layoutrestorer = __webpack_require__(67863);
// EXTERNAL MODULE: consume shared module (default) @lumino/disposable@~2.1.4 (singleton) (fallback: ../node_modules/@lumino/disposable/dist/index.es6.js)
var disposable_dist_index_es6_js_ = __webpack_require__(38302);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/lib/router.js
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/




/**
 * A static class that routes URLs within the application.
 */
class Router {
    /**
     * Create a URL router.
     */
    constructor(options) {
        /**
         * If a matching rule's command resolves with the `stop` token during routing,
         * no further matches will execute.
         */
        this.stop = new dist_index_js_.Token('@jupyterlab/application:Router#stop');
        this._routed = new dist_index_es6_js_.Signal(this);
        this._rules = new Map();
        this.base = options.base;
        this.commands = options.commands;
    }
    /**
     * Returns the parsed current URL of the application.
     */
    get current() {
        var _a, _b;
        const { base } = this;
        const parsed = coreutils_lib_index_js_.URLExt.parse(window.location.href);
        const { search, hash } = parsed;
        const path = (_b = (_a = parsed.pathname) === null || _a === void 0 ? void 0 : _a.replace(base, '/')) !== null && _b !== void 0 ? _b : '';
        const request = path + search + hash;
        return { hash, path, request, search };
    }
    /**
     * A signal emitted when the router routes a route.
     */
    get routed() {
        return this._routed;
    }
    /**
     * Navigate to a new path within the application.
     *
     * @param path - The new path or empty string if redirecting to root.
     *
     * @param options - The navigation options.
     */
    navigate(path, options = {}) {
        const { base } = this;
        const { history } = window;
        const { hard } = options;
        const old = document.location.href;
        const url = path && path.indexOf(base) === 0 ? path : coreutils_lib_index_js_.URLExt.join(base, path);
        if (url === old) {
            return hard ? this.reload() : undefined;
        }
        history.pushState({}, '', url);
        if (hard) {
            return this.reload();
        }
        if (!options.skipRouting) {
            // Because a `route()` call may still be in the stack after having received
            // a `stop` token, wait for the next stack frame before calling `route()`.
            requestAnimationFrame(() => {
                void this.route();
            });
        }
    }
    /**
     * Register to route a path pattern to a command.
     *
     * @param options - The route registration options.
     *
     * @returns A disposable that removes the registered rule from the router.
     */
    register(options) {
        var _a;
        const { command, pattern } = options;
        const rank = (_a = options.rank) !== null && _a !== void 0 ? _a : 100;
        const rules = this._rules;
        rules.set(pattern, { command, rank });
        return new disposable_dist_index_es6_js_.DisposableDelegate(() => {
            rules.delete(pattern);
        });
    }
    /**
     * Cause a hard reload of the document.
     */
    reload() {
        window.location.reload();
    }
    /**
     * Route a specific path to an action.
     *
     * #### Notes
     * If a pattern is matched, its command will be invoked with arguments that
     * match the `IRouter.ILocation` interface.
     */
    route() {
        const { commands, current, stop } = this;
        const { request } = current;
        const routed = this._routed;
        const rules = this._rules;
        const matches = [];
        // Collect all rules that match the URL.
        rules.forEach((rule, pattern) => {
            if (request === null || request === void 0 ? void 0 : request.match(pattern)) {
                matches.push(rule);
            }
        });
        // Order the matching rules by rank and enqueue them.
        const queue = matches.sort((a, b) => b.rank - a.rank);
        const done = new dist_index_js_.PromiseDelegate();
        // Process each enqueued command sequentially and short-circuit if a promise
        // resolves with the `stop` token.
        const next = async () => {
            if (!queue.length) {
                routed.emit(current);
                done.resolve(undefined);
                return;
            }
            const { command } = queue.pop();
            try {
                const request = this.current.request;
                const result = await commands.execute(command, current);
                if (result === stop) {
                    queue.length = 0;
                    console.debug(`Routing ${request} was short-circuited by ${command}`);
                }
            }
            catch (reason) {
                console.warn(`Routing ${request} to ${command} failed`, reason);
            }
            void next();
        };
        void next();
        return done.promise;
    }
}
//# sourceMappingURL=router.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/lib/tokens.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * A token for which a plugin can provide to respond to connection failures
 * to the application server.
 */
const IConnectionLost = new dist_index_js_.Token('@jupyterlab/application:IConnectionLost', `A service for invoking the dialog shown
  when JupyterLab has lost its connection to the server. Use this if, for some reason,
  you want to bring up the "connection lost" dialog under new circumstances.`);
/**
 * The application status token.
 */
const ILabStatus = new dist_index_js_.Token('@jupyterlab/application:ILabStatus', `A service for interacting with the application busy/dirty
  status. Use this if you want to set the application "busy" favicon, or to set
  the application "dirty" status, which asks the user for confirmation before leaving the application page.`);
/**
 * The URL Router token.
 */
const IRouter = new dist_index_js_.Token('@jupyterlab/application:IRouter', 'The URL router used by the application. Use this to add custom URL-routing for your extension (e.g., to invoke a command if the user navigates to a sub-path).');
//# sourceMappingURL=tokens.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/lib/treepathupdater.js
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * The tree path updater token.
 */
const ITreePathUpdater = new dist_index_js_.Token('@jupyterlab/application:ITreePathUpdater', 'A service to update the tree path.');
//# sourceMappingURL=treepathupdater.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/lib/utils.js
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */


/**
 * Add a semantic commands to the application and take care
 * of setting up the command changed signal.
 *
 * @param options Semantic command options
 */
function addSemanticCommand(options) {
    const { id, commands, shell, semanticCommands, default: defaultValues, overrides, trans } = options;
    commands.addCommand(id, {
        ...createSemanticCommand({ commands, shell }, semanticCommands, defaultValues !== null && defaultValues !== void 0 ? defaultValues : {}, trans !== null && trans !== void 0 ? trans : lib_index_js_.nullTranslator.load('jupyterlab')),
        ...overrides
    });
    const commandList = Array.isArray(semanticCommands)
        ? semanticCommands
        : [semanticCommands];
    const onCommandChanged = (commands, args) => {
        if (args.id) {
            if (args.id === id && args.type === 'removed') {
                commands.commandChanged.disconnect(onCommandChanged);
            }
            else {
                const commandIds = commandList.reduce((agg, cmd) => agg.concat(cmd.ids), []);
                if (commandIds.includes(args.id)) {
                    switch (args.type) {
                        case 'changed':
                        case 'many-changed':
                            commands.notifyCommandChanged(id);
                            break;
                        case 'removed':
                            for (const cmd of commandList) {
                                cmd.remove(args.id);
                            }
                            break;
                    }
                }
            }
        }
    };
    commands.commandChanged.connect(onCommandChanged);
}
/**
 * Create the command options from the given semantic commands list
 * and the given default values.
 *
 * @param app Jupyter Application
 * @param semanticCommands Single semantic command  or a list of commands
 * @param defaultValues Default values
 * @param trans Translation bundle
 * @returns Command options
 *
 * @deprecated Please use {@link addSemanticCommand}. This function will
 * be removed of the public API in JupyterLab 5.
 */
function createSemanticCommand(app, semanticCommands, defaultValues, trans) {
    const { commands, shell } = app;
    const commandList = Array.isArray(semanticCommands)
        ? semanticCommands
        : [semanticCommands];
    return {
        label: concatenateTexts('label'),
        caption: concatenateTexts('caption'),
        isEnabled: () => {
            var _a;
            const isEnabled = reduceAttribute('isEnabled');
            return ((isEnabled.length > 0 &&
                !isEnabled.some(enabled => enabled === false)) ||
                ((_a = defaultValues.isEnabled) !== null && _a !== void 0 ? _a : false));
        },
        isToggled: () => {
            var _a;
            const isToggled = reduceAttribute('isToggled');
            return (isToggled.some(enabled => enabled === true) ||
                ((_a = defaultValues.isToggled) !== null && _a !== void 0 ? _a : false));
        },
        isVisible: () => {
            var _a;
            const isVisible = reduceAttribute('isVisible');
            return ((isVisible.length > 0 &&
                !isVisible.some(visible => visible === false)) ||
                ((_a = defaultValues.isVisible) !== null && _a !== void 0 ? _a : true));
        },
        execute: async () => {
            const widget = shell.currentWidget;
            const commandIds = commandList.map(cmd => widget !== null ? cmd.getActiveCommandId(widget) : null);
            const toExecute = commandIds.filter(commandId => commandId !== null && commands.isEnabled(commandId));
            let result = null;
            if (toExecute.length > 0) {
                for (const commandId of toExecute) {
                    const args = { [index_js_.SemanticCommand.WIDGET]: widget.id };
                    result = await commands.execute(commandId, args);
                    if (typeof result === 'boolean' && result === false) {
                        // If a command returns a boolean, assume it is the execution success status
                        // So break if it is false.
                        break;
                    }
                }
            }
            else if (defaultValues.execute) {
                result = await commands.execute(defaultValues.execute);
            }
            return result;
        }
    };
    function reduceAttribute(attribute) {
        const widget = shell.currentWidget;
        const commandIds = commandList.map(cmd => widget !== null ? cmd.getActiveCommandId(widget) : null);
        const attributes = commandIds
            .filter(commandId => commandId !== null)
            .map(commandId => commands[attribute](commandId));
        return attributes;
    }
    function concatenateTexts(attribute) {
        return () => {
            var _a;
            const texts = reduceAttribute(attribute).map((text, textIndex) => attribute == 'caption' && textIndex > 0
                ? text.toLocaleLowerCase()
                : text);
            switch (texts.length) {
                case 0:
                    return (_a = defaultValues[attribute]) !== null && _a !== void 0 ? _a : '';
                case 1:
                    return texts[0];
                default: {
                    const hasEllipsis = texts.some(l => /…$/.test(l));
                    const main = texts
                        .slice(undefined, -1)
                        .map(l => l.replace(/…$/, ''))
                        .join(', ');
                    const end = texts.slice(-1)[0].replace(/…$/, '') + (hasEllipsis ? '…' : '');
                    return trans.__('%1 and %2', main, end);
                }
            }
        };
    }
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/lib/index.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * @packageDocumentation
 * @module application
 */











//# sourceMappingURL=index.js.map

/***/ }),

/***/ 67863:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ ILayoutRestorer),
/* harmony export */   c: () => (/* binding */ LayoutRestorer)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5406);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65482);
/* harmony import */ var _lumino_properties__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_properties__WEBPACK_IMPORTED_MODULE_1__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/


/**
 * The layout restorer token.
 */
const ILayoutRestorer = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/application:ILayoutRestorer', 'A service providing application layout restoration functionality. Use this to have your activities restored across page loads.');
/**
 * The data connector key for restorer data.
 */
const KEY = 'layout-restorer:data';
/**
 * The default implementation of a layout restorer.
 *
 * #### Notes
 * The lifecycle for state restoration is subtle. The sequence of events is:
 *
 * 1. The layout restorer plugin is instantiated and makes a `fetch` call to
 *    the data connector that stores the layout restoration data. The `fetch`
 *    call returns a promise that resolves in step 6, below.
 *
 * 2. Other plugins that care about state restoration require the layout
 *    restorer as a dependency.
 *
 * 3. As each load-time plugin initializes (which happens before the front-end
 *    application has `started`), it instructs the layout restorer whether
 *    the restorer ought to `restore` its widgets by passing in its widget
 *    tracker.
 *    Alternatively, a plugin that does not require its own widget tracker
 *    (because perhaps it only creates a single widget, like a command palette),
 *    can simply `add` its widget along with a persistent unique name to the
 *    layout restorer so that its layout state can be restored when the lab
 *    application restores.
 *
 * 4. After all the load-time plugins have finished initializing, the front-end
 *    application `started` promise will resolve. This is the `first`
 *    promise that the layout restorer waits for. By this point, all of the
 *    plugins that care about restoration will have instructed the layout
 *    restorer to `restore` their widget trackers.
 *
 * 5. The layout restorer will then instruct each plugin's widget tracker
 *    to restore its state and reinstantiate whichever widgets it wants. The
 *    tracker returns a promise to the layout restorer that resolves when it
 *    has completed restoring the tracked widgets it cares about.
 *
 * 6. As each widget tracker finishes restoring the widget instances it cares
 *    about, it resolves the promise that was returned to the layout restorer
 *    (in step 5). After all of the promises that the restorer is awaiting have
 *    settled, the restorer then resolves the outstanding `fetch` promise
 *    (from step 1) and hands off a layout state object to the application
 *    shell's `restoreLayout` method for restoration.
 *
 * 7. Once the application shell has finished restoring the layout, the
 *    JupyterLab application's `restored` promise is resolved.
 *
 * Of particular note are steps 5 and 6: since data restoration of plugins
 * is accomplished by executing commands, the command that is used to restore
 * the data of each plugin must return a promise that only resolves when the
 * widget has been created and added to the plugin's widget tracker.
 */
class LayoutRestorer {
    /**
     * Create a layout restorer.
     */
    constructor(options) {
        this._deferred = new Array();
        this._deferredMainArea = null;
        this._firstDone = false;
        this._promisesDone = false;
        this._promises = [];
        this._restored = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();
        this._trackers = new Set();
        this._widgets = new Map();
        this._mode = 'multiple-document';
        this._connector = options.connector;
        this._first = options.first;
        this._registry = options.registry;
        if (options.mode) {
            this._mode = options.mode;
        }
        void this._first
            .then(() => {
            this._firstDone = true;
        })
            .then(() => Promise.all(this._promises))
            .then(() => {
            this._promisesDone = true;
            // Release the tracker set.
            this._trackers.clear();
        })
            .then(() => {
            this._restored.resolve(void 0);
        });
    }
    /**
     * Whether full layout restoration is deferred and is currently incomplete.
     *
     * #### Notes
     * This flag is useful for tracking when the application has started in
     * 'single-document' mode and the main area has not yet been restored.
     */
    get isDeferred() {
        return this._deferred.length > 0;
    }
    /**
     * A promise resolved when the layout restorer is ready to receive signals.
     */
    get restored() {
        return this._restored.promise;
    }
    /**
     * Add a widget to be tracked by the layout restorer.
     */
    add(widget, name) {
        Private.nameProperty.set(widget, name);
        this._widgets.set(name, widget);
        widget.disposed.connect(this._onWidgetDisposed, this);
    }
    /**
     * Fetch the layout state for the application.
     *
     * #### Notes
     * Fetching the layout relies on all widget restoration to be complete, so
     * calls to `fetch` are guaranteed to return after restoration is complete.
     */
    async fetch() {
        var _a;
        const blank = {
            fresh: true,
            mainArea: null,
            downArea: null,
            leftArea: null,
            rightArea: null,
            topArea: null,
            relativeSizes: null
        };
        const layout = this._connector.fetch(KEY);
        try {
            const [data] = await Promise.all([layout, this.restored]);
            if (!data) {
                return blank;
            }
            const { main, down, left, right, relativeSizes, top } = data;
            // If any data exists, then this is not a fresh session.
            const fresh = false;
            // Rehydrate main area.
            let mainArea = null;
            if (this._mode === 'multiple-document') {
                mainArea = this._rehydrateMainArea(main);
            }
            else {
                this._deferredMainArea = main;
            }
            // Rehydrate down area.
            const downArea = this._rehydrateDownArea(down);
            // Rehydrate left area.
            const leftArea = this._rehydrateSideArea(left);
            // Rehydrate right area.
            const rightArea = this._rehydrateSideArea(right);
            return {
                fresh,
                mainArea,
                downArea,
                leftArea,
                rightArea,
                relativeSizes: relativeSizes || null,
                topArea: (_a = top) !== null && _a !== void 0 ? _a : null
            };
        }
        catch (error) {
            return blank;
        }
    }
    /**
     * Restore the widgets of a particular widget tracker.
     *
     * @param tracker - The widget tracker whose widgets will be restored.
     *
     * @param options - The restoration options.
     */
    async restore(tracker, options) {
        if (this._firstDone) {
            throw new Error('restore() must be called before `first` has resolved.');
        }
        const { namespace } = tracker;
        if (this._trackers.has(namespace)) {
            throw new Error(`The tracker "${namespace}" is already restored.`);
        }
        const { args, command, name, when } = options;
        // Add the tracker to the private trackers collection.
        this._trackers.add(namespace);
        // Whenever a new widget is added to the tracker, record its name.
        tracker.widgetAdded.connect((_, widget) => {
            const widgetName = name(widget);
            if (widgetName) {
                this.add(widget, `${namespace}:${widgetName}`);
            }
        }, this);
        // Whenever a widget is updated, get its new name.
        tracker.widgetUpdated.connect((_, widget) => {
            const widgetName = name(widget);
            if (widgetName) {
                const name = `${namespace}:${widgetName}`;
                Private.nameProperty.set(widget, name);
                this._widgets.set(name, widget);
            }
        });
        const first = this._first;
        if (this._mode == 'multiple-document') {
            const promise = tracker
                .restore({
                args: args || (() => _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.emptyObject),
                command,
                connector: this._connector,
                name,
                registry: this._registry,
                when: when ? [first].concat(when) : first
            })
                .catch(error => {
                console.error(error);
            });
            this._promises.push(promise);
            return promise;
        }
        tracker.defer({
            args: args || (() => _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.emptyObject),
            command,
            connector: this._connector,
            name,
            registry: this._registry,
            when: when ? [first].concat(when) : first
        });
        this._deferred.push(tracker);
    }
    /**
     * Restore the application layout if its restoration has been deferred.
     *
     * @returns - the rehydrated main area.
     */
    async restoreDeferred() {
        if (!this.isDeferred) {
            return null;
        }
        // Empty the deferred list and wait for all trackers to restore.
        const wait = Promise.resolve();
        const promises = this._deferred.map(t => wait.then(() => t.restore()));
        this._deferred.length = 0;
        await Promise.all(promises);
        // Rehydrate the main area layout.
        return this._rehydrateMainArea(this._deferredMainArea);
    }
    /**
     * Save the layout state for the application.
     */
    save(layout) {
        var _a;
        // If there are promises that are unresolved, bail.
        if (!this._promisesDone) {
            const warning = 'save() was called prematurely.';
            console.warn(warning);
            return Promise.reject(warning);
        }
        const dehydrated = {};
        // Save the cached main area layout if restoration is deferred.
        dehydrated.main = this.isDeferred
            ? this._deferredMainArea
            : this._dehydrateMainArea(layout.mainArea);
        // Update only the current widget in the db when restoration is deferred.
        // Useful for providing the tab title in doc mode.
        if (this.isDeferred) {
            const currentWidget = (_a = layout.mainArea) === null || _a === void 0 ? void 0 : _a.currentWidget;
            if (currentWidget) {
                const widgetName = Private.nameProperty.get(currentWidget);
                dehydrated.main = {
                    ...dehydrated.main,
                    current: widgetName || undefined
                };
            }
        }
        dehydrated.down = this._dehydrateDownArea(layout.downArea);
        dehydrated.left = this._dehydrateSideArea(layout.leftArea);
        dehydrated.right = this._dehydrateSideArea(layout.rightArea);
        dehydrated.relativeSizes = layout.relativeSizes;
        dehydrated.top = { ...layout.topArea };
        return this._connector.save(KEY, dehydrated);
    }
    /**
     * Dehydrate a main area description into a serializable object.
     */
    _dehydrateMainArea(area) {
        if (!area) {
            return null;
        }
        return Private.serializeMain(area);
    }
    /**
     * Rehydrate a serialized main area description object.
     *
     * #### Notes
     * This function consumes data that can become corrupted, so it uses type
     * coercion to guarantee the dehydrated object is safely processed.
     */
    _rehydrateMainArea(area) {
        if (!area) {
            return null;
        }
        return Private.deserializeMain(area, this._widgets);
    }
    /**
     * Dehydrate a down area description into a serializable object.
     */
    _dehydrateDownArea(area) {
        if (!area) {
            return null;
        }
        const dehydrated = {
            size: area.size
        };
        if (area.currentWidget) {
            const current = Private.nameProperty.get(area.currentWidget);
            if (current) {
                dehydrated.current = current;
            }
        }
        if (area.widgets) {
            dehydrated.widgets = area.widgets
                .map(widget => Private.nameProperty.get(widget))
                .filter(name => !!name);
        }
        return dehydrated;
    }
    /**
     * Rehydrate a serialized side area description object.
     *
     * #### Notes
     * This function consumes data that can become corrupted, so it uses type
     * coercion to guarantee the dehydrated object is safely processed.
     */
    _rehydrateDownArea(area) {
        var _a;
        if (!area) {
            return { currentWidget: null, size: 0.0, widgets: null };
        }
        const internal = this._widgets;
        const currentWidget = area.current && internal.has(`${area.current}`)
            ? internal.get(`${area.current}`)
            : null;
        const widgets = !Array.isArray(area.widgets)
            ? null
            : area.widgets
                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)
                .filter(widget => !!widget);
        return {
            currentWidget: currentWidget,
            size: (_a = area.size) !== null && _a !== void 0 ? _a : 0.0,
            widgets: widgets
        };
    }
    /**
     * Dehydrate a side area description into a serializable object.
     */
    _dehydrateSideArea(area) {
        if (!area) {
            return null;
        }
        const dehydrated = {
            collapsed: area.collapsed,
            visible: area.visible
        };
        if (area.currentWidget) {
            const current = Private.nameProperty.get(area.currentWidget);
            if (current) {
                dehydrated.current = current;
            }
        }
        if (area.widgets) {
            dehydrated.widgets = area.widgets
                .map(widget => Private.nameProperty.get(widget))
                .filter(name => !!name);
        }
        if (area.widgetStates) {
            dehydrated.widgetStates = area.widgetStates;
        }
        return dehydrated;
    }
    /**
     * Rehydrate a serialized side area description object.
     *
     * #### Notes
     * This function consumes data that can become corrupted, so it uses type
     * coercion to guarantee the dehydrated object is safely processed.
     */
    _rehydrateSideArea(area) {
        var _a, _b;
        if (!area) {
            return {
                collapsed: true,
                currentWidget: null,
                visible: true,
                widgets: null,
                widgetStates: {
                    ['null']: {
                        sizes: null,
                        expansionStates: null
                    }
                }
            };
        }
        const internal = this._widgets;
        const collapsed = (_a = area.collapsed) !== null && _a !== void 0 ? _a : false;
        const currentWidget = area.current && internal.has(`${area.current}`)
            ? internal.get(`${area.current}`)
            : null;
        const widgets = !Array.isArray(area.widgets)
            ? null
            : area.widgets
                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)
                .filter(widget => !!widget);
        const widgetStates = area.widgetStates;
        return {
            collapsed,
            currentWidget: currentWidget,
            widgets: widgets,
            visible: (_b = area.visible) !== null && _b !== void 0 ? _b : true,
            widgetStates: widgetStates
        };
    }
    /**
     * Handle a widget disposal.
     */
    _onWidgetDisposed(widget) {
        const name = Private.nameProperty.get(widget);
        this._widgets.delete(name);
    }
}
/*
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for a widget's ID in the serialized restore data.
     */
    Private.nameProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_1__.AttachedProperty({
        name: 'name',
        create: owner => ''
    });
    /**
     * Serialize individual areas within the main area.
     */
    function serializeArea(area) {
        if (!area || !area.type) {
            return null;
        }
        if (area.type === 'tab-area') {
            return {
                type: 'tab-area',
                currentIndex: area.currentIndex,
                widgets: area.widgets
                    .map(widget => Private.nameProperty.get(widget))
                    .filter(name => !!name)
            };
        }
        return {
            type: 'split-area',
            orientation: area.orientation,
            sizes: area.sizes,
            children: area.children
                .map(serializeArea)
                .filter(area => !!area)
        };
    }
    /**
     * Return a dehydrated, serializable version of the main dock panel.
     */
    function serializeMain(area) {
        const dehydrated = {
            dock: (area && area.dock && serializeArea(area.dock.main)) || null
        };
        if (area) {
            if (area.currentWidget) {
                const current = Private.nameProperty.get(area.currentWidget);
                if (current) {
                    dehydrated.current = current;
                }
            }
        }
        return dehydrated;
    }
    Private.serializeMain = serializeMain;
    /**
     * Deserialize individual areas within the main area.
     *
     * #### Notes
     * Because this data comes from a potentially unreliable foreign source, it is
     * typed as a `JSONObject`; but the actual expected type is:
     * `ITabArea | ISplitArea`.
     *
     * For fault tolerance, types are manually checked in deserialization.
     */
    function deserializeArea(area, names) {
        if (!area) {
            return null;
        }
        // Because this data is saved to a foreign data source, its type safety is
        // not guaranteed when it is retrieved, so exhaustive checks are necessary.
        const type = area.type || 'unknown';
        if (type === 'unknown' || (type !== 'tab-area' && type !== 'split-area')) {
            console.warn(`Attempted to deserialize unknown type: ${type}`);
            return null;
        }
        if (type === 'tab-area') {
            const { currentIndex, widgets } = area;
            const hydrated = {
                type: 'tab-area',
                currentIndex: currentIndex || 0,
                widgets: (widgets &&
                    widgets
                        .map(widget => names.get(widget))
                        .filter(widget => !!widget)) ||
                    []
            };
            // Make sure the current index is within bounds.
            if (hydrated.currentIndex > hydrated.widgets.length - 1) {
                hydrated.currentIndex = 0;
            }
            return hydrated;
        }
        const { orientation, sizes, children } = area;
        const hydrated = {
            type: 'split-area',
            orientation: orientation,
            sizes: sizes || [],
            children: (children &&
                children
                    .map(child => deserializeArea(child, names))
                    .filter(widget => !!widget)) ||
                []
        };
        return hydrated;
    }
    /**
     * Return the hydrated version of the main dock panel, ready to restore.
     *
     * #### Notes
     * Because this data comes from a potentially unreliable foreign source, it is
     * typed as a `JSONObject`; but the actual expected type is: `IMainArea`.
     *
     * For fault tolerance, types are manually checked in deserialization.
     */
    function deserializeMain(area, names) {
        if (!area) {
            return null;
        }
        const name = area.current || null;
        const dock = area.dock || null;
        return {
            currentWidget: (name && names.has(name) && names.get(name)) || null,
            dock: dock ? { main: deserializeArea(dock, names) } : null
        };
    }
    Private.deserializeMain = deserializeMain;
})(Private || (Private = {}));
//# sourceMappingURL=layoutrestorer.js.map

/***/ }),

/***/ 75677:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   aX: () => (/* binding */ createRendermimePlugin),
/* harmony export */   as: () => (/* binding */ createRendermimePlugins),
/* harmony export */   w2: () => (/* binding */ IMimeDocumentTracker)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94079);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74886);
/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(940);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50856);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(39089);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5406);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _lumino_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(65482);
/* harmony import */ var _lumino_properties__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lumino_properties__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _layoutrestorer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(67863);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.








/**
 * The mime document tracker token.
 */
const IMimeDocumentTracker = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_5__.Token('@jupyterlab/application:IMimeDocumentTracker', 'A widget tracker for documents rendered using a mime renderer extension. Use this if you want to list and interact with documents rendered by such extensions.');
/**
 * Create rendermime plugins for rendermime extension modules.
 */
function createRendermimePlugins(extensions) {
    const plugins = [];
    const namespace = 'application-mimedocuments';
    const tracker = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.WidgetTracker({ namespace });
    extensions.forEach(mod => {
        let data = mod.default;
        // Handle CommonJS exports.
        if (!mod.hasOwnProperty('__esModule')) {
            data = mod;
        }
        if (!Array.isArray(data)) {
            data = [data];
        }
        data.forEach(item => {
            plugins.push(createRendermimePlugin(tracker, item));
        });
    });
    // Also add a meta-plugin handling state restoration
    // and exposing the mime document widget tracker.
    plugins.push({
        id: '@jupyterlab/application-extension:mimedocument',
        description: 'Provides a mime document widget tracker.',
        optional: [_layoutrestorer__WEBPACK_IMPORTED_MODULE_7__/* .ILayoutRestorer */ .L],
        provides: IMimeDocumentTracker,
        autoStart: true,
        activate: (app, restorer) => {
            if (restorer) {
                void restorer.restore(tracker, {
                    command: 'docmanager:open',
                    args: widget => ({
                        path: widget.context.path,
                        factory: Private.factoryNameProperty.get(widget)
                    }),
                    name: widget => `${widget.context.path}:${Private.factoryNameProperty.get(widget)}`
                });
            }
            return tracker;
        }
    });
    return plugins;
}
/**
 * Create rendermime plugins for rendermime extension modules.
 */
function createRendermimePlugin(tracker, item) {
    return {
        id: item.id,
        description: item.description,
        requires: [_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__.IRenderMimeRegistry, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_3__.ITranslator],
        autoStart: true,
        activate: (app, rendermime, translator) => {
            // Add the mime renderer.
            if (item.rank !== undefined) {
                rendermime.addFactory(item.rendererFactory, item.rank);
            }
            else {
                rendermime.addFactory(item.rendererFactory);
            }
            // Handle the widget factory.
            if (!item.documentWidgetFactoryOptions) {
                return;
            }
            const registry = app.docRegistry;
            let options = [];
            if (Array.isArray(item.documentWidgetFactoryOptions)) {
                options = item.documentWidgetFactoryOptions;
            }
            else {
                options = [
                    item.documentWidgetFactoryOptions
                ];
            }
            if (item.fileTypes) {
                item.fileTypes.forEach(ft => {
                    if (ft.icon) {
                        // upconvert the contents of the icon field to a proper LabIcon
                        ft = { ...ft, icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_4__.LabIcon.resolve({ icon: ft.icon }) };
                    }
                    app.docRegistry.addFileType(ft);
                });
            }
            options.forEach(option => {
                const toolbarFactory = option.toolbarFactory
                    ? (w) => option.toolbarFactory(w.content.renderer)
                    : undefined;
                const factory = new _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_1__.MimeDocumentFactory({
                    renderTimeout: item.renderTimeout,
                    dataType: item.dataType,
                    rendermime,
                    modelName: option.modelName,
                    name: option.name,
                    primaryFileType: registry.getFileType(option.primaryFileType),
                    fileTypes: option.fileTypes,
                    defaultFor: option.defaultFor,
                    defaultRendered: option.defaultRendered,
                    toolbarFactory,
                    translator,
                    factory: item.rendererFactory
                });
                registry.addWidgetFactory(factory);
                factory.widgetCreated.connect((sender, widget) => {
                    Private.factoryNameProperty.set(widget, factory.name);
                    // Notify the widget tracker if restore data needs to update.
                    widget.context.pathChanged.connect(() => {
                        void tracker.save(widget);
                    });
                    void tracker.add(widget);
                });
            });
        }
    };
}
/**
 * Private namespace for the module.
 */
var Private;
(function (Private) {
    /**
     * An attached property for keeping the factory name
     * that was used to create a mimedocument.
     */
    Private.factoryNameProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_6__.AttachedProperty({
        name: 'factoryName',
        create: () => undefined
    });
})(Private || (Private = {}));
//# sourceMappingURL=mimerenderers.js.map

/***/ }),

/***/ 20389:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ LabStatus)
/* harmony export */ });
/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38302);
/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_disposable__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2536);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * The application status signals and flags class.
 */
class LabStatus {
    /**
     * Construct a new  status object.
     */
    constructor(app) {
        this._busyCount = 0;
        this._dirtyCount = 0;
        this._busySignal = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(app);
        this._dirtySignal = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(app);
    }
    /**
     * Returns a signal for when application changes its busy status.
     */
    get busySignal() {
        return this._busySignal;
    }
    /**
     * Returns a signal for when application changes its dirty status.
     */
    get dirtySignal() {
        return this._dirtySignal;
    }
    /**
     * Whether the application is busy.
     */
    get isBusy() {
        return this._busyCount > 0;
    }
    /**
     * Whether the application is dirty.
     */
    get isDirty() {
        return this._dirtyCount > 0;
    }
    /**
     * Set the application state to dirty.
     *
     * @returns A disposable used to clear the dirty state for the caller.
     */
    setDirty() {
        const oldDirty = this.isDirty;
        this._dirtyCount++;
        if (this.isDirty !== oldDirty) {
            this._dirtySignal.emit(this.isDirty);
        }
        return new _lumino_disposable__WEBPACK_IMPORTED_MODULE_0__.DisposableDelegate(() => {
            const oldDirty = this.isDirty;
            this._dirtyCount = Math.max(0, this._dirtyCount - 1);
            if (this.isDirty !== oldDirty) {
                this._dirtySignal.emit(this.isDirty);
            }
        });
    }
    /**
     * Set the application state to busy.
     *
     * @returns A disposable used to clear the busy state for the caller.
     */
    setBusy() {
        const oldBusy = this.isBusy;
        this._busyCount++;
        if (this.isBusy !== oldBusy) {
            this._busySignal.emit(this.isBusy);
        }
        return new _lumino_disposable__WEBPACK_IMPORTED_MODULE_0__.DisposableDelegate(() => {
            const oldBusy = this.isBusy;
            this._busyCount--;
            if (this.isBusy !== oldBusy) {
                this._busySignal.emit(this.isBusy);
            }
        });
    }
}
//# sourceMappingURL=status.js.map

/***/ }),

/***/ 67663:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// EXTERNAL MODULE: ../node_modules/@fortawesome/fontawesome-free/css/all.min.css
var all_min = __webpack_require__(94891);
// EXTERNAL MODULE: ../node_modules/@fortawesome/fontawesome-free/css/v4-shims.min.css
var v4_shims_min = __webpack_require__(60609);
// EXTERNAL MODULE: ../node_modules/@lumino/widgets/style/index.js + 1 modules
var style = __webpack_require__(20959);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/ui-components/style/index.js + 1 modules
var ui_components_style = __webpack_require__(26238);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/apputils/style/index.js + 1 modules
var apputils_style = __webpack_require__(57261);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/docregistry/style/index.js + 1 modules
var docregistry_style = __webpack_require__(30507);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(94830);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(80592);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(99763);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(28915);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(80366);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(17352);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/css-loader/dist/cjs.js!../node_modules/@jupyterlab/application/style/base.css
var base = __webpack_require__(82119);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/style/base.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(base/* default */.Z, options);




       /* harmony default export */ const style_base = (base/* default */.Z && base/* default */.Z.locals ? base/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ../node_modules/@jupyterlab/application/style/index.js
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* This file was auto-generated by ensurePackage() in @jupyterlab/buildutils */










/***/ }),

/***/ 3147:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ lib),
  kernelSettings: () => (/* binding */ kernelSettings),
  toggleHeader: () => (/* binding */ toggleHeader)
});

// EXTERNAL MODULE: consume shared module (default) @jupyterlab/application@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/application/lib/index.js)
var index_js_ = __webpack_require__(77415);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/apputils@~4.5.3 (singleton) (fallback: ../node_modules/@jupyterlab/apputils/lib/index.js)
var lib_index_js_ = __webpack_require__(94079);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/coreutils@~6.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/coreutils/lib/index.js)
var coreutils_lib_index_js_ = __webpack_require__(60649);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/settingregistry@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/settingregistry/lib/index.js)
var settingregistry_lib_index_js_ = __webpack_require__(94238);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/statedb@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/statedb/lib/index.js)
var statedb_lib_index_js_ = __webpack_require__(70870);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/translation@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/translation/lib/index.js)
var translation_lib_index_js_ = __webpack_require__(50856);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/ui-components@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/ui-components/lib/index.js)
var ui_components_lib_index_js_ = __webpack_require__(39089);
// EXTERNAL MODULE: consume shared module (default) @lumino/coreutils@~2.2.1 (singleton) (fallback: ../node_modules/@lumino/coreutils/dist/index.js)
var dist_index_js_ = __webpack_require__(5406);
// EXTERNAL MODULE: consume shared module (default) @lumino/disposable@~2.1.4 (singleton) (fallback: ../node_modules/@lumino/disposable/dist/index.es6.js)
var index_es6_js_ = __webpack_require__(38302);
// EXTERNAL MODULE: consume shared module (default) @lumino/polling@^2.1.4 (strict) (fallback: ../node_modules/@lumino/polling/dist/index.es6.js)
var dist_index_es6_js_ = __webpack_require__(1492);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/services@~7.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/services/lib/index.js)
var services_lib_index_js_ = __webpack_require__(43234);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/announcements.js
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */





const COMMAND_HELP_OPEN = 'help:open';
const NEWS_API_URL = '/lab/api/news';
const UPDATE_API_URL = '/lab/api/update';
const PRIVACY_URL = 'https://jupyterlab.readthedocs.io/en/stable/privacy_policies.html';
/**
 * Call the announcement API
 *
 * @param endpoint Endpoint to request
 * @param init Initial values for the request
 * @returns The response body interpreted as JSON
 */
async function requestAPI(endpoint, init = {}) {
    // Make request to Jupyter API
    const settings = services_lib_index_js_.ServerConnection.makeSettings();
    const requestUrl = coreutils_lib_index_js_.URLExt.join(settings.baseUrl, endpoint);
    let response;
    try {
        response = await services_lib_index_js_.ServerConnection.makeRequest(requestUrl, init, settings);
    }
    catch (error) {
        throw new services_lib_index_js_.ServerConnection.NetworkError(error);
    }
    const data = await response.json();
    if (!response.ok) {
        throw new services_lib_index_js_.ServerConnection.ResponseError(response, data.message);
    }
    return data;
}
const announcements = {
    id: '@jupyterlab/apputils-extension:announcements',
    description: 'Add the announcement feature. It will fetch news on the internet and check for application updates.',
    autoStart: true,
    optional: [services_lib_index_js_.IConfigSectionManager, settingregistry_lib_index_js_.ISettingRegistry, translation_lib_index_js_.ITranslator],
    activate: (app, configSectionManager, settingRegistry, translator) => {
        var _a, _b;
        const CONFIG_SECTION_NAME = announcements.id.replace(/[^\w]/g, '');
        void Promise.all([
            app.restored,
            (_a = settingRegistry === null || settingRegistry === void 0 ? void 0 : settingRegistry.load('@jupyterlab/apputils-extension:notification')) !== null && _a !== void 0 ? _a : Promise.resolve(null),
            // Use config instead of state to store independently of the workspace
            // if a news has been displayed or not.
            (_b = configSectionManager === null || configSectionManager === void 0 ? void 0 : configSectionManager.create({
                name: CONFIG_SECTION_NAME
            })) !== null && _b !== void 0 ? _b : Promise.resolve(null)
        ]).then(async ([_, settings, config]) => {
            const trans = (translator !== null && translator !== void 0 ? translator : translation_lib_index_js_.nullTranslator).load('jupyterlab');
            // Store dismiss state
            lib_index_js_.Notification.manager.changed.connect((manager, change) => {
                var _a;
                if (change.type !== 'removed') {
                    return;
                }
                const { id, tags } = ((_a = change
                    .notification.options.data) !== null && _a !== void 0 ? _a : {});
                if ((tags !== null && tags !== void 0 ? tags : []).some(tag => ['news', 'update'].includes(tag)) && id) {
                    const update = {};
                    update[id] = { seen: true, dismissed: true };
                    config === null || config === void 0 ? void 0 : config.update(update).catch(reason => {
                        console.error(`Failed to update the announcements config:\n${reason}`);
                    });
                }
            });
            const mustFetchNews = settings === null || settings === void 0 ? void 0 : settings.get('fetchNews').composite;
            if (mustFetchNews === 'none') {
                const notificationId = lib_index_js_.Notification.emit(trans.__('Would you like to get notified about official Jupyter news?'), 'default', {
                    autoClose: false,
                    actions: [
                        {
                            label: trans.__('Open privacy policy'),
                            caption: PRIVACY_URL,
                            callback: event => {
                                event.preventDefault();
                                if (app.commands.hasCommand(COMMAND_HELP_OPEN)) {
                                    void app.commands.execute(COMMAND_HELP_OPEN, {
                                        text: trans.__('Privacy policies'),
                                        url: PRIVACY_URL
                                    });
                                }
                                else {
                                    window.open(PRIVACY_URL, '_blank', 'noreferrer');
                                }
                            },
                            displayType: 'link'
                        },
                        {
                            label: trans.__('Yes'),
                            callback: () => {
                                lib_index_js_.Notification.dismiss(notificationId);
                                config === null || config === void 0 ? void 0 : config.update({}).then(() => fetchNews()).catch(reason => {
                                    console.error(`Failed to get the news:\n${reason}`);
                                });
                                settings === null || settings === void 0 ? void 0 : settings.set('fetchNews', 'true').catch((reason) => {
                                    console.error(`Failed to save setting 'fetchNews':\n${reason}`);
                                });
                            }
                        },
                        {
                            label: trans.__('No'),
                            callback: () => {
                                lib_index_js_.Notification.dismiss(notificationId);
                                settings === null || settings === void 0 ? void 0 : settings.set('fetchNews', 'false').catch((reason) => {
                                    console.error(`Failed to save setting 'fetchNews':\n${reason}`);
                                });
                            }
                        }
                    ]
                });
            }
            else {
                await fetchNews();
            }
            async function fetchNews() {
                var _a, _b, _c, _d;
                if (((_a = settings === null || settings === void 0 ? void 0 : settings.get('fetchNews').composite) !== null && _a !== void 0 ? _a : 'false') === 'true') {
                    try {
                        const response = await requestAPI(NEWS_API_URL);
                        for (const { link, message, type, options } of response.news) {
                            // @ts-expect-error data has no index
                            const id = options.data['id'];
                            // Filter those notifications
                            const state = (_b = config === null || config === void 0 ? void 0 : config.data[id]) !== null && _b !== void 0 ? _b : {
                                seen: false,
                                dismissed: false
                            };
                            if (!state.dismissed) {
                                options.actions = [
                                    {
                                        label: trans.__('Hide'),
                                        caption: trans.__('Never show this notification again.'),
                                        callback: () => {
                                            const update = {};
                                            update[id] = { seen: true, dismissed: true };
                                            config === null || config === void 0 ? void 0 : config.update(update).catch(reason => {
                                                console.error(`Failed to update the announcements config:\n${reason}`);
                                            });
                                        }
                                    }
                                ];
                                if ((link === null || link === void 0 ? void 0 : link.length) === 2) {
                                    options.actions.push({
                                        label: link[0],
                                        caption: link[1],
                                        callback: () => {
                                            window.open(link[1], '_blank', 'noreferrer');
                                        },
                                        displayType: 'link'
                                    });
                                }
                                if (!state.seen) {
                                    options.autoClose = 5000;
                                    const update = {};
                                    update[id] = { seen: true };
                                    config === null || config === void 0 ? void 0 : config.update(update).catch(reason => {
                                        console.error(`Failed to update the announcements config:\n${reason}`);
                                    });
                                }
                                lib_index_js_.Notification.emit(message, type, options);
                            }
                        }
                    }
                    catch (reason) {
                        console.log('Failed to get the announcements.', reason);
                    }
                }
                if ((_c = settings === null || settings === void 0 ? void 0 : settings.get('checkForUpdates').composite) !== null && _c !== void 0 ? _c : true) {
                    const response = await requestAPI(UPDATE_API_URL);
                    if (response.notification) {
                        const { link, message, type, options } = response.notification;
                        // @ts-expect-error data has no index
                        const id = options.data['id'];
                        const state = (_d = config === null || config === void 0 ? void 0 : config.data[id]) !== null && _d !== void 0 ? _d : {
                            seen: false,
                            dismissed: false
                        };
                        if (!state.dismissed) {
                            let notificationId;
                            options.actions = [
                                {
                                    label: trans.__('Ignore all updates'),
                                    caption: trans.__('Do not prompt me if a new JupyterLab version is available.'),
                                    callback: () => {
                                        settings === null || settings === void 0 ? void 0 : settings.set('checkForUpdates', false).then(() => {
                                            lib_index_js_.Notification.dismiss(notificationId);
                                        }).catch((reason) => {
                                            console.error('Failed to set the `checkForUpdates` setting.', reason);
                                        });
                                    }
                                }
                            ];
                            if ((link === null || link === void 0 ? void 0 : link.length) === 2) {
                                options.actions.push({
                                    label: link[0],
                                    caption: link[1],
                                    callback: () => {
                                        window.open(link[1], '_blank', 'noreferrer');
                                    },
                                    // Because the link to the changelog is the primary option,
                                    // display it in an accent color.
                                    displayType: 'accent'
                                });
                            }
                            if (!state.seen) {
                                options.autoClose = 5000;
                                const update = {};
                                update[id] = { seen: true };
                                config === null || config === void 0 ? void 0 : config.update(update).catch(reason => {
                                    console.error(`Failed to update the announcements config:\n${reason}`);
                                });
                            }
                            notificationId = lib_index_js_.Notification.emit(message, type, options);
                        }
                    }
                }
            }
        });
    }
};
//# sourceMappingURL=announcements.js.map
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/mainmenu@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/mainmenu/lib/index.js)
var mainmenu_lib_index_js_ = __webpack_require__(68405);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/licensesplugin.js
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */






/**
 * The command IDs used by the licenses plugin.
 */
var CommandIDs;
(function (CommandIDs) {
    CommandIDs.licenses = 'apputils:licenses';
    CommandIDs.licenseReport = 'apputils:license-report';
    CommandIDs.refreshLicenses = 'apputils:licenses-refresh';
})(CommandIDs || (CommandIDs = {}));
/**
 * The license client plugin for fetching licenses.
 */
const licensesClient = {
    id: '@jupyterlab/apputils-extension:licenses-client',
    description: 'The licenses client plugin for fetching licenses.',
    autoStart: true,
    provides: lib_index_js_.ILicensesClient,
    activate: (app) => {
        const licensesUrl = coreutils_lib_index_js_.URLExt.join(coreutils_lib_index_js_.PageConfig.getBaseUrl(), coreutils_lib_index_js_.PageConfig.getOption('licensesUrl')) + '/';
        const serverSettings = app.serviceManager.serverSettings;
        return new lib_index_js_.Licenses.LicensesClient({ licensesUrl, serverSettings });
    }
};
/**
 * A plugin to add a licenses reporting tools.
 */
const licensesPlugin = {
    id: '@jupyterlab/apputils-extension:licenses-plugin',
    description: 'Adds licenses reporting tools.',
    requires: [lib_index_js_.ILicensesClient, translation_lib_index_js_.ITranslator],
    optional: [index_js_.ILayoutRestorer, mainmenu_lib_index_js_.IMainMenu, lib_index_js_.ICommandPalette],
    autoStart: true,
    activate: (app, client, translator, restorer, menu, palette) => {
        const { commands, shell } = app;
        const trans = translator.load('jupyterlab');
        const category = trans.__('Help');
        const downloadAsText = trans.__('Download All Licenses as');
        const refreshLicenses = trans.__('Refresh Licenses');
        const licensesNamespace = 'help-licenses';
        const licensesTracker = new lib_index_js_.WidgetTracker({
            namespace: licensesNamespace
        });
        // translation strings
        const licensesText = trans.__('Licenses');
        // an incrementer for license widget ids
        let counter = 0;
        /**
         * Create a MainAreaWidget for a license viewer
         */
        function createLicenseWidget(args) {
            const licensesModel = new lib_index_js_.Licenses.Model({
                ...args,
                client,
                trans
            });
            const content = new lib_index_js_.Licenses({ model: licensesModel });
            content.id = `${licensesNamespace}-${++counter}`;
            content.title.label = licensesText;
            content.title.icon = ui_components_lib_index_js_.copyrightIcon;
            const main = new lib_index_js_.MainAreaWidget({
                content,
                reveal: licensesModel.licensesReady
            });
            main.toolbar.addItem('refresh-licenses', new ui_components_lib_index_js_.CommandToolbarButton({
                id: CommandIDs.refreshLicenses,
                args: { noLabel: 1 },
                commands
            }));
            main.toolbar.addItem('spacer', ui_components_lib_index_js_.Toolbar.createSpacerItem());
            for (const format of Object.keys(lib_index_js_.Licenses.REPORT_FORMATS)) {
                const button = new ui_components_lib_index_js_.CommandToolbarButton({
                    id: CommandIDs.licenseReport,
                    args: { format, noLabel: 1 },
                    commands
                });
                main.toolbar.addItem(`download-${format}`, button);
            }
            return main;
        }
        /**
         * Return a full license report format based on a format name
         */
        function formatOrDefault(format) {
            return (lib_index_js_.Licenses.REPORT_FORMATS[format] ||
                lib_index_js_.Licenses.REPORT_FORMATS[lib_index_js_.Licenses.DEFAULT_FORMAT]);
        }
        // register license-related commands
        commands.addCommand(CommandIDs.licenses, {
            label: licensesText,
            execute: (args) => {
                // bail if no license API is available from the server
                if (!coreutils_lib_index_js_.PageConfig.getOption('licensesUrl')) {
                    console.warn('No license API available from the server');
                    return;
                }
                const licenseMain = createLicenseWidget(args);
                shell.add(licenseMain, 'main', { type: 'Licenses' });
                // add to tracker so it can be restored, and update when choices change
                void licensesTracker.add(licenseMain);
                licenseMain.content.model.trackerDataChanged.connect(() => {
                    void licensesTracker.save(licenseMain);
                });
                return licenseMain;
            }
        });
        commands.addCommand(CommandIDs.refreshLicenses, {
            label: args => (args.noLabel ? '' : refreshLicenses),
            caption: refreshLicenses,
            icon: ui_components_lib_index_js_.refreshIcon,
            execute: async () => {
                var _a;
                return (_a = licensesTracker.currentWidget) === null || _a === void 0 ? void 0 : _a.content.model.initLicenses();
            }
        });
        commands.addCommand(CommandIDs.licenseReport, {
            label: args => {
                if (args.noLabel) {
                    return '';
                }
                const format = formatOrDefault(`${args.format}`);
                return `${downloadAsText} ${format.title}`;
            },
            caption: args => {
                const format = formatOrDefault(`${args.format}`);
                return `${downloadAsText} ${format.title}`;
            },
            icon: args => {
                const format = formatOrDefault(`${args.format}`);
                return format.icon;
            },
            execute: async (args) => {
                var _a;
                const format = formatOrDefault(`${args.format}`);
                return await ((_a = licensesTracker.currentWidget) === null || _a === void 0 ? void 0 : _a.content.model.download({
                    format: format.id
                }));
            }
        });
        // handle optional integrations
        if (palette) {
            palette.addItem({ command: CommandIDs.licenses, category });
        }
        if (menu) {
            const helpMenu = menu.helpMenu;
            helpMenu.addGroup([{ command: CommandIDs.licenses }], 0);
        }
        if (restorer) {
            void restorer.restore(licensesTracker, {
                command: CommandIDs.licenses,
                name: widget => 'licenses',
                args: widget => {
                    const { currentBundleName, currentPackageIndex, packageFilter } = widget.content.model;
                    const args = {
                        currentBundleName,
                        currentPackageIndex,
                        packageFilter
                    };
                    return args;
                }
            });
        }
    }
};
//# sourceMappingURL=licensesplugin.js.map
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/statusbar@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/statusbar/lib/index.js)
var statusbar_lib_index_js_ = __webpack_require__(98338);
// EXTERNAL MODULE: consume shared module (default) @lumino/widgets@~2.7.1 (singleton) (fallback: ../node_modules/@lumino/widgets/dist/index.es6.js)
var widgets_dist_index_es6_js_ = __webpack_require__(60920);
// EXTERNAL MODULE: consume shared module (default) react@~18.2.0 (singleton) (fallback: ../node_modules/react/index.js)
var react_index_js_ = __webpack_require__(78156);
// EXTERNAL MODULE: ../node_modules/react-dom/client.js
var client = __webpack_require__(37634);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/notificationplugin.js
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */









/**
 * Toast close button class
 */
const TOAST_CLOSE_BUTTON_CLASS = 'jp-Notification-Toast-Close';
/**
 * Toast close button class right margin required due to custom hover effect
 */
const TOAST_CLOSE_BUTTON_MARGIN_CLASS = 'jp-Notification-Toast-Close-Margin';
/**
 * Maximal number of characters displayed in a notification.
 */
const MAX_MESSAGE_LENGTH = 140;
var notificationplugin_CommandIDs;
(function (CommandIDs) {
    /**
     * Dismiss a notification
     */
    CommandIDs.dismiss = 'apputils:dismiss-notification';
    /**
     * Display all notifications
     */
    CommandIDs.display = 'apputils:display-notifications';
    /**
     * Create a notification
     */
    CommandIDs.notify = 'apputils:notify';
    /**
     * Update a notification
     */
    CommandIDs.update = 'apputils:update-notification';
})(notificationplugin_CommandIDs || (notificationplugin_CommandIDs = {}));
/**
 * Half spacing between subitems in a status item.
 */
const HALF_SPACING = 4;
/**
 * Notification center view
 */
function NotificationCenter(props) {
    const { manager, onClose, trans } = props;
    // Markdown parsed notifications
    const [notifications, setNotifications] = react_index_js_.useState([]);
    // Load asynchronously react-toastify icons
    const [icons, setIcons] = react_index_js_.useState(null);
    react_index_js_.useEffect(() => {
        async function onChanged() {
            setNotifications(await Promise.all(manager.notifications.map(async (n) => {
                return Object.freeze({
                    ...n
                });
            })));
        }
        if (notifications.length !== manager.count) {
            void onChanged();
        }
        manager.changed.connect(onChanged);
        return () => {
            manager.changed.disconnect(onChanged);
        };
    }, [manager]);
    react_index_js_.useEffect(() => {
        Private.getIcons()
            .then(toastifyIcons => {
            setIcons(toastifyIcons);
        })
            .catch(r => {
            console.error(`Failed to get react-toastify icons:\n${r}`);
        });
    }, []);
    return (react_index_js_.createElement(ui_components_lib_index_js_.UseSignal, { signal: manager.changed }, () => (react_index_js_.createElement(react_index_js_.Fragment, null,
        react_index_js_.createElement("h2", { className: "jp-Notification-Header jp-Toolbar" },
            react_index_js_.createElement("span", { className: "jp-Toolbar-item" }, manager.count > 0
                ? trans._n('%1 notification', '%1 notifications', manager.count)
                : trans.__('No notifications')),
            react_index_js_.createElement("span", { className: "jp-Toolbar-item jp-Toolbar-spacer" }),
            react_index_js_.createElement(ui_components_lib_index_js_.ToolbarButtonComponent, { noFocusOnClick: false, onClick: () => {
                    manager.dismiss();
                }, icon: ui_components_lib_index_js_.deleteIcon, tooltip: trans.__('Dismiss all notifications'), enabled: manager.count > 0 }),
            react_index_js_.createElement(ui_components_lib_index_js_.ToolbarButtonComponent, { noFocusOnClick: false, onClick: onClose, icon: ui_components_lib_index_js_.closeIcon, tooltip: trans.__('Hide notifications') })),
        react_index_js_.createElement("ol", { className: "jp-Notification-List" }, notifications.map(notification => {
            var _a;
            const { id, message, type, options } = notification;
            const toastType = type === 'in-progress' ? 'default' : type;
            const closeNotification = () => {
                manager.dismiss(id);
            };
            const icon = type === 'default'
                ? null
                : type === 'in-progress'
                    ? (_a = icons === null || icons === void 0 ? void 0 : icons.spinner) !== null && _a !== void 0 ? _a : null
                    : icons && icons[type];
            return (react_index_js_.createElement("li", { className: "jp-Notification-List-Item", key: notification.id, onClick: event => {
                    // Stop propagation to avoid closing the popup on click
                    event.stopPropagation();
                } },
                react_index_js_.createElement("div", { className: `Toastify__toast Toastify__toast-theme--light Toastify__toast--${toastType} jp-Notification-Toast-${toastType}` },
                    react_index_js_.createElement("div", { className: "Toastify__toast-body" },
                        icon && (react_index_js_.createElement("div", { className: "Toastify__toast-icon" }, icon({ theme: 'light', type: toastType }))),
                        react_index_js_.createElement("div", null, Private.createContent(message, closeNotification, options.actions))),
                    react_index_js_.createElement(Private.CloseButton, { close: closeNotification, closeIcon: ui_components_lib_index_js_.deleteIcon.react, title: trans.__('Dismiss notification'), closeIconMargin: true }))));
        }))))));
}
/**
 * Status widget model
 */
class NotificationStatusModel extends ui_components_lib_index_js_.VDomModel {
    constructor(manager) {
        super();
        this.manager = manager;
        this._highlight = false;
        this._listOpened = false;
        this._doNotDisturbMode = false;
        this._count = manager.count;
        this.manager.changed.connect(this.onNotificationChanged, this);
    }
    /**
     * Number of notifications.
     */
    get count() {
        return this._count;
    }
    /**
     * Whether to silence all notifications or not.
     */
    get doNotDisturbMode() {
        return this._doNotDisturbMode;
    }
    set doNotDisturbMode(v) {
        this._doNotDisturbMode = v;
    }
    /**
     * Whether to highlight the status widget or not.
     */
    get highlight() {
        return this._highlight;
    }
    /**
     * Whether the popup is opened or not.
     */
    get listOpened() {
        return this._listOpened;
    }
    set listOpened(v) {
        this._listOpened = v;
        if (this._listOpened || this._highlight) {
            this._highlight = false;
        }
        this.stateChanged.emit();
    }
    onNotificationChanged(_, change) {
        // Set private attribute to trigger only once the signal emission
        this._count = this.manager.count;
        const { autoClose } = change.notification.options;
        const noToast = this.doNotDisturbMode ||
            (typeof autoClose === 'number' && autoClose <= 0);
        // Highlight if
        //   the list is not opened (the style change if list is opened due to clickedItem style in statusbar.)
        //   the change type is not removed
        //   the notification will be hidden
        if (!this._listOpened && change.type !== 'removed' && noToast) {
            this._highlight = true;
        }
        this.stateChanged.emit();
    }
}
/**
 * Status view
 */
function NotificationStatus(props) {
    return (react_index_js_.createElement(statusbar_lib_index_js_.GroupItem, { spacing: HALF_SPACING, onClick: () => {
            props.onClick();
        }, title: props.count > 0
            ? props.trans._n('%1 notification', '%1 notifications', props.count)
            : props.trans.__('No notifications') },
        react_index_js_.createElement(statusbar_lib_index_js_.TextItem, { className: "jp-Notification-Status-Text", source: `${props.count}` }),
        react_index_js_.createElement(ui_components_lib_index_js_.bellIcon.react, { top: '2px', stylesheet: 'statusBar' })));
}
/**
 * Add notification center and toast
 */
const notificationPlugin = {
    id: '@jupyterlab/apputils-extension:notification',
    description: 'Add the notification center and its status indicator.',
    autoStart: true,
    optional: [statusbar_lib_index_js_.IStatusBar, settingregistry_lib_index_js_.ISettingRegistry, translation_lib_index_js_.ITranslator],
    activate: (app, statusBar, settingRegistry, translator) => {
        Private.translator = translator !== null && translator !== void 0 ? translator : translation_lib_index_js_.nullTranslator;
        const trans = Private.translator.load('jupyterlab');
        const model = new NotificationStatusModel(lib_index_js_.Notification.manager);
        model.doNotDisturbMode = false;
        if (settingRegistry) {
            void Promise.all([
                settingRegistry.load(notificationPlugin.id),
                app.restored
            ]).then(([plugin]) => {
                const updateSettings = () => {
                    model.doNotDisturbMode = plugin.get('doNotDisturbMode')
                        .composite;
                };
                updateSettings();
                plugin.changed.connect(updateSettings);
            });
        }
        app.commands.addCommand(notificationplugin_CommandIDs.notify, {
            label: trans.__('Emit a notification'),
            caption: trans.__('Notification is described by {message: string, type?: string, options?: {autoClose?: number | false, actions: {label: string, commandId: string, args?: ReadOnlyJSONObject, caption?: string, className?: string}[], data?: ReadOnlyJSONValue}}.'),
            execute: args => {
                var _a;
                const { message, type } = args;
                const options = (_a = args.options) !== null && _a !== void 0 ? _a : {};
                return lib_index_js_.Notification.manager.notify(message, type !== null && type !== void 0 ? type : 'default', {
                    ...options,
                    actions: options.actions
                        ? options.actions.map((action) => {
                            return {
                                ...action,
                                callback: () => {
                                    app.commands
                                        .execute(action.commandId, action.args)
                                        .catch(r => {
                                        console.error(`Failed to executed '${action.commandId}':\n${r}`);
                                    });
                                }
                            };
                        })
                        : null
                });
            }
        });
        app.commands.addCommand(notificationplugin_CommandIDs.update, {
            label: trans.__('Update a notification'),
            caption: trans.__('Notification is described by {id: string, message: string, type?: string, options?: {autoClose?: number | false, actions: {label: string, commandId: string, args?: ReadOnlyJSONObject, caption?: string, className?: string}[], data?: ReadOnlyJSONValue}}.'),
            execute: args => {
                const { id, message, type, ...options } = args;
                return lib_index_js_.Notification.manager.update({
                    id,
                    message,
                    type: type !== null && type !== void 0 ? type : 'default',
                    ...options,
                    actions: options.actions
                        ? options.actions.map((action) => {
                            return {
                                ...action,
                                callback: () => {
                                    app.commands
                                        .execute(action.commandId, action.args)
                                        .catch(r => {
                                        console.error(`Failed to executed '${action.commandId}':\n${r}`);
                                    });
                                }
                            };
                        })
                        : null
                });
            }
        });
        app.commands.addCommand(notificationplugin_CommandIDs.dismiss, {
            label: trans.__('Dismiss a notification'),
            execute: args => {
                const { id } = args;
                lib_index_js_.Notification.manager.dismiss(id);
            }
        });
        let popup = null;
        model.listOpened = false;
        const notificationList = lib_index_js_.ReactWidget.create(react_index_js_.createElement(NotificationCenter, { manager: lib_index_js_.Notification.manager, onClose: () => {
                popup === null || popup === void 0 ? void 0 : popup.dispose();
            }, trans: trans }));
        notificationList.addClass('jp-Notification-Center');
        async function onNotification(manager, change) {
            var _a;
            if (model.doNotDisturbMode || (popup !== null && !popup.isDisposed)) {
                return;
            }
            const { message, type, options, id } = change.notification;
            if (typeof options.autoClose === 'number' && options.autoClose <= 0) {
                // If the notification is silent, bail early.
                return;
            }
            switch (change.type) {
                case 'added':
                    await Private.createToast(id, message, type, options);
                    break;
                case 'updated':
                    {
                        const toast = await Private.toast();
                        const actions = options.actions;
                        const autoClose = (_a = options.autoClose) !== null && _a !== void 0 ? _a : (actions && actions.length > 0 ? false : null);
                        if (toast.isActive(id)) {
                            // Update existing toast
                            const closeToast = () => {
                                // Dismiss the displayed toast
                                toast.dismiss(id);
                                // Dismiss the notification from the queue
                                manager.dismiss(id);
                            };
                            toast.update(id, {
                                type: type === 'in-progress' ? null : type,
                                isLoading: type === 'in-progress',
                                autoClose: autoClose,
                                render: Private.createContent(message, closeToast, options.actions)
                            });
                        }
                        else {
                            // Needs to recreate a closed toast
                            await Private.createToast(id, message, type, options);
                        }
                    }
                    break;
                case 'removed':
                    await Private.toast().then(t => {
                        t.dismiss(id);
                    });
                    break;
            }
        }
        lib_index_js_.Notification.manager.changed.connect(onNotification);
        const displayNotifications = () => {
            if (popup) {
                popup.dispose();
                popup = null;
            }
            else {
                popup = (0,statusbar_lib_index_js_.showPopup)({
                    body: notificationList,
                    anchor: notificationStatus,
                    align: 'right',
                    hasDynamicSize: true,
                    startHidden: true
                });
                // Dismiss all toasts when opening the notification center
                Private.toast()
                    .then(t => {
                    t.dismiss();
                })
                    .catch(r => {
                    console.error(`Failed to dismiss all toasts:\n${r}`);
                })
                    .finally(() => {
                    popup === null || popup === void 0 ? void 0 : popup.launch();
                    // Focus on the pop-up
                    notificationList.node.focus();
                    popup === null || popup === void 0 ? void 0 : popup.disposed.connect(() => {
                        model.listOpened = false;
                        popup = null;
                    });
                });
            }
            model.listOpened = popup !== null;
        };
        app.commands.addCommand(notificationplugin_CommandIDs.display, {
            label: trans.__('Show Notifications'),
            execute: displayNotifications
        });
        const notificationStatus = lib_index_js_.ReactWidget.create(react_index_js_.createElement(ui_components_lib_index_js_.UseSignal, { signal: model.stateChanged }, () => {
            if (model.highlight || (popup && !popup.isDisposed)) {
                notificationStatus.addClass('jp-mod-selected');
            }
            else {
                notificationStatus.removeClass('jp-mod-selected');
            }
            return (react_index_js_.createElement(NotificationStatus, { count: model.count, highlight: model.highlight, trans: trans, onClick: displayNotifications }));
        }));
        notificationStatus.addClass('jp-Notification-Status');
        if (statusBar) {
            statusBar.registerStatusItem(notificationPlugin.id, {
                item: notificationStatus,
                align: 'right',
                rank: -1
            });
        }
        else {
            notificationStatus.addClass('jp-ThemedContainer');
            // if the status bar is not available, position the notification
            // status in the bottom right corner of the page
            notificationStatus.node.style.position = 'fixed';
            notificationStatus.node.style.bottom = '0';
            // 10px is the default padding for the status bar
            notificationStatus.node.style.right = '10px';
            widgets_dist_index_es6_js_.Widget.attach(notificationStatus, document.body);
            notificationStatus.show();
        }
    }
};
var Private;
(function (Private) {
    /**
     * Translator object for private namespace
     */
    Private.translator = translation_lib_index_js_.nullTranslator;
    /**
     * Pointer to asynchronously loaded react-toastify
     */
    let toastify = null;
    function CloseButton(props) {
        var _a;
        return (react_index_js_.createElement("button", { className: `jp-Button jp-mod-minimal ${TOAST_CLOSE_BUTTON_CLASS}${props.closeIconMargin ? ` ${TOAST_CLOSE_BUTTON_MARGIN_CLASS}` : ''}`, title: (_a = props.title) !== null && _a !== void 0 ? _a : '', onClick: props.close },
            react_index_js_.createElement(props.closeIcon, { className: "jp-icon-hover", tag: "span" })));
    }
    Private.CloseButton = CloseButton;
    function ToastifyCloseButton(props) {
        const trans = Private.translator.load('jupyterlab');
        return (react_index_js_.createElement(CloseButton, { close: props.closeToast, closeIcon: ui_components_lib_index_js_.closeIcon.react, title: trans.__('Hide notification') }));
    }
    let waitForToastify = null;
    /**
     * Asynchronously load the toast container
     *
     * @returns The toast object
     */
    async function toast() {
        if (waitForToastify === null) {
            waitForToastify = new dist_index_js_.PromiseDelegate();
        }
        else {
            await waitForToastify.promise;
        }
        if (toastify === null) {
            toastify = await __webpack_require__.e(/* import() */ 53).then(__webpack_require__.t.bind(__webpack_require__, 60053, 23));
            const container = document.body.appendChild(document.createElement('div'));
            container.id = 'react-toastify-container';
            container.classList.add('jp-ThemedContainer');
            const root = (0,client/* createRoot */.s)(container);
            root.render(react_index_js_.createElement(toastify.ToastContainer, { draggable: false, closeOnClick: false, hideProgressBar: true, newestOnTop: true, pauseOnFocusLoss: true, pauseOnHover: true, position: "bottom-right", className: "jp-toastContainer", transition: toastify.Slide, closeButton: ToastifyCloseButton }));
            waitForToastify.resolve();
        }
        return toastify.toast;
    }
    Private.toast = toast;
    /**
     * react-toastify icons loader
     */
    async function getIcons() {
        if (toastify === null) {
            await toast();
        }
        return toastify.Icons;
    }
    Private.getIcons = getIcons;
    const displayType2Class = {
        accent: 'jp-mod-accept',
        link: 'jp-mod-link',
        warn: 'jp-mod-warn',
        default: ''
    };
    /**
     * Create a button with customized callback in a toast
     */
    function ToastButton({ action, closeToast }) {
        var _a, _b;
        const clickHandler = (event) => {
            action.callback(event);
            if (!event.defaultPrevented) {
                closeToast();
            }
        };
        const classes = [
            'jp-toast-button',
            displayType2Class[(_a = action.displayType) !== null && _a !== void 0 ? _a : 'default']
        ].join(' ');
        return (react_index_js_.createElement(ui_components_lib_index_js_.Button, { title: (_b = action.caption) !== null && _b !== void 0 ? _b : action.label, className: classes, onClick: clickHandler, small: true }, action.label));
    }
    /**
     * Helper function to construct the notification content
     *
     * @param message Message to print in the notification
     * @param closeHandler Function closing the notification
     * @param actions Toast actions
     */
    function createContent(message, closeHandler, actions) {
        var _a;
        const shortenMessage = message.length > MAX_MESSAGE_LENGTH
            ? message.slice(0, MAX_MESSAGE_LENGTH) + '…'
            : message;
        return (react_index_js_.createElement(react_index_js_.Fragment, null,
            react_index_js_.createElement("div", { className: "jp-toast-message" }, shortenMessage.split('\n').map((part, index) => (react_index_js_.createElement(react_index_js_.Fragment, { key: `part-${index}` },
                index > 0 ? react_index_js_.createElement("br", null) : null,
                part)))),
            ((_a = actions === null || actions === void 0 ? void 0 : actions.length) !== null && _a !== void 0 ? _a : 0) > 0 && (react_index_js_.createElement("div", { className: "jp-toast-buttonBar" },
                react_index_js_.createElement("div", { className: "jp-toast-spacer" }),
                actions.map((action, idx) => {
                    return (react_index_js_.createElement(ToastButton, { key: 'button-' + idx, action: action, closeToast: closeHandler }));
                })))));
    }
    Private.createContent = createContent;
    /**
     * Create a toast notification
     *
     * @param toastId Toast unique id
     * @param message Toast message
     * @param type Toast type
     * @param options Toast options
     * @returns Toast id
     */
    async function createToast(toastId, message, type, options = {}) {
        const { actions, autoClose, data } = options;
        const t = await toast();
        const toastOptions = {
            autoClose: autoClose !== null && autoClose !== void 0 ? autoClose : (actions && actions.length > 0 ? false : undefined),
            data: data,
            className: `jp-Notification-Toast-${type}`,
            toastId,
            type: type === 'in-progress' ? null : type,
            isLoading: type === 'in-progress'
        };
        return t(({ closeToast }) => createContent(message, () => {
            if (closeToast)
                closeToast();
            lib_index_js_.Notification.manager.dismiss(toastId);
        }, actions), toastOptions);
    }
    Private.createToast = createToast;
})(Private || (Private = {}));
//# sourceMappingURL=notificationplugin.js.map
// EXTERNAL MODULE: consume shared module (default) @lumino/algorithm@~2.0.3 (singleton) (fallback: ../node_modules/@lumino/algorithm/dist/index.es6.js)
var algorithm_dist_index_es6_js_ = __webpack_require__(56114);
// EXTERNAL MODULE: consume shared module (default) @lumino/commands@~2.3.2 (singleton) (fallback: ../node_modules/@lumino/commands/dist/index.es6.js)
var commands_dist_index_es6_js_ = __webpack_require__(35538);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/palette.js
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/







/**
 * The command IDs used by the apputils extension.
 */
var palette_CommandIDs;
(function (CommandIDs) {
    CommandIDs.activate = 'apputils:activate-command-palette';
})(palette_CommandIDs || (palette_CommandIDs = {}));
const PALETTE_PLUGIN_ID = '@jupyterlab/apputils-extension:palette';
/**
 * A thin wrapper around the `CommandPalette` class to conform with the
 * JupyterLab interface for the application-wide command palette.
 */
class Palette {
    /**
     * Create a palette instance.
     */
    constructor(palette, translator) {
        this.translator = translator || translation_lib_index_js_.nullTranslator;
        const trans = this.translator.load('jupyterlab');
        this._palette = palette;
        this._palette.title.label = '';
        this._palette.title.caption = trans.__('Command Palette');
    }
    /**
     * The placeholder text of the command palette's search input.
     */
    set placeholder(placeholder) {
        this._palette.inputNode.placeholder = placeholder;
    }
    get placeholder() {
        return this._palette.inputNode.placeholder;
    }
    /**
     * Activate the command palette for user input.
     */
    activate() {
        this._palette.activate();
    }
    /**
     * Add a command item to the command palette.
     *
     * @param options - The options for creating the command item.
     *
     * @returns A disposable that will remove the item from the palette.
     */
    addItem(options) {
        const item = this._palette.addItem(options);
        return new index_es6_js_.DisposableDelegate(() => {
            this._palette.removeItem(item);
        });
    }
}
/**
 * A namespace for `Palette` statics.
 */
(function (Palette) {
    /**
     * Activate the command palette.
     */
    function activate(app, translator, settingRegistry) {
        const { commands, shell } = app;
        const trans = translator.load('jupyterlab');
        const palette = palette_Private.createPalette(app, translator);
        const modalPalette = new lib_index_js_.ModalCommandPalette({ commandPalette: palette });
        let modal = false;
        palette.node.setAttribute('role', 'region');
        palette.node.setAttribute('aria-label', trans.__('Command Palette Section'));
        shell.add(palette, 'left', { rank: 300, type: 'Command Palette' });
        if (settingRegistry) {
            const loadSettings = settingRegistry.load(PALETTE_PLUGIN_ID);
            const updateSettings = (settings) => {
                const newModal = settings.get('modal').composite;
                if (modal && !newModal) {
                    palette.parent = null;
                    modalPalette.detach();
                    shell.add(palette, 'left', { rank: 300, type: 'Command Palette' });
                }
                else if (!modal && newModal) {
                    palette.parent = null;
                    modalPalette.palette = palette;
                    palette.show();
                    modalPalette.attach();
                }
                modal = newModal;
            };
            Promise.all([loadSettings, app.restored])
                .then(([settings]) => {
                updateSettings(settings);
                settings.changed.connect(settings => {
                    updateSettings(settings);
                });
            })
                .catch((reason) => {
                console.error(reason.message);
            });
        }
        // Show the current palette shortcut in its title.
        const updatePaletteTitle = () => {
            const binding = (0,algorithm_dist_index_es6_js_.find)(app.commands.keyBindings, b => b.command === palette_CommandIDs.activate);
            if (binding) {
                const ks = binding.keys.map(commands_dist_index_es6_js_.CommandRegistry.formatKeystroke).join(', ');
                palette.title.caption = trans.__('Commands (%1)', ks);
            }
            else {
                palette.title.caption = trans.__('Commands');
            }
        };
        updatePaletteTitle();
        app.commands.keyBindingChanged.connect(() => {
            updatePaletteTitle();
        });
        commands.addCommand(palette_CommandIDs.activate, {
            execute: () => {
                if (modal) {
                    modalPalette.activate();
                }
                else {
                    shell.activateById(palette.id);
                }
            },
            label: trans.__('Activate Command Palette')
        });
        palette.inputNode.placeholder = trans.__('SEARCH');
        return new Palette(palette, translator);
    }
    Palette.activate = activate;
    /**
     * Restore the command palette.
     */
    function restore(app, restorer, translator) {
        const palette = palette_Private.createPalette(app, translator);
        // Let the application restorer track the command palette for restoration of
        // application state (e.g. setting the command palette as the current side bar
        // widget).
        restorer.add(palette, 'command-palette');
    }
    Palette.restore = restore;
})(Palette || (Palette = {}));
/**
 * The namespace for module private data.
 */
var palette_Private;
(function (Private) {
    /**
     * The private command palette instance.
     */
    let palette;
    /**
     * Create the application-wide command palette.
     */
    function createPalette(app, translator) {
        if (!palette) {
            // use a renderer tweaked to use inline svg icons
            palette = new widgets_dist_index_es6_js_.CommandPalette({
                commands: app.commands,
                renderer: ui_components_lib_index_js_.CommandPaletteSvg.defaultRenderer
            });
            palette.id = 'command-palette';
            palette.title.icon = ui_components_lib_index_js_.paletteIcon;
            const trans = translator.load('jupyterlab');
            palette.title.label = trans.__('Commands');
        }
        return palette;
    }
    Private.createPalette = createPalette;
})(palette_Private || (palette_Private = {}));
//# sourceMappingURL=palette.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/settingconnector.js
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */



/**
 * A data connector for fetching settings.
 *
 * #### Notes
 * This connector adds a query parameter to the base services setting manager.
 */
class SettingConnector extends statedb_lib_index_js_.DataConnector {
    constructor(connector) {
        super();
        this._throttlers = Object.create(null);
        this._connector = connector;
    }
    /**
     * Fetch settings for a plugin.
     * @param id - The plugin ID
     *
     * #### Notes
     * The REST API requests are throttled at one request per plugin per 100ms.
     */
    fetch(id) {
        const throttlers = this._throttlers;
        if (!(id in throttlers)) {
            throttlers[id] = new dist_index_es6_js_.Throttler(() => this._connector.fetch(id), 100);
        }
        return throttlers[id].invoke();
    }
    async list(query = 'all') {
        const { isDisabled } = coreutils_lib_index_js_.PageConfig.Extension;
        const { ids, values } = await this._connector.list(query === 'ids' ? 'ids' : undefined);
        if (query === 'all') {
            return { ids, values };
        }
        if (query === 'ids') {
            return { ids };
        }
        return {
            ids: ids.filter(id => !isDisabled(id)),
            values: values.filter(({ id }) => !isDisabled(id))
        };
    }
    async save(id, raw) {
        await this._connector.save(id, raw);
    }
}
//# sourceMappingURL=settingconnector.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/settingsplugin.js
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/



/**
 * Provides the settings connector as a separate plugin to allow for alternative
 * implementations that may want to fetch settings from a different source or
 * endpoint.
 */
const settingsConnector = {
    id: '@jupyterlab/apputils-extension:settings-connector',
    description: 'Provides the settings connector.',
    autoStart: true,
    provides: settingregistry_lib_index_js_.ISettingConnector,
    activate: (app) => new SettingConnector(app.serviceManager.settings)
};
/**
 * The default setting registry provider.
 */
const settingsPlugin = {
    id: '@jupyterlab/apputils-extension:settings',
    autoStart: true,
    provides: settingregistry_lib_index_js_.ISettingRegistry,
    optional: [settingregistry_lib_index_js_.ISettingConnector],
    description: 'Provides the setting registry.',
    activate: async (app, settingsConnector) => {
        const { isDisabled } = coreutils_lib_index_js_.PageConfig.Extension;
        const connector = settingsConnector !== null && settingsConnector !== void 0 ? settingsConnector : new SettingConnector(app.serviceManager.settings);
        // On startup, check if a plugin is available in the application.
        // This helps avoid loading plugin files from other lab-based applications
        // that have placed their schemas next to the JupyterLab schemas. Different lab-based
        // applications might not have the same set of plugins loaded on the page.
        // As an example this helps prevent having new toolbar items added by another application
        // appear in JupyterLab as a side-effect when they are defined via the settings system.
        const registry = new settingregistry_lib_index_js_.SettingRegistry({
            connector,
            plugins: (await connector.list('active')).values.filter(value => app.hasPlugin(value.id))
        });
        // If there are plugins that have schemas that are not in the setting
        // registry after the application has restored, try to load them manually
        // because otherwise, its settings will never become available in the
        // setting registry.
        void app.restored.then(async () => {
            const plugins = await connector.list('ids');
            plugins.ids.forEach(async (id) => {
                if (!app.hasPlugin(id) || isDisabled(id) || id in registry.plugins) {
                    return;
                }
                try {
                    await registry.load(id);
                }
                catch (error) {
                    console.warn(`Settings failed to load for (${id})`, error);
                    if (!app.isPluginActivated(id)) {
                        console.warn(`If 'jupyter.lab.transform=true' in the plugin schema, this ` +
                            `may happen if {autoStart: false} in (${id}) or if it is ` +
                            `one of the deferredExtensions in page config.`);
                    }
                }
            });
        });
        return registry;
    }
};
//# sourceMappingURL=settingsplugin.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/statusbarplugin.js
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/





/**
 * A plugin that provides a kernel status item to the status bar.
 */
const kernelStatus = {
    id: '@jupyterlab/apputils-extension:kernel-status',
    description: 'Provides the kernel status indicator model.',
    autoStart: true,
    requires: [statusbar_lib_index_js_.IStatusBar],
    provides: lib_index_js_.IKernelStatusModel,
    optional: [lib_index_js_.ISessionContextDialogs, translation_lib_index_js_.ITranslator, index_js_.ILabShell],
    activate: (app, statusBar, sessionDialogs_, translator_, labShell) => {
        const translator = translator_ !== null && translator_ !== void 0 ? translator_ : translation_lib_index_js_.nullTranslator;
        const sessionDialogs = sessionDialogs_ !== null && sessionDialogs_ !== void 0 ? sessionDialogs_ : new lib_index_js_.SessionContextDialogs({ translator });
        // When the status item is clicked, launch the kernel
        // selection dialog for the current session.
        const changeKernel = async () => {
            if (!item.model.sessionContext) {
                return;
            }
            await sessionDialogs.selectKernel(item.model.sessionContext);
        };
        const changeKernelOnKeyDown = async (event) => {
            if (event.key === 'Enter' ||
                event.key === 'Spacebar' ||
                event.key === ' ') {
                event.preventDefault();
                event.stopPropagation();
                return changeKernel();
            }
        };
        // Create the status item.
        const item = new lib_index_js_.KernelStatus({ onClick: changeKernel, onKeyDown: changeKernelOnKeyDown }, translator);
        const providers = new Set();
        const addSessionProvider = (provider) => {
            providers.add(provider);
            if (app.shell.currentWidget) {
                updateSession(app.shell, {
                    newValue: app.shell.currentWidget,
                    oldValue: null
                });
            }
        };
        function updateSession(shell, changes) {
            var _a;
            const { oldValue, newValue } = changes;
            // Clean up after the old value if it exists,
            // listen for changes to the title of the activity
            if (oldValue) {
                oldValue.title.changed.disconnect(onTitleChanged);
            }
            item.model.sessionContext =
                (_a = [...providers]
                    .map(provider => provider(changes.newValue))
                    .filter(session => session !== null)[0]) !== null && _a !== void 0 ? _a : null;
            if (newValue && item.model.sessionContext) {
                onTitleChanged(newValue.title);
                newValue.title.changed.connect(onTitleChanged);
            }
        }
        // When the title of the active widget changes, update the label
        // of the hover text.
        const onTitleChanged = (title) => {
            item.model.activityName = title.label;
        };
        if (labShell) {
            labShell.currentChanged.connect(updateSession);
        }
        statusBar.registerStatusItem(kernelStatus.id, {
            priority: 1,
            item,
            align: 'left',
            rank: 1,
            isActive: () => item.model.sessionContext !== null
        });
        return { addSessionProvider };
    }
};
/*
 * A plugin providing running terminals and sessions information
 * to the status bar.
 */
const runningSessionsStatus = {
    id: '@jupyterlab/apputils-extension:running-sessions-status',
    description: 'Add the running sessions and terminals status bar item.',
    autoStart: true,
    requires: [statusbar_lib_index_js_.IStatusBar, translation_lib_index_js_.ITranslator],
    optional: [settingregistry_lib_index_js_.ISettingRegistry],
    activate: (app, statusBar, translator, settingRegistry) => {
        const createStatusItem = (options) => {
            const item = new lib_index_js_.RunningSessions({
                onClick: () => app.shell.activateById('jp-running-sessions'),
                onKeyDown: (event) => {
                    if (event.key === 'Enter' ||
                        event.key === 'Spacebar' ||
                        event.key === ' ') {
                        event.preventDefault();
                        event.stopPropagation();
                        app.shell.activateById('jp-running-sessions');
                    }
                },
                serviceManager: app.serviceManager,
                translator,
                ...options
            });
            item.model.sessions = Array.from(app.serviceManager.sessions.running()).length;
            item.model.terminals = Array.from(app.serviceManager.terminals.running()).length;
            return item;
        };
        const registerItem = (options) => {
            const item = createStatusItem(options);
            return statusBar.registerStatusItem(runningSessionsStatus.id, {
                item,
                align: 'left',
                rank: 0
            });
        };
        if (settingRegistry) {
            let disposable;
            const onSettingsUpdated = (kernelSettings, terminalsSettings) => {
                var _a, _b;
                const showTerminalsMap = {
                    'if-any': undefined,
                    never: false,
                    always: true
                };
                const showKernels = (_a = kernelSettings === null || kernelSettings === void 0 ? void 0 : kernelSettings.get('showStatusBarItem').composite) !== null && _a !== void 0 ? _a : true;
                const showTerminals = showTerminalsMap[(_b = terminalsSettings === null || terminalsSettings === void 0 ? void 0 : terminalsSettings.get('showStatusBarItem').composite) !== null && _b !== void 0 ? _b : 'if-any'];
                disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                if (showKernels || showTerminals !== false) {
                    disposable = registerItem({
                        showKernels,
                        showTerminals
                    });
                }
            };
            const kernelsPluginId = '@jupyterlab/apputils-extension:kernels-settings';
            const terminalPluginId = '@jupyterlab/terminal-extension:plugin';
            void Promise.all([
                // Settings may be missing if the respective plugins are not enabled/included.
                kernelsPluginId in settingRegistry.plugins
                    ? settingRegistry.load(kernelsPluginId).catch(() => undefined)
                    : Promise.resolve(undefined),
                terminalPluginId in settingRegistry.plugins
                    ? settingRegistry.load(terminalPluginId).catch(() => undefined)
                    : Promise.resolve(undefined)
            ]).then(([kernelSettings, terminalSettings]) => {
                onSettingsUpdated(kernelSettings, terminalSettings);
                if (kernelSettings) {
                    kernelSettings.changed.connect(settings => {
                        kernelSettings = settings;
                        onSettingsUpdated(kernelSettings, terminalSettings);
                    });
                }
                if (terminalSettings) {
                    terminalSettings.changed.connect(settings => {
                        terminalSettings = settings;
                        onSettingsUpdated(kernelSettings, terminalSettings);
                    });
                }
            });
        }
        else {
            registerItem({
                showKernels: true
            });
        }
    }
};
//# sourceMappingURL=statusbarplugin.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/subshell-settings.js
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*
 * A plugin loading kernel subshell settings.
 */
const subshellsSettings = {
    id: '@jupyterlab/apputils-extension:subshell-settings',
    description: 'Kernel subshell settings.',
    autoStart: true,
    requires: [],
    optional: [settingregistry_lib_index_js_.ISettingRegistry],
    activate: (app, settingRegistry) => {
        if (settingRegistry) {
            app.started
                .then(async () => {
                const subshellsSettings = await settingRegistry.load('@jupyterlab/apputils-extension:kernels-settings');
                const commsOverSubshells = subshellsSettings.get('commsOverSubshells')
                    .composite;
                app.serviceManager.kernels.commsOverSubshells = commsOverSubshells;
                subshellsSettings.changed.connect(() => {
                    const commsOverSubshells = subshellsSettings.get('commsOverSubshells').composite;
                    app.serviceManager.kernels.commsOverSubshells = commsOverSubshells;
                });
            })
                .catch(reason => {
                console.error('Fail to load settings for the subshells.');
                console.error(reason);
            });
        }
    }
};
//# sourceMappingURL=subshell-settings.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/style/scrollbar.raw.css
const scrollbar_raw_namespaceObject = "/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n/*\n * Webkit scrollbar styling.\n * Separate file which is dynamically loaded based on user/theme settings.\n */\n\n/* use standard opaque scrollbars for most nodes */\n\n::-webkit-scrollbar,\n::-webkit-scrollbar-corner {\n  background: var(--jp-scrollbar-background-color);\n}\n\n::-webkit-scrollbar-thumb {\n  background: rgb(var(--jp-scrollbar-thumb-color));\n  border: var(--jp-scrollbar-thumb-margin) solid transparent;\n  background-clip: content-box;\n  border-radius: var(--jp-scrollbar-thumb-radius);\n}\n\n::-webkit-scrollbar-track:horizontal {\n  border-left: var(--jp-scrollbar-endpad) solid\n    var(--jp-scrollbar-background-color);\n  border-right: var(--jp-scrollbar-endpad) solid\n    var(--jp-scrollbar-background-color);\n}\n\n::-webkit-scrollbar-track:vertical {\n  border-top: var(--jp-scrollbar-endpad) solid\n    var(--jp-scrollbar-background-color);\n  border-bottom: var(--jp-scrollbar-endpad) solid\n    var(--jp-scrollbar-background-color);\n}\n\n/* for code nodes, use a transparent style of scrollbar */\n\n.CodeMirror-hscrollbar::-webkit-scrollbar,\n.CodeMirror-vscrollbar::-webkit-scrollbar,\n.CodeMirror-hscrollbar::-webkit-scrollbar-corner,\n.CodeMirror-vscrollbar::-webkit-scrollbar-corner {\n  background-color: transparent;\n}\n\n.CodeMirror-hscrollbar::-webkit-scrollbar-thumb,\n.CodeMirror-vscrollbar::-webkit-scrollbar-thumb {\n  background: rgba(var(--jp-scrollbar-thumb-color), 0.5);\n  border: var(--jp-scrollbar-thumb-margin) solid transparent;\n  background-clip: content-box;\n  border-radius: var(--jp-scrollbar-thumb-radius);\n}\n\n.CodeMirror-hscrollbar::-webkit-scrollbar-track:horizontal {\n  border-left: var(--jp-scrollbar-endpad) solid transparent;\n  border-right: var(--jp-scrollbar-endpad) solid transparent;\n}\n\n.CodeMirror-vscrollbar::-webkit-scrollbar-track:vertical {\n  border-top: var(--jp-scrollbar-endpad) solid transparent;\n  border-bottom: var(--jp-scrollbar-endpad) solid transparent;\n}\n";
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/themesplugins.js
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/







var themesplugins_CommandIDs;
(function (CommandIDs) {
    CommandIDs.changeTheme = 'apputils:change-theme';
    CommandIDs.changePreferredLightTheme = 'apputils:change-light-theme';
    CommandIDs.changePreferredDarkTheme = 'apputils:change-dark-theme';
    CommandIDs.toggleAdaptiveTheme = 'apputils:adaptive-theme';
    CommandIDs.themeScrollbars = 'apputils:theme-scrollbars';
    CommandIDs.changeFont = 'apputils:change-font';
    CommandIDs.incrFontSize = 'apputils:incr-font-size';
    CommandIDs.decrFontSize = 'apputils:decr-font-size';
})(themesplugins_CommandIDs || (themesplugins_CommandIDs = {}));
function createStyleSheet(text) {
    const style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.appendChild(document.createTextNode(text));
    return style;
}
/**
 * The default theme manager provider.
 */
const themesPlugin = {
    id: '@jupyterlab/apputils-extension:themes',
    description: 'Provides the theme manager.',
    requires: [settingregistry_lib_index_js_.ISettingRegistry, index_js_.JupyterFrontEnd.IPaths, translation_lib_index_js_.ITranslator],
    optional: [lib_index_js_.ISplashScreen],
    activate: (app, settings, paths, translator, splash) => {
        const trans = translator.load('jupyterlab');
        const host = app.shell;
        const commands = app.commands;
        const url = coreutils_lib_index_js_.URLExt.join(coreutils_lib_index_js_.PageConfig.getBaseUrl(), paths.urls.themes);
        const key = themesPlugin.id;
        const manager = new lib_index_js_.ThemeManager({
            key,
            host,
            settings,
            splash: splash !== null && splash !== void 0 ? splash : undefined,
            url
        });
        let scrollbarsStyleElement = null;
        // Keep a synchronously set reference to the current theme,
        // since the asynchronous setting of the theme in `changeTheme`
        // can lead to an incorrect toggle on the currently used theme.
        let currentTheme;
        manager.themeChanged.connect((sender, args) => {
            // Set data attributes on the application shell for the current theme.
            currentTheme = args.newValue;
            document.body.dataset.jpThemeLight = String(manager.isLight(currentTheme));
            document.body.dataset.jpThemeName = currentTheme;
            document.body.style.colorScheme = manager.isLight(currentTheme)
                ? 'light'
                : 'dark';
            if (document.body.dataset.jpThemeScrollbars !==
                String(manager.themeScrollbars(currentTheme))) {
                document.body.dataset.jpThemeScrollbars = String(manager.themeScrollbars(currentTheme));
                if (manager.themeScrollbars(currentTheme)) {
                    if (!scrollbarsStyleElement) {
                        scrollbarsStyleElement = createStyleSheet(scrollbar_raw_namespaceObject);
                    }
                    if (!scrollbarsStyleElement.parentElement) {
                        document.body.appendChild(scrollbarsStyleElement);
                    }
                }
                else {
                    if (scrollbarsStyleElement && scrollbarsStyleElement.parentElement) {
                        scrollbarsStyleElement.parentElement.removeChild(scrollbarsStyleElement);
                    }
                }
            }
            commands.notifyCommandChanged(themesplugins_CommandIDs.changeTheme);
        });
        commands.addCommand(themesplugins_CommandIDs.changeTheme, {
            label: args => {
                if (args.theme === undefined) {
                    return trans.__('Switch to the provided `theme`.');
                }
                const theme = args['theme'];
                const displayName = manager.getDisplayName(theme);
                return args['isPalette']
                    ? trans.__('Use Theme: %1', displayName)
                    : displayName;
            },
            isToggled: args => args['theme'] === currentTheme,
            execute: args => {
                const theme = args['theme'];
                if (theme === manager.theme) {
                    return;
                }
                // Disable adaptive theme if users decide to change the theme when adaptive theme is on
                if (manager.isToggledAdaptiveTheme()) {
                    return manager.toggleAdaptiveTheme();
                }
                return manager.setTheme(theme);
            }
        });
        commands.addCommand(themesplugins_CommandIDs.changePreferredLightTheme, {
            label: args => {
                if (args.theme === undefined) {
                    return trans.__('Switch to the provided light `theme`.');
                }
                const theme = args['theme'];
                const displayName = manager.getDisplayName(theme);
                return args['isPalette']
                    ? trans.__('Set Preferred Light Theme: %1', displayName)
                    : displayName;
            },
            isToggled: args => args['theme'] === manager.preferredLightTheme,
            execute: args => {
                const theme = args['theme'];
                if (theme === manager.preferredLightTheme) {
                    return;
                }
                return manager.setPreferredLightTheme(theme);
            }
        });
        commands.addCommand(themesplugins_CommandIDs.changePreferredDarkTheme, {
            label: args => {
                if (args.theme === undefined) {
                    return trans.__('Switch to the provided dark `theme`.');
                }
                const theme = args['theme'];
                const displayName = manager.getDisplayName(theme);
                return args['isPalette']
                    ? trans.__('Set Preferred Dark Theme: %1', displayName)
                    : displayName;
            },
            isToggled: args => args['theme'] === manager.preferredDarkTheme,
            execute: args => {
                const theme = args['theme'];
                if (theme === manager.preferredDarkTheme) {
                    return;
                }
                return manager.setPreferredDarkTheme(theme);
            }
        });
        commands.addCommand(themesplugins_CommandIDs.toggleAdaptiveTheme, {
            // Avoid lengthy option text in menu
            label: args => args['isPalette']
                ? trans.__('Synchronize Styling Theme with System Settings')
                : trans.__('Synchronize with System Settings'),
            isToggled: () => manager.isToggledAdaptiveTheme(),
            execute: () => {
                manager.toggleAdaptiveTheme().catch(console.warn);
            }
        });
        commands.addCommand(themesplugins_CommandIDs.themeScrollbars, {
            label: trans.__('Theme Scrollbars'),
            isToggled: () => manager.isToggledThemeScrollbars(),
            execute: () => manager.toggleThemeScrollbars()
        });
        commands.addCommand(themesplugins_CommandIDs.changeFont, {
            label: args => args['enabled'] ? `${args['font']}` : trans.__('waiting for fonts'),
            isEnabled: args => args['enabled'],
            isToggled: args => manager.getCSS(args['key']) === args['font'],
            execute: args => manager.setCSSOverride(args['key'], args['font'])
        });
        commands.addCommand(themesplugins_CommandIDs.incrFontSize, {
            label: args => {
                switch (args.key) {
                    case 'code-font-size':
                        return trans.__('Increase Code Font Size');
                    case 'content-font-size1':
                        return trans.__('Increase Content Font Size');
                    case 'ui-font-size1':
                        return trans.__('Increase UI Font Size');
                    default:
                        return trans.__('Increase Font Size');
                }
            },
            execute: args => manager.incrFontSize(args['key'])
        });
        commands.addCommand(themesplugins_CommandIDs.decrFontSize, {
            label: args => {
                switch (args.key) {
                    case 'code-font-size':
                        return trans.__('Decrease Code Font Size');
                    case 'content-font-size1':
                        return trans.__('Decrease Content Font Size');
                    case 'ui-font-size1':
                        return trans.__('Decrease UI Font Size');
                    default:
                        return trans.__('Decrease Font Size');
                }
            },
            execute: args => manager.decrFontSize(args['key'])
        });
        return manager;
    },
    autoStart: true,
    provides: lib_index_js_.IThemeManager
};
/**
 * The default theme manager's UI command palette and main menu functionality.
 *
 * #### Notes
 * This plugin loads separately from the theme manager plugin in order to
 * prevent blocking of the theme manager while it waits for the command palette
 * and main menu to become available.
 */
const themesPaletteMenuPlugin = {
    id: '@jupyterlab/apputils-extension:themes-palette-menu',
    description: 'Adds theme commands to the menu and the command palette.',
    requires: [lib_index_js_.IThemeManager, translation_lib_index_js_.ITranslator],
    optional: [lib_index_js_.ICommandPalette, mainmenu_lib_index_js_.IMainMenu],
    activate: (app, manager, translator, palette, mainMenu) => {
        const trans = translator.load('jupyterlab');
        // If we have a main menu, add the theme manager to the settings menu.
        if (mainMenu) {
            void app.restored.then(() => {
                var _a;
                const isPalette = false;
                const themeMenu = (_a = mainMenu.settingsMenu.items.find(item => {
                    var _a;
                    return item.type === 'submenu' &&
                        ((_a = item.submenu) === null || _a === void 0 ? void 0 : _a.id) === 'jp-mainmenu-settings-apputilstheme';
                })) === null || _a === void 0 ? void 0 : _a.submenu;
                // choose a theme
                if (themeMenu) {
                    manager.themes.forEach((theme, index) => {
                        themeMenu.insertItem(index, {
                            command: themesplugins_CommandIDs.changeTheme,
                            args: { isPalette, theme }
                        });
                    });
                }
            });
        }
        // If we have a command palette, add theme switching options to it.
        if (palette) {
            void app.restored.then(() => {
                const category = trans.__('Theme');
                const command = themesplugins_CommandIDs.changeTheme;
                const isPalette = true;
                // choose a theme
                manager.themes.forEach(theme => {
                    palette.addItem({ command, args: { isPalette, theme }, category });
                });
                // choose preferred light theme
                manager.themes.forEach(theme => {
                    palette.addItem({
                        command: themesplugins_CommandIDs.changePreferredLightTheme,
                        args: { isPalette, theme },
                        category
                    });
                });
                // choose preferred dark theme
                manager.themes.forEach(theme => {
                    palette.addItem({
                        command: themesplugins_CommandIDs.changePreferredDarkTheme,
                        args: { isPalette, theme },
                        category
                    });
                });
                // toggle adaptive theme
                palette.addItem({
                    command: themesplugins_CommandIDs.toggleAdaptiveTheme,
                    args: { isPalette },
                    category
                });
                // toggle scrollbar theming
                palette.addItem({ command: themesplugins_CommandIDs.themeScrollbars, category });
                // increase/decrease code font size
                palette.addItem({
                    command: themesplugins_CommandIDs.incrFontSize,
                    args: {
                        key: 'code-font-size'
                    },
                    category
                });
                palette.addItem({
                    command: themesplugins_CommandIDs.decrFontSize,
                    args: {
                        key: 'code-font-size'
                    },
                    category
                });
                // increase/decrease content font size
                palette.addItem({
                    command: themesplugins_CommandIDs.incrFontSize,
                    args: {
                        key: 'content-font-size1'
                    },
                    category
                });
                palette.addItem({
                    command: themesplugins_CommandIDs.decrFontSize,
                    args: {
                        key: 'content-font-size1'
                    },
                    category
                });
                // increase/decrease ui font size
                palette.addItem({
                    command: themesplugins_CommandIDs.incrFontSize,
                    args: {
                        key: 'ui-font-size1'
                    },
                    category
                });
                palette.addItem({
                    command: themesplugins_CommandIDs.decrFontSize,
                    args: {
                        key: 'ui-font-size1'
                    },
                    category
                });
            });
        }
    },
    autoStart: true
};
//# sourceMappingURL=themesplugins.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/toolbarregistryplugin.js
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/**
 * The default toolbar registry.
 */
const toolbarRegistry = {
    id: '@jupyterlab/apputils-extension:toolbar-registry',
    description: 'Provides toolbar items registry.',
    autoStart: true,
    provides: lib_index_js_.IToolbarWidgetRegistry,
    activate: (app) => {
        const registry = new lib_index_js_.ToolbarWidgetRegistry({
            defaultFactory: (0,lib_index_js_.createDefaultFactory)(app.commands)
        });
        return registry;
    }
};
//# sourceMappingURL=toolbarregistryplugin.js.map
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/docregistry@~4.4.3 (strict) (fallback: ../node_modules/@jupyterlab/docregistry/lib/index.js)
var docregistry_lib_index_js_ = __webpack_require__(74886);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/workspaces@^4.4.3 (strict) (fallback: ../node_modules/@jupyterlab/workspaces/lib/index.js)
var workspaces_lib_index_js_ = __webpack_require__(1229);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/workspacesplugin.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







const WORKSPACE_NAME = 'jupyterlab-workspace';
const WORKSPACE_EXT = '.' + WORKSPACE_NAME;
const LAST_SAVE_ID = 'workspace-ui:lastSave';
const ICON_NAME = 'jp-JupyterIcon';
/**
 * The workspace MIME renderer.
 */
const workspacesPlugin = {
    id: '@jupyterlab/apputils-extension:workspaces',
    description: 'Add workspace file type.',
    autoStart: true,
    requires: [statedb_lib_index_js_.IStateDB, translation_lib_index_js_.ITranslator, index_js_.JupyterFrontEnd.IPaths],
    optional: [index_js_.IRouter, workspaces_lib_index_js_.IWorkspaceCommands],
    activate: (app, state, translator, paths, router, workspaceCommands) => {
        // The workspace factory creates dummy widgets to load a new workspace.
        const factory = new workspacesplugin_Private.WorkspaceFactory({
            workspaces: app.serviceManager.workspaces,
            state,
            translator,
            open: async (id) => {
                if (workspaceCommands) {
                    await app.commands.execute(workspaceCommands.open, { workspace: id });
                }
                else {
                    const workspacesBase = coreutils_lib_index_js_.URLExt.join(paths.urls.app, 'workspaces');
                    const url = coreutils_lib_index_js_.URLExt.join(workspacesBase, id);
                    if (!url.startsWith(workspacesBase)) {
                        throw new Error('Can only be used for workspaces');
                    }
                    if (router) {
                        router.navigate(url, { hard: true });
                    }
                    else {
                        document.location.href = url;
                    }
                }
            }
        });
        const trans = translator.load('jupyterlab');
        app.docRegistry.addFileType({
            name: WORKSPACE_NAME,
            contentType: 'file',
            fileFormat: 'text',
            displayName: trans.__('JupyterLab Workspace File'),
            extensions: [WORKSPACE_EXT],
            mimeTypes: ['text/json'],
            iconClass: ICON_NAME
        });
        app.docRegistry.addWidgetFactory(factory);
    }
};
var workspacesplugin_Private;
(function (Private) {
    /**
     * This widget factory is used to handle double click on workspace
     */
    class WorkspaceFactory extends docregistry_lib_index_js_.ABCWidgetFactory {
        /**
         * Construct a widget factory that uploads a workspace and navigates to it.
         *
         * @param options - The instantiation options for a `WorkspaceFactory`.
         */
        constructor(options) {
            const trans = (options.translator || translation_lib_index_js_.nullTranslator).load('jupyterlab');
            super({
                name: 'Workspace loader',
                label: trans.__('Workspace loader'),
                fileTypes: [WORKSPACE_NAME],
                defaultFor: [WORKSPACE_NAME],
                readOnly: true
            });
            this._state = options.state;
            this._workspaces = options.workspaces;
            this._open = options.open;
        }
        /**
         * Loads the workspace into load, and jump to it
         * @param context This is used to query the workspace content
         */
        createNewWidget(context) {
            // Save a file's contents as a workspace and navigate to that workspace.
            void context.ready.then(async () => {
                const file = context.model;
                const workspace = file.toJSON();
                const path = context.path;
                const id = workspace.metadata.id;
                // Save the file contents as a workspace.
                await this._workspaces.save(id, workspace);
                // Save last save location for the save command.
                await this._state.save(LAST_SAVE_ID, path);
                // Navigate to new workspace.
                await this._open(id);
            });
            return dummyWidget(context);
        }
    }
    Private.WorkspaceFactory = WorkspaceFactory;
    /**
     * Returns a dummy widget with disposed content that doesn't render in the UI.
     *
     * @param context - The file context.
     */
    function dummyWidget(context) {
        const widget = new docregistry_lib_index_js_.DocumentWidget({ content: new widgets_dist_index_es6_js_.Widget(), context });
        widget.content.dispose();
        return widget;
    }
})(workspacesplugin_Private || (workspacesplugin_Private = {}));
//# sourceMappingURL=workspacesplugin.js.map
// EXTERNAL MODULE: consume shared module (default) @lumino/domutils@~2.0.3 (singleton) (fallback: ../node_modules/@lumino/domutils/dist/index.es6.js)
var domutils_dist_index_es6_js_ = __webpack_require__(23738);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/shortcuts.js
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */




/**
 * The class name for each row of ContextShortcutTable
 */
const SHORTCUT_TABLE_ROW_CLASS = 'jp-ContextualShortcut-TableRow';
/**
 * The class name for the last row of ContextShortcutTable
 */
const SHORTCUT_TABLE_LAST_ROW_CLASS = 'jp-ContextualShortcut-TableLastRow';
/**
 * The class name for each item of ContextShortcutTable
 */
const SHORTCUT_TABLE_ITEM_CLASS = 'jp-ContextualShortcut-TableItem';
/**
 * The class name for each button-like symbol representing a key used in a shortcut in the ContextShortcutTable
 */
const SHORTCUT_KEY_CLASS = 'jp-ContextualShortcut-Key';
function displayShortcuts(options) {
    const { commands, trans, activeElement } = options;
    const elt = activeElement !== null && activeElement !== void 0 ? activeElement : document.activeElement;
    /**
     * Find the distance from the target node to the first matching node.
     *
     * Based on Lumino private function commands.Private.targetDistance
     * This traverses the DOM path from `elt` to the root
     * computes the distance from `elt` to the first node which matches
     * the CSS selector. If no match is found, `-1` is returned.
     *
     * It also stops traversal if the `data-lm-suppress-shortcuts` or
     * `data-p-suppress-shortcuts` attributes are found.
     */
    function formatKeys(keys) {
        const topContainer = [];
        keys.forEach((key, index) => {
            const container = [];
            key.split(' ').forEach((ch, chIndex) => {
                container.push(react_index_js_.createElement("span", { className: SHORTCUT_KEY_CLASS, key: `ch-${chIndex}` },
                    react_index_js_.createElement("kbd", null, ch)), react_index_js_.createElement(react_index_js_.Fragment, { key: `fragment-${chIndex}` }, " + "));
            });
            topContainer.push(react_index_js_.createElement("span", { key: `key-${index}` }, container.slice(0, -1)), react_index_js_.createElement(react_index_js_.Fragment, { key: `fragment-${index}` }, " + "));
        });
        return react_index_js_.createElement("span", null, topContainer.slice(0, -1));
    }
    function capitalizeString(str) {
        const capitalizedStr = str.charAt(0).toUpperCase() + str.slice(1);
        return capitalizedStr;
    }
    function formatLabel(b) {
        const label = commands.label(b.command);
        const commandID = b.command.split(':')[1];
        const automaticLabel = commandID.split('-');
        let capitalizedLabel = '';
        for (let i = 0; i < automaticLabel.length; i++) {
            const str = capitalizeString(automaticLabel[i]);
            capitalizedLabel = capitalizedLabel + ' ' + str;
        }
        if (label.length > 0) {
            return label;
        }
        else {
            return capitalizedLabel;
        }
    }
    function matchDistance(selector, elt) {
        let targ = elt;
        for (let dist = 0; targ !== null && targ !== targ.parentElement; targ = targ.parentElement, ++dist) {
            if (targ.hasAttribute('data-lm-suppress-shortcuts')) {
                return -1;
            }
            if (targ.matches(selector)) {
                return dist;
            }
        }
        return -1;
    }
    // Find active keybindings for target element
    const activeBindings = new Map();
    for (let i = 0; i < commands.keyBindings.length; i++) {
        const kb = commands.keyBindings[i];
        let distance = matchDistance(kb.selector, elt);
        if (distance < 0) {
            continue;
        }
        let formatted = commands_dist_index_es6_js_.CommandRegistry.formatKeystroke(kb.keys);
        if (activeBindings.has(formatted)) {
            let oldBinding = activeBindings.get(formatted);
            // if the existing binding takes precedence, ignore this binding by continuing
            if (oldBinding[0] < distance ||
                (oldBinding[0] === distance &&
                    domutils_dist_index_es6_js_.Selector.calculateSpecificity(oldBinding[1].selector) >
                        domutils_dist_index_es6_js_.Selector.calculateSpecificity(kb.selector))) {
                continue;
            }
        }
        activeBindings.set(formatted, [distance, kb]);
    }
    // Group shortcuts by distance
    let maxDistance = -1;
    const groupedBindings = new Map();
    for (let [distance, binding] of activeBindings.values()) {
        maxDistance = Math.max(distance, maxDistance);
        if (!groupedBindings.has(distance)) {
            groupedBindings.set(distance, []);
        }
        groupedBindings.get(distance).push(binding);
    }
    // Display shortcuts by group
    const bindingTable = [];
    for (let d = 0; d <= maxDistance; d++) {
        if (groupedBindings.has(d)) {
            bindingTable.push(groupedBindings.get(d).map(b => (react_index_js_.createElement("tr", { className: SHORTCUT_TABLE_ROW_CLASS, key: `${b.command}-${b.keys.join('-').replace(' ', '_')}` },
                react_index_js_.createElement("td", { className: SHORTCUT_TABLE_ITEM_CLASS }, formatLabel(b)),
                react_index_js_.createElement("td", { className: SHORTCUT_TABLE_ITEM_CLASS }, formatKeys([...b.keys]))))));
            bindingTable.push(react_index_js_.createElement("tr", { className: SHORTCUT_TABLE_LAST_ROW_CLASS, key: `group-${d}-last` }));
        }
    }
    const body = (react_index_js_.createElement("table", null,
        react_index_js_.createElement("tbody", null, bindingTable)));
    return (0,lib_index_js_.showDialog)({
        title: trans.__('Keyboard Shortcuts'),
        body,
        buttons: [
            lib_index_js_.Dialog.cancelButton({
                label: trans.__('Close')
            })
        ]
    });
}
//# sourceMappingURL=shortcuts.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/lib/index.js
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
/**
 * @packageDocumentation
 * @module apputils-extension
 */





















/**
 * The interval in milliseconds before recover options appear during splash.
 */
const SPLASH_RECOVER_TIMEOUT = 12000;
/**
 * The command IDs used by the apputils plugin.
 */
var lib_CommandIDs;
(function (CommandIDs) {
    CommandIDs.loadState = 'apputils:load-statedb';
    CommandIDs.print = 'apputils:print';
    CommandIDs.reset = 'apputils:reset';
    CommandIDs.resetOnLoad = 'apputils:reset-on-load';
    CommandIDs.runFirstEnabled = 'apputils:run-first-enabled';
    CommandIDs.runAllEnabled = 'apputils:run-all-enabled';
    CommandIDs.toggleHeader = 'apputils:toggle-header';
    CommandIDs.displayShortcuts = 'apputils:display-shortcuts';
})(lib_CommandIDs || (lib_CommandIDs = {}));
/**
 * The default command palette extension.
 */
const palette = {
    id: '@jupyterlab/apputils-extension:palette',
    description: 'Provides the command palette.',
    autoStart: true,
    requires: [translation_lib_index_js_.ITranslator],
    provides: lib_index_js_.ICommandPalette,
    optional: [settingregistry_lib_index_js_.ISettingRegistry],
    activate: (app, translator, settingRegistry) => {
        return Palette.activate(app, translator, settingRegistry);
    }
};
/**
 * The default command palette's restoration extension.
 *
 * #### Notes
 * The command palette's restoration logic is handled separately from the
 * command palette provider extension because the layout restorer dependency
 * causes the command palette to be unavailable to other extensions earlier
 * in the application load cycle.
 */
const paletteRestorer = {
    id: '@jupyterlab/apputils-extension:palette-restorer',
    description: 'Restores the command palette.',
    autoStart: true,
    requires: [index_js_.ILayoutRestorer, translation_lib_index_js_.ITranslator],
    activate: (app, restorer, translator) => {
        Palette.restore(app, restorer, translator);
    }
};
/**
 * The default window name resolver provider.
 */
const resolver = {
    id: '@jupyterlab/apputils-extension:resolver',
    description: 'Provides the window name resolver.',
    autoStart: true,
    provides: lib_index_js_.IWindowResolver,
    requires: [index_js_.JupyterFrontEnd.IPaths, index_js_.IRouter],
    activate: async (app, paths, router) => {
        const { hash, search } = router.current;
        const query = coreutils_lib_index_js_.URLExt.queryStringToObject(search || '');
        const solver = new lib_index_js_.WindowResolver();
        const workspace = coreutils_lib_index_js_.PageConfig.getOption('workspace');
        const treePath = coreutils_lib_index_js_.PageConfig.getOption('treePath');
        const mode = coreutils_lib_index_js_.PageConfig.getOption('mode') === 'multiple-document' ? 'lab' : 'doc';
        // This is used as a key in local storage to refer to workspaces, either the name
        // of the workspace or the string PageConfig.defaultWorkspace. Both lab and doc modes share the same workspace.
        const candidate = workspace ? workspace : coreutils_lib_index_js_.PageConfig.defaultWorkspace;
        const rest = treePath ? coreutils_lib_index_js_.URLExt.join('tree', treePath) : '';
        try {
            await solver.resolve(candidate);
            return solver;
        }
        catch (error) {
            // Window resolution has failed so the URL must change. Return a promise
            // that never resolves to prevent the application from loading plugins
            // that rely on `IWindowResolver`.
            return new Promise(() => {
                const { base } = paths.urls;
                const pool = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                const random = pool[Math.floor(Math.random() * pool.length)];
                let path = coreutils_lib_index_js_.URLExt.join(base, mode, 'workspaces', `auto-${random}`);
                path = rest ? coreutils_lib_index_js_.URLExt.join(path, coreutils_lib_index_js_.URLExt.encodeParts(rest)) : path;
                // Reset the workspace on load.
                query['reset'] = '';
                const url = path + coreutils_lib_index_js_.URLExt.objectToQueryString(query) + (hash || '');
                router.navigate(url, { hard: true });
            });
        }
    }
};
/**
 * The default splash screen provider.
 */
const splash = {
    id: '@jupyterlab/apputils-extension:splash',
    description: 'Provides the splash screen.',
    autoStart: true,
    requires: [translation_lib_index_js_.ITranslator],
    provides: lib_index_js_.ISplashScreen,
    activate: (app, translator) => {
        const trans = translator.load('jupyterlab');
        const { commands, restored } = app;
        // Create splash element and populate it.
        const splash = document.createElement('div');
        const galaxy = document.createElement('div');
        const logo = document.createElement('div');
        splash.id = 'jupyterlab-splash';
        galaxy.id = 'galaxy';
        logo.id = 'main-logo';
        ui_components_lib_index_js_.jupyterFaviconIcon.element({
            container: logo,
            stylesheet: 'splash'
        });
        galaxy.appendChild(logo);
        ['1', '2', '3'].forEach(id => {
            const moon = document.createElement('div');
            const planet = document.createElement('div');
            moon.id = `moon${id}`;
            moon.className = 'moon orbit';
            planet.id = `planet${id}`;
            planet.className = 'planet';
            moon.appendChild(planet);
            galaxy.appendChild(moon);
        });
        splash.appendChild(galaxy);
        // Create debounced recovery dialog function.
        let dialog;
        const recovery = new dist_index_es6_js_.Throttler(async () => {
            if (dialog) {
                return;
            }
            dialog = new lib_index_js_.Dialog({
                title: trans.__('Loading…'),
                body: trans.__(`The loading screen is taking a long time.
Would you like to clear the workspace or keep waiting?`),
                buttons: [
                    lib_index_js_.Dialog.cancelButton({ label: trans.__('Keep Waiting') }),
                    lib_index_js_.Dialog.warnButton({ label: trans.__('Clear Workspace') })
                ]
            });
            try {
                const result = await dialog.launch();
                dialog.dispose();
                dialog = null;
                if (result.button.accept && commands.hasCommand(lib_CommandIDs.reset)) {
                    return commands.execute(lib_CommandIDs.reset);
                }
                // Re-invoke the recovery timer in the next frame.
                requestAnimationFrame(() => {
                    // Because recovery can be stopped, handle invocation rejection.
                    void recovery.invoke().catch(_ => undefined);
                });
            }
            catch (error) {
                /* no-op */
            }
        }, { limit: SPLASH_RECOVER_TIMEOUT, edge: 'trailing' });
        // Return ISplashScreen.
        let splashCount = 0;
        return {
            show: (light = true) => {
                splash.classList.remove('splash-fade');
                splash.classList.toggle('light', light);
                splash.classList.toggle('dark', !light);
                splashCount++;
                document.body.appendChild(splash);
                // Because recovery can be stopped, handle invocation rejection.
                void recovery.invoke().catch(_ => undefined);
                return new index_es6_js_.DisposableDelegate(async () => {
                    await restored;
                    if (--splashCount === 0) {
                        void recovery.stop();
                        if (dialog) {
                            dialog.dispose();
                            dialog = null;
                        }
                        splash.classList.add('splash-fade');
                        window.setTimeout(() => {
                            document.body.removeChild(splash);
                        }, 200);
                    }
                });
            }
        };
    }
};
const print = {
    id: '@jupyterlab/apputils-extension:print',
    description: 'Add the print capability',
    autoStart: true,
    requires: [translation_lib_index_js_.ITranslator],
    activate: (app, translator) => {
        var _a;
        const trans = translator.load('jupyterlab');
        app.commands.addCommand(lib_CommandIDs.print, {
            label: trans.__('Print…'),
            isEnabled: () => {
                const widget = app.shell.currentWidget;
                return lib_index_js_.Printing.getPrintFunction(widget) !== null;
            },
            execute: async () => {
                const widget = app.shell.currentWidget;
                const printFunction = lib_index_js_.Printing.getPrintFunction(widget);
                if (printFunction) {
                    await printFunction();
                }
            }
        });
        (_a = app.shell.currentChanged) === null || _a === void 0 ? void 0 : _a.connect(() => {
            app.commands.notifyCommandChanged(lib_CommandIDs.print);
        });
    }
};
const toggleHeader = {
    id: '@jupyterlab/apputils-extension:toggle-header',
    description: 'Adds a command to display the main area widget content header.',
    autoStart: true,
    requires: [translation_lib_index_js_.ITranslator],
    optional: [lib_index_js_.ICommandPalette],
    activate: (app, translator, palette) => {
        var _a;
        const trans = translator.load('jupyterlab');
        const category = trans.__('Main Area');
        app.commands.addCommand(lib_CommandIDs.toggleHeader, {
            label: trans.__('Show Header Above Content'),
            isEnabled: () => app.shell.currentWidget instanceof lib_index_js_.MainAreaWidget &&
                !app.shell.currentWidget.contentHeader.isDisposed &&
                app.shell.currentWidget.contentHeader.widgets.length > 0,
            isToggled: () => {
                const widget = app.shell.currentWidget;
                return widget instanceof lib_index_js_.MainAreaWidget
                    ? !widget.contentHeader.isHidden
                    : false;
            },
            execute: async () => {
                const widget = app.shell.currentWidget;
                if (widget instanceof lib_index_js_.MainAreaWidget) {
                    widget.contentHeader.setHidden(!widget.contentHeader.isHidden);
                }
            }
        });
        (_a = app.shell.currentChanged) === null || _a === void 0 ? void 0 : _a.connect(() => {
            app.commands.notifyCommandChanged(lib_CommandIDs.toggleHeader);
        });
        if (palette) {
            palette.addItem({ command: lib_CommandIDs.toggleHeader, category });
        }
    }
};
/**
 * Update the browser title based on the workspace and the current
 * active item.
 */
async function updateTabTitle(workspace, db, name) {
    var _a, _b;
    const data = await db.toJSON();
    let current = (_b = (_a = data['layout-restorer:data']) === null || _a === void 0 ? void 0 : _a.main) === null || _b === void 0 ? void 0 : _b.current;
    if (current === undefined ||
        !(current.startsWith('notebook') || current.startsWith('editor'))) {
        document.title = `${coreutils_lib_index_js_.PageConfig.getOption('appName') || 'JupyterLab'}${workspace === 'default' ? '' : ` (${workspace})`}`;
    }
    else {
        // File name from current path
        let currentFile = coreutils_lib_index_js_.PathExt.basename(decodeURIComponent(window.location.href));
        // Truncate to first 12 characters of current document name + ... if length > 15
        currentFile =
            currentFile.length > 15
                ? currentFile.slice(0, 12).concat(`…`)
                : currentFile;
        workspace =
            workspace.length > 15 ? workspace.slice(0, 12).concat(`…`) : workspace;
        // Number of restorable items that are either notebooks or editors
        const count = Object.keys(data).filter(item => item.startsWith('notebook') || item.startsWith('editor')).length;
        document.title = `${currentFile}${count > 1 ? ` (${count})` : ``} - ${workspace === 'default' ? name : workspace}`;
    }
}
/**
 * The default state database for storing application state.
 *
 * #### Notes
 * If this extension is loaded with a window resolver, it will automatically add
 * state management commands, URL support for `clone` and `reset`, and workspace
 * auto-saving. Otherwise, it will return a simple in-memory state database.
 */
const state = {
    id: '@jupyterlab/apputils-extension:state',
    description: 'Provides the application state. It is stored per workspaces.',
    autoStart: true,
    provides: statedb_lib_index_js_.IStateDB,
    requires: [index_js_.JupyterFrontEnd.IPaths, index_js_.IRouter, translation_lib_index_js_.ITranslator],
    optional: [lib_index_js_.IWindowResolver],
    activate: (app, paths, router, translator, resolver) => {
        const trans = translator.load('jupyterlab');
        if (resolver === null) {
            return new statedb_lib_index_js_.StateDB();
        }
        let resolved = false;
        const { commands, name, serviceManager } = app;
        const { workspaces } = serviceManager;
        const workspace = resolver.name;
        const transform = new dist_index_js_.PromiseDelegate();
        const db = new statedb_lib_index_js_.StateDB({ transform: transform.promise });
        const save = new dist_index_es6_js_.Debouncer(async () => {
            const id = workspace;
            const metadata = { id };
            const data = await db.toJSON();
            await workspaces.save(id, { data, metadata });
        });
        // Any time the local state database changes, save the workspace.
        db.changed.connect(() => void save.invoke(), db);
        db.changed.connect(() => updateTabTitle(workspace, db, name));
        commands.addCommand(lib_CommandIDs.loadState, {
            label: trans.__('Load state for the current workspace.'),
            execute: async (args) => {
                // Since the command can be executed an arbitrary number of times, make
                // sure it is safe to call multiple times.
                if (resolved) {
                    return;
                }
                const { hash, path, search } = args;
                const query = coreutils_lib_index_js_.URLExt.queryStringToObject(search || '');
                const clone = typeof query['clone'] === 'string'
                    ? query['clone'] === ''
                        ? coreutils_lib_index_js_.PageConfig.defaultWorkspace
                        : query['clone']
                    : null;
                const source = clone || workspace || null;
                if (source === null) {
                    console.error(`${lib_CommandIDs.loadState} cannot load null workspace.`);
                    return;
                }
                try {
                    const saved = await workspaces.fetch(source);
                    // If this command is called after a reset, the state database
                    // will already be resolved.
                    if (!resolved) {
                        resolved = true;
                        transform.resolve({ type: 'overwrite', contents: saved.data });
                    }
                }
                catch ({ message }) {
                    console.warn(`Fetching workspace "${workspace}" failed.`, message);
                    // If the workspace does not exist, cancel the data transformation
                    // and save a workspace with the current user state data.
                    if (!resolved) {
                        resolved = true;
                        transform.resolve({ type: 'cancel', contents: null });
                    }
                }
                if (source === clone) {
                    // Maintain the query string parameters but remove `clone`.
                    delete query['clone'];
                    const url = path + coreutils_lib_index_js_.URLExt.objectToQueryString(query) + hash;
                    const cloned = save.invoke().then(() => router.stop);
                    // After the state has been cloned, navigate to the URL.
                    void cloned.then(() => {
                        router.navigate(url);
                    });
                    return cloned;
                }
                // After the state database has finished loading, save it.
                await save.invoke();
            }
        });
        commands.addCommand(lib_CommandIDs.reset, {
            label: trans.__('Reset Application State'),
            execute: async ({ reload }) => {
                await db.clear();
                await save.invoke();
                if (reload) {
                    router.reload();
                }
            }
        });
        commands.addCommand(lib_CommandIDs.resetOnLoad, {
            label: trans.__('Reset state when loading for the workspace.'),
            execute: (args) => {
                const { hash, path, search } = args;
                const query = coreutils_lib_index_js_.URLExt.queryStringToObject(search || '');
                const reset = 'reset' in query;
                const clone = 'clone' in query;
                if (!reset) {
                    return;
                }
                // If the state database has already been resolved, resetting is
                // impossible without reloading.
                if (resolved) {
                    return router.reload();
                }
                // Empty the state database.
                resolved = true;
                transform.resolve({ type: 'clear', contents: null });
                // Maintain the query string parameters but remove `reset`.
                delete query['reset'];
                const url = path + coreutils_lib_index_js_.URLExt.objectToQueryString(query) + hash;
                const cleared = db.clear().then(() => save.invoke());
                // After the state has been reset, navigate to the URL.
                if (clone) {
                    void cleared.then(() => {
                        router.navigate(url, { hard: true });
                    });
                }
                else {
                    void cleared.then(() => {
                        router.navigate(url);
                    });
                }
                return cleared;
            }
        });
        router.register({
            command: lib_CommandIDs.loadState,
            pattern: /.?/,
            rank: 30 // High priority: 30:100.
        });
        router.register({
            command: lib_CommandIDs.resetOnLoad,
            pattern: /(\?reset|\&reset)($|&)/,
            rank: 20 // High priority: 20:100.
        });
        return db;
    }
};
/**
 * The default session context dialogs extension.
 */
const sessionDialogs = {
    id: '@jupyterlab/apputils-extension:sessionDialogs',
    description: 'Provides the session context dialogs.',
    provides: lib_index_js_.ISessionContextDialogs,
    optional: [translation_lib_index_js_.ITranslator, settingregistry_lib_index_js_.ISettingRegistry],
    autoStart: true,
    activate: async (app, translator, settingRegistry) => {
        return new lib_index_js_.SessionContextDialogs({
            translator: translator !== null && translator !== void 0 ? translator : translation_lib_index_js_.nullTranslator,
            settingRegistry: settingRegistry !== null && settingRegistry !== void 0 ? settingRegistry : null
        });
    }
};
/**
 * Utility commands
 */
const utilityCommands = {
    id: '@jupyterlab/apputils-extension:utilityCommands',
    description: 'Adds meta commands to run set of other commands.',
    requires: [translation_lib_index_js_.ITranslator],
    optional: [lib_index_js_.ICommandPalette],
    autoStart: true,
    activate: (app, translator, palette) => {
        const trans = translator.load('jupyterlab');
        const { commands } = app;
        commands.addCommand(lib_CommandIDs.runFirstEnabled, {
            label: trans.__('Run First Enabled Command'),
            execute: args => {
                const commands = args.commands;
                const commandArgs = args.args;
                const argList = Array.isArray(args);
                for (let i = 0; i < commands.length; i++) {
                    const cmd = commands[i];
                    const arg = argList ? commandArgs[i] : commandArgs;
                    if (app.commands.isEnabled(cmd, arg)) {
                        return app.commands.execute(cmd, arg);
                    }
                }
            }
        });
        // Add a command for taking lists of commands and command arguments
        // and running all the enabled commands.
        commands.addCommand(lib_CommandIDs.runAllEnabled, {
            label: trans.__('Run All Enabled Commands Passed as Args'),
            execute: async (args) => {
                var _a, _b;
                const commands = (_a = args.commands) !== null && _a !== void 0 ? _a : [];
                const commandArgs = args.args;
                const argList = Array.isArray(args);
                const errorIfNotEnabled = (_b = args.errorIfNotEnabled) !== null && _b !== void 0 ? _b : false;
                for (let i = 0; i < commands.length; i++) {
                    const cmd = commands[i];
                    const arg = argList ? commandArgs[i] : commandArgs;
                    if (app.commands.isEnabled(cmd, arg)) {
                        await app.commands.execute(cmd, arg);
                    }
                    else {
                        if (errorIfNotEnabled) {
                            console.error(`${cmd} is not enabled.`);
                        }
                    }
                }
            },
            isEnabled: args => {
                var _a;
                const commands = (_a = args.commands) !== null && _a !== void 0 ? _a : [];
                const commandArgs = args.args;
                const argList = Array.isArray(args);
                return commands.some((cmd, idx) => app.commands.isEnabled(cmd, argList ? commandArgs[idx] : commandArgs));
            }
        });
        commands.addCommand(lib_CommandIDs.displayShortcuts, {
            label: trans.__('Show Keyboard Shortcuts…'),
            caption: trans.__('Show relevant keyboard shortcuts for the current active widget'),
            execute: args => {
                var _a;
                const currentWidget = app.shell.currentWidget;
                const included = currentWidget === null || currentWidget === void 0 ? void 0 : currentWidget.node.contains(document.activeElement);
                if (!included && currentWidget instanceof lib_index_js_.MainAreaWidget) {
                    const currentNode = (_a = currentWidget.content.node) !== null && _a !== void 0 ? _a : currentWidget === null || currentWidget === void 0 ? void 0 : currentWidget.node;
                    currentNode === null || currentNode === void 0 ? void 0 : currentNode.focus();
                }
                const options = { commands, trans };
                return displayShortcuts(options);
            }
        });
        if (palette) {
            const category = trans.__('Help');
            palette.addItem({ command: lib_CommandIDs.displayShortcuts, category });
        }
    }
};
/**
 * The default HTML sanitizer.
 */
const sanitizer = {
    id: '@jupyterlab/apputils-extension:sanitizer',
    description: 'Provides the HTML sanitizer.',
    autoStart: true,
    provides: lib_index_js_.ISanitizer,
    requires: [settingregistry_lib_index_js_.ISettingRegistry],
    activate: (app, settings) => {
        const sanitizer = new lib_index_js_.Sanitizer();
        const loadSetting = (setting) => {
            const allowedSchemes = setting.get('allowedSchemes')
                .composite;
            const autolink = setting.get('autolink').composite;
            const allowNamedProperties = setting.get('allowNamedProperties')
                .composite;
            if (allowedSchemes) {
                sanitizer.setAllowedSchemes(allowedSchemes);
            }
            sanitizer.setAutolink(autolink);
            sanitizer.setAllowNamedProperties(allowNamedProperties);
        };
        // Wait for the application to be restored and
        // for the settings for this plugin to be loaded
        settings
            .load('@jupyterlab/apputils-extension:sanitizer')
            .then(setting => {
            // Read the settings
            loadSetting(setting);
            // Listen for your plugin setting changes using Signal
            setting.changed.connect(loadSetting);
        })
            .catch(reason => {
            console.error(`Failed to load sanitizer settings:`, reason);
        });
        return sanitizer;
    }
};
/*
 * A plugin owning the kernel settings
 */
const kernelSettings = {
    id: '@jupyterlab/apputils-extension:kernels-settings',
    description: 'Reserves the name for kernel settings.',
    autoStart: true,
    requires: [settingregistry_lib_index_js_.ISettingRegistry],
    activate: (_app, settingRegistry) => {
        void settingRegistry.load(kernelSettings.id);
    }
};
/**
 * Export the plugins as default.
 */
const plugins = [
    kernelSettings,
    announcements,
    kernelStatus,
    licensesClient,
    licensesPlugin,
    notificationPlugin,
    palette,
    paletteRestorer,
    print,
    resolver,
    runningSessionsStatus,
    subshellsSettings,
    sanitizer,
    settingsConnector,
    settingsPlugin,
    state,
    splash,
    sessionDialogs,
    themesPlugin,
    themesPaletteMenuPlugin,
    toggleHeader,
    toolbarRegistry,
    utilityCommands,
    workspacesPlugin
];
/* harmony default export */ const lib = (plugins);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 82649:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// EXTERNAL MODULE: ../node_modules/@lumino/widgets/style/index.js + 1 modules
var style = __webpack_require__(20959);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/ui-components/style/index.js + 1 modules
var ui_components_style = __webpack_require__(26238);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/statusbar/style/index.js + 1 modules
var statusbar_style = __webpack_require__(25066);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/apputils/style/index.js + 1 modules
var apputils_style = __webpack_require__(57261);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/docregistry/style/index.js + 1 modules
var docregistry_style = __webpack_require__(30507);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/application/style/index.js + 1 modules
var application_style = __webpack_require__(67663);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/mainmenu/style/index.js
var mainmenu_style = __webpack_require__(70022);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(94830);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(80592);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(99763);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(28915);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(80366);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(17352);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ../node_modules/@jupyterlab/builder/node_modules/css-loader/dist/cjs.js!../node_modules/@jupyterlab/apputils-extension/style/base.css
var base = __webpack_require__(92606);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/style/base.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(base/* default */.Z, options);




       /* harmony default export */ const style_base = (base/* default */.Z && base/* default */.Z.locals ? base/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils-extension/style/index.js
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* This file was auto-generated by ensurePackage() in @jupyterlab/buildutils */











/***/ }),

/***/ 13296:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Clipboard: () => (/* reexport */ Clipboard),
  Collapse: () => (/* reexport */ index_js_.Collapser),
  CommandLinker: () => (/* reexport */ CommandLinker),
  CommandToolbarButton: () => (/* reexport */ index_js_.CommandToolbarButton),
  CommandToolbarButtonComponent: () => (/* reexport */ index_js_.CommandToolbarButtonComponent),
  DOMUtils: () => (/* reexport */ DOMUtils),
  Dialog: () => (/* reexport */ Dialog),
  HoverBox: () => (/* reexport */ index_js_.HoverBox),
  ICommandPalette: () => (/* reexport */ ICommandPalette),
  IFrame: () => (/* reexport */ index_js_.IFrame),
  IKernelStatusModel: () => (/* reexport */ IKernelStatusModel),
  ILicensesClient: () => (/* reexport */ ILicensesClient),
  ISanitizer: () => (/* reexport */ ISanitizer),
  ISessionContextDialogs: () => (/* reexport */ ISessionContextDialogs),
  ISplashScreen: () => (/* reexport */ ISplashScreen),
  IThemeManager: () => (/* reexport */ IThemeManager),
  IToolbarWidgetRegistry: () => (/* reexport */ IToolbarWidgetRegistry),
  IWindowResolver: () => (/* reexport */ IWindowResolver),
  InputDialog: () => (/* reexport */ InputDialog),
  KernelStatus: () => (/* reexport */ KernelStatus),
  Licenses: () => (/* reexport */ Licenses),
  MainAreaWidget: () => (/* reexport */ MainAreaWidget),
  MenuFactory: () => (/* reexport */ MenuFactory),
  ModalCommandPalette: () => (/* reexport */ ModalCommandPalette),
  Notification: () => (/* reexport */ Notification),
  NotificationManager: () => (/* reexport */ NotificationManager),
  Printing: () => (/* reexport */ Printing),
  ReactWidget: () => (/* reexport */ index_js_.ReactWidget),
  RunningSessions: () => (/* reexport */ RunningSessions),
  Sanitizer: () => (/* reexport */ Sanitizer),
  SemanticCommand: () => (/* reexport */ SemanticCommand),
  SessionContext: () => (/* reexport */ SessionContext),
  SessionContextDialogs: () => (/* reexport */ SessionContextDialogs),
  Spinner: () => (/* reexport */ index_js_.Spinner),
  Styling: () => (/* reexport */ index_js_.Styling),
  ThemeManager: () => (/* reexport */ ThemeManager),
  Toolbar: () => (/* binding */ Toolbar),
  ToolbarButton: () => (/* reexport */ index_js_.ToolbarButton),
  ToolbarButtonComponent: () => (/* reexport */ index_js_.ToolbarButtonComponent),
  ToolbarWidgetRegistry: () => (/* reexport */ ToolbarWidgetRegistry),
  UseSignal: () => (/* reexport */ index_js_.UseSignal),
  VDomModel: () => (/* reexport */ index_js_.VDomModel),
  VDomRenderer: () => (/* reexport */ index_js_.VDomRenderer),
  WidgetTracker: () => (/* reexport */ WidgetTracker),
  WindowResolver: () => (/* reexport */ WindowResolver),
  addCommandToolbarButtonClass: () => (/* reexport */ index_js_.addCommandToolbarButtonClass),
  addToolbarButtonClass: () => (/* reexport */ index_js_.addToolbarButtonClass),
  createDefaultFactory: () => (/* reexport */ createDefaultFactory),
  createToolbarFactory: () => (/* reexport */ createToolbarFactory),
  setToolbar: () => (/* reexport */ setToolbar),
  showDialog: () => (/* reexport */ showDialog),
  showErrorMessage: () => (/* reexport */ showErrorMessage),
  translateKernelStatuses: () => (/* reexport */ translateKernelStatuses)
});

// EXTERNAL MODULE: consume shared module (default) @jupyterlab/ui-components@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/ui-components/lib/index.js)
var index_js_ = __webpack_require__(39089);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/translation@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/translation/lib/index.js)
var lib_index_js_ = __webpack_require__(50856);
// EXTERNAL MODULE: consume shared module (default) @lumino/widgets@~2.7.1 (singleton) (fallback: ../node_modules/@lumino/widgets/dist/index.es6.js)
var index_es6_js_ = __webpack_require__(60920);
// EXTERNAL MODULE: consume shared module (default) react@~18.2.0 (singleton) (fallback: ../node_modules/react/index.js)
var react_index_js_ = __webpack_require__(78156);
var react_index_js_default = /*#__PURE__*/__webpack_require__.n(react_index_js_);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/coreutils@~6.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/coreutils/lib/index.js)
var coreutils_lib_index_js_ = __webpack_require__(60649);
// EXTERNAL MODULE: consume shared module (default) @lumino/algorithm@~2.0.3 (singleton) (fallback: ../node_modules/@lumino/algorithm/dist/index.es6.js)
var dist_index_es6_js_ = __webpack_require__(56114);
// EXTERNAL MODULE: consume shared module (default) @lumino/coreutils@~2.2.1 (singleton) (fallback: ../node_modules/@lumino/coreutils/dist/index.js)
var dist_index_js_ = __webpack_require__(5406);
// EXTERNAL MODULE: consume shared module (default) @lumino/signaling@~2.1.4 (singleton) (fallback: ../node_modules/@lumino/signaling/dist/index.es6.js)
var signaling_dist_index_es6_js_ = __webpack_require__(2536);
// EXTERNAL MODULE: consume shared module (default) @lumino/messaging@~2.0.3 (singleton) (fallback: ../node_modules/@lumino/messaging/dist/index.es6.js)
var messaging_dist_index_es6_js_ = __webpack_require__(34993);
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/statedb@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/statedb/lib/index.js)
var statedb_lib_index_js_ = __webpack_require__(70870);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/widgettracker.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * A class that keeps track of widget instances on an Application shell.
 *
 * @typeparam T - The type of widget being tracked. Defaults to `Widget`.
 *
 * #### Notes
 * The API surface area of this concrete implementation is substantially larger
 * than the widget tracker interface it implements. The interface is intended
 * for export by JupyterLab plugins that create widgets and have clients who may
 * wish to keep track of newly created widgets. This class, however, can be used
 * internally by plugins to restore state as well.
 */
class WidgetTracker {
    /**
     * Create a new widget tracker.
     *
     * @param options - The instantiation options for a widget tracker.
     */
    constructor(options) {
        this._currentChanged = new signaling_dist_index_es6_js_.Signal(this);
        this._deferred = null;
        this._isDisposed = false;
        this._widgetAdded = new signaling_dist_index_es6_js_.Signal(this);
        this._widgetUpdated = new signaling_dist_index_es6_js_.Signal(this);
        const focus = (this._focusTracker = new index_es6_js_.FocusTracker());
        const pool = (this._pool = new statedb_lib_index_js_.RestorablePool(options));
        this.namespace = options.namespace;
        focus.currentChanged.connect((_, current) => {
            if (current.newValue !== this.currentWidget) {
                pool.current = current.newValue;
            }
        }, this);
        pool.added.connect((_, widget) => {
            this._widgetAdded.emit(widget);
        }, this);
        pool.currentChanged.connect((_, widget) => {
            // If the pool's current reference is `null` but the focus tracker has a
            // current widget, update the pool to match the focus tracker.
            if (widget === null && focus.currentWidget) {
                pool.current = focus.currentWidget;
                return;
            }
            this.onCurrentChanged(widget);
            this._currentChanged.emit(widget);
        }, this);
        pool.updated.connect((_, widget) => {
            this._widgetUpdated.emit(widget);
        }, this);
    }
    /**
     * A signal emitted when the current widget changes.
     */
    get currentChanged() {
        return this._currentChanged;
    }
    /**
     * The current widget is the most recently focused or added widget.
     *
     * #### Notes
     * It is the most recently focused widget, or the most recently added
     * widget if no widget has taken focus.
     */
    get currentWidget() {
        return this._pool.current || null;
    }
    /**
     * A promise resolved when the tracker has been restored.
     */
    get restored() {
        if (this._deferred) {
            return Promise.resolve();
        }
        else {
            return this._pool.restored;
        }
    }
    /**
     * The number of widgets held by the tracker.
     */
    get size() {
        return this._pool.size;
    }
    /**
     * A signal emitted when a widget is added.
     *
     * #### Notes
     * This signal will only fire when a widget is added to the tracker. It will
     * not fire if a widget is injected into the tracker.
     */
    get widgetAdded() {
        return this._widgetAdded;
    }
    /**
     * A signal emitted when a widget is updated.
     */
    get widgetUpdated() {
        return this._widgetUpdated;
    }
    /**
     * Add a new widget to the tracker.
     *
     * @param widget - The widget being added.
     *
     * #### Notes
     * The widget passed into the tracker is added synchronously; its existence in
     * the tracker can be checked with the `has()` method. The promise this method
     * returns resolves after the widget has been added and saved to an underlying
     * restoration connector, if one is available.
     *
     * The newly added widget becomes the current widget unless the focus tracker
     * already had a focused widget.
     */
    async add(widget) {
        this._focusTracker.add(widget);
        await this._pool.add(widget);
        if (!this._focusTracker.activeWidget) {
            this._pool.current = widget;
        }
    }
    /**
     * Test whether the tracker is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Dispose of the resources held by the tracker.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._pool.dispose();
        this._focusTracker.dispose();
        signaling_dist_index_es6_js_.Signal.clearData(this);
    }
    /**
     * Find the first widget in the tracker that satisfies a filter function.
     *
     * @param fn The filter function to call on each widget.
     *
     * #### Notes
     * If no widget is found, the value returned is `undefined`.
     */
    find(fn) {
        return this._pool.find(fn);
    }
    /**
     * Iterate through each widget in the tracker.
     *
     * @param fn - The function to call on each widget.
     */
    forEach(fn) {
        return this._pool.forEach(fn);
    }
    /**
     * Filter the widgets in the tracker based on a predicate.
     *
     * @param fn - The function by which to filter.
     */
    filter(fn) {
        return this._pool.filter(fn);
    }
    /**
     * Inject a foreign widget into the widget tracker.
     *
     * @param widget - The widget to inject into the tracker.
     *
     * #### Notes
     * Injected widgets will not have their state saved by the tracker.
     *
     * The primary use case for widget injection is for a plugin that offers a
     * sub-class of an extant plugin to have its instances share the same commands
     * as the parent plugin (since most relevant commands will use the
     * `currentWidget` of the parent plugin's widget tracker). In this situation,
     * the sub-class plugin may well have its own widget tracker for layout and
     * state restoration in addition to injecting its widgets into the parent
     * plugin's widget tracker.
     */
    inject(widget) {
        return this._pool.inject(widget);
    }
    /**
     * Check if this tracker has the specified widget.
     *
     * @param widget - The widget whose existence is being checked.
     */
    has(widget) {
        return this._pool.has(widget);
    }
    /**
     * Restore the widgets in this tracker's namespace.
     *
     * @param options - The configuration options that describe restoration.
     *
     * @returns A promise that resolves when restoration has completed.
     *
     * #### Notes
     * This function should not typically be invoked by client code.
     * Its primary use case is to be invoked by a restorer.
     */
    async restore(options) {
        const deferred = this._deferred;
        if (deferred) {
            this._deferred = null;
            return this._pool.restore(deferred);
        }
        if (options) {
            return this._pool.restore(options);
        }
        console.warn('No options provided to restore the tracker.');
    }
    /**
     * Save the restore options for this tracker, but do not restore yet.
     *
     * @param options - The configuration options that describe restoration.
     *
     * ### Notes
     * This function is useful when starting the shell in 'single-document' mode,
     * to avoid restoring all useless widgets. It should not ordinarily be called
     * by client code.
     */
    defer(options) {
        this._deferred = options;
    }
    /**
     * Save the restore data for a given widget.
     *
     * @param widget - The widget being saved.
     */
    async save(widget) {
        return this._pool.save(widget);
    }
    /**
     * Handle the current change event.
     *
     * #### Notes
     * The default implementation is a no-op.
     */
    onCurrentChanged(value) {
        /* no-op */
    }
}
//# sourceMappingURL=widgettracker.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/dialog.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.








/**
 * Create and show a dialog.
 *
 * @param options - The dialog setup options.
 *
 * @returns A promise that resolves with whether the dialog was accepted.
 */
function showDialog(options = {}) {
    const dialog = new Dialog(options);
    return dialog.launch();
}
/**
 * Show an error message dialog.
 *
 * @param title - The title of the dialog box.
 *
 * @param error - the error to show in the dialog body (either a string
 *   or an object with a string `message` property).
 */
function showErrorMessage(title, error, buttons) {
    const trans = Dialog.translator.load('jupyterlab');
    buttons = buttons !== null && buttons !== void 0 ? buttons : [Dialog.cancelButton({ label: trans.__('Close') })];
    console.warn('Showing error:', error);
    // Cache promises to prevent multiple copies of identical dialogs showing
    // to the user.
    const body = typeof error === 'string' ? error : error.message;
    const key = title + '----' + body;
    const promise = Private.errorMessagePromiseCache.get(key);
    if (promise) {
        return promise;
    }
    else {
        const dialogPromise = showDialog({
            title: title,
            body: body,
            buttons: buttons
        }).then(() => {
            Private.errorMessagePromiseCache.delete(key);
        }, error => {
            // TODO: Use .finally() above when supported
            Private.errorMessagePromiseCache.delete(key);
            throw error;
        });
        Private.errorMessagePromiseCache.set(key, dialogPromise);
        return dialogPromise;
    }
}
/**
 * A modal dialog widget.
 */
class Dialog extends index_es6_js_.Widget {
    /**
     * Create a dialog panel instance.
     *
     * @param options - The dialog setup options.
     */
    constructor(options = {}) {
        const dialogNode = document.createElement('dialog');
        dialogNode.ariaModal = 'true';
        super({ node: dialogNode });
        this._hasValidationErrors = false;
        this._ready = new dist_index_js_.PromiseDelegate();
        this._focusNodeSelector = '';
        this.addClass('jp-Dialog');
        this.addClass('jp-ThemedContainer');
        const normalized = Private.handleOptions(options);
        const renderer = normalized.renderer;
        this._host = normalized.host;
        this._defaultButton = normalized.defaultButton;
        this._buttons = normalized.buttons;
        this._hasClose = normalized.hasClose;
        this._buttonNodes = this._buttons.map(b => renderer.createButtonNode(b));
        this._checkboxNode = null;
        this._lastMouseDownInDialog = false;
        if (normalized.checkbox) {
            const { label = '', caption = '', checked = false, className = '' } = normalized.checkbox;
            this._checkboxNode = renderer.createCheckboxNode({
                label,
                caption: caption !== null && caption !== void 0 ? caption : label,
                checked,
                className
            });
        }
        const layout = (this.layout = new index_es6_js_.PanelLayout());
        const content = new index_es6_js_.Panel();
        content.addClass('jp-Dialog-content');
        if (typeof options.body === 'string') {
            content.addClass('jp-Dialog-content-small');
            dialogNode.ariaLabel = [normalized.title, options.body].join(' ');
        }
        layout.addWidget(content);
        this._body = normalized.body;
        const header = renderer.createHeader(normalized.title, () => this.reject(), options);
        const body = renderer.createBody(normalized.body);
        const footer = renderer.createFooter(this._buttonNodes, this._checkboxNode);
        content.addWidget(header);
        content.addWidget(body);
        content.addWidget(footer);
        this._bodyWidget = body;
        this._primary = this._buttonNodes[this._defaultButton];
        this._focusNodeSelector = options.focusNodeSelector;
        // Add new dialogs to the tracker.
        void Dialog.tracker.add(this);
    }
    /**
     * A promise that resolves when the Dialog first rendering is done.
     */
    get ready() {
        return this._ready.promise;
    }
    /**
     * Dispose of the resources used by the dialog.
     */
    dispose() {
        const promise = this._promise;
        if (promise) {
            this._promise = null;
            promise.reject(void 0);
            dist_index_es6_js_.ArrayExt.removeFirstOf(Private.launchQueue, promise.promise);
        }
        super.dispose();
    }
    /**
     * Launch the dialog as a modal window.
     *
     * @returns a promise that resolves with the result of the dialog.
     */
    launch() {
        // Return the existing dialog if already open.
        if (this._promise) {
            return this._promise.promise;
        }
        const promise = (this._promise = new dist_index_js_.PromiseDelegate());
        const promises = Promise.all(Private.launchQueue);
        Private.launchQueue.push(this._promise.promise);
        return promises.then(() => {
            // Do not show Dialog if it was disposed of before it was at the front of the launch queue
            if (!this._promise) {
                return Promise.resolve({
                    button: Dialog.cancelButton(),
                    isChecked: null,
                    value: null
                });
            }
            index_es6_js_.Widget.attach(this, this._host);
            return promise.promise;
        });
    }
    /**
     * Resolve the current dialog.
     *
     * @param index - An optional index to the button to resolve.
     *
     * #### Notes
     * Will default to the defaultIndex.
     * Will resolve the current `show()` with the button value.
     * Will be a no-op if the dialog is not shown.
     */
    resolve(index) {
        if (!this._promise) {
            return;
        }
        if (index === undefined) {
            index = this._defaultButton;
        }
        this._resolve(this._buttons[index]);
    }
    /**
     * Reject the current dialog with a default reject value.
     *
     * #### Notes
     * Will be a no-op if the dialog is not shown.
     */
    reject() {
        if (!this._promise) {
            return;
        }
        this._resolve(Dialog.cancelButton());
    }
    /**
     * Handle the DOM events for the directory listing.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the panel's DOM node. It should
     * not be called directly by user code.
     */
    handleEvent(event) {
        switch (event.type) {
            case 'keydown':
                this._evtKeydown(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'click':
                this._evtClick(event);
                break;
            case 'input':
                this._evtInput(event);
                break;
            case 'focus':
                this._evtFocus(event);
                break;
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
            default:
                break;
        }
    }
    /**
     *  A message handler invoked on an `'after-attach'` message.
     */
    onAfterAttach(msg) {
        const node = this.node;
        node.addEventListener('keydown', this, true);
        node.addEventListener('contextmenu', this, true);
        node.addEventListener('click', this, true);
        document.addEventListener('mousedown', this, true);
        document.addEventListener('focus', this, true);
        document.addEventListener('input', this, true);
        this._first = Private.findFirstFocusable(this.node);
        this._original = document.activeElement;
        const setFocus = () => {
            var _a;
            if (this._focusNodeSelector) {
                const body = this.node.querySelector('.jp-Dialog-body');
                const el = body === null || body === void 0 ? void 0 : body.querySelector(this._focusNodeSelector);
                if (el) {
                    this._primary = el;
                }
            }
            (_a = this._primary) === null || _a === void 0 ? void 0 : _a.focus();
            this._ready.resolve();
        };
        if (this._bodyWidget instanceof index_js_.ReactWidget &&
            this._bodyWidget.renderPromise !== undefined) {
            this._bodyWidget
                .renderPromise.then(() => {
                setFocus();
            })
                .catch(() => {
                console.error("Error while loading Dialog's body");
            });
        }
        else {
            setFocus();
        }
    }
    /**
     *  A message handler invoked on an `'after-detach'` message.
     */
    onAfterDetach(msg) {
        const node = this.node;
        node.removeEventListener('keydown', this, true);
        node.removeEventListener('contextmenu', this, true);
        node.removeEventListener('click', this, true);
        document.removeEventListener('focus', this, true);
        document.removeEventListener('mousedown', this, true);
        document.removeEventListener('input', this, true);
        this._original.focus();
    }
    /**
     * A message handler invoked on a `'close-request'` message.
     */
    onCloseRequest(msg) {
        if (this._promise) {
            this.reject();
        }
        super.onCloseRequest(msg);
    }
    /**
     * Handle the `'input'` event for dialog's children.
     *
     * @param event - The DOM event sent to the widget
     */
    _evtInput(_event) {
        this._hasValidationErrors = !!this.node.querySelector(':invalid');
        for (let i = 0; i < this._buttons.length; i++) {
            if (this._buttons[i].accept) {
                this._buttonNodes[i].disabled = this._hasValidationErrors;
            }
        }
    }
    /**
     * Handle the `'click'` event for a dialog button.
     *
     * @param event - The DOM event sent to the widget
     */
    _evtClick(event) {
        const content = this.node.getElementsByClassName('jp-Dialog-content')[0];
        if (!content.contains(event.target)) {
            event.stopPropagation();
            event.preventDefault();
            if (this._hasClose && !this._lastMouseDownInDialog) {
                this.reject();
            }
            return;
        }
        for (const buttonNode of this._buttonNodes) {
            if (buttonNode.contains(event.target)) {
                const index = this._buttonNodes.indexOf(buttonNode);
                this.resolve(index);
            }
        }
    }
    /**
     * Handle the `'keydown'` event for the widget.
     *
     * @param event - The DOM event sent to the widget
     */
    _evtKeydown(event) {
        // Check for escape key
        switch (event.keyCode) {
            case 27: // Escape.
                event.stopPropagation();
                event.preventDefault();
                if (this._hasClose) {
                    this.reject();
                }
                break;
            case 37: {
                // Left arrow
                const activeEl = document.activeElement;
                if (activeEl instanceof HTMLButtonElement) {
                    let idx = this._buttonNodes.indexOf(activeEl) - 1;
                    // Handle a left arrows on the first button
                    if (idx < 0) {
                        idx = this._buttonNodes.length - 1;
                    }
                    const node = this._buttonNodes[idx];
                    event.stopPropagation();
                    event.preventDefault();
                    node.focus();
                }
                break;
            }
            case 39: {
                // Right arrow
                const activeEl = document.activeElement;
                if (activeEl instanceof HTMLButtonElement) {
                    let idx = this._buttonNodes.indexOf(activeEl) + 1;
                    // Handle a right arrows on the last button
                    if (idx == this._buttons.length) {
                        idx = 0;
                    }
                    const node = this._buttonNodes[idx];
                    event.stopPropagation();
                    event.preventDefault();
                    node.focus();
                }
                break;
            }
            case 9: {
                // Tab.
                // Handle a tab on the last button.
                const node = this._buttonNodes[this._buttons.length - 1];
                if (document.activeElement === node && !event.shiftKey) {
                    event.stopPropagation();
                    event.preventDefault();
                    this._first.focus();
                }
                break;
            }
            case 13: {
                // Enter.
                event.stopPropagation();
                event.preventDefault();
                const activeEl = document.activeElement;
                if (activeEl instanceof HTMLButtonElement) {
                    const index = this._buttonNodes.indexOf(activeEl);
                    if (index !== -1) {
                        this.resolve(index);
                    }
                }
                else if (!(activeEl instanceof HTMLTextAreaElement)) {
                    const index = this._defaultButton;
                    this.resolve(index);
                }
                break;
            }
            default:
                break;
        }
    }
    /**
     * Handle the `'focus'` event for the widget.
     *
     * @param event - The DOM event sent to the widget
     */
    _evtFocus(event) {
        var _a;
        const target = event.target;
        if (!this.node.contains(target)) {
            event.stopPropagation();
            (_a = this._buttonNodes[this._defaultButton]) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }
    /**
     * Handle the `'mousedown'` event for the widget.
     *
     * @param event - The DOM event sent to the widget
     */
    _evtMouseDown(event) {
        const content = this.node.getElementsByClassName('jp-Dialog-content')[0];
        const target = event.target;
        this._lastMouseDownInDialog = content.contains(target);
    }
    /**
     * Resolve a button item.
     */
    _resolve(button) {
        var _a, _b, _c;
        if (this._hasValidationErrors && button.accept) {
            // Do not allow accepting with validation errors
            return;
        }
        // Prevent loopback.
        const promise = this._promise;
        if (!promise) {
            this.dispose();
            return;
        }
        this._promise = null;
        dist_index_es6_js_.ArrayExt.removeFirstOf(Private.launchQueue, promise.promise);
        const body = this._body;
        let value = null;
        if (button.accept &&
            body instanceof index_es6_js_.Widget &&
            typeof body.getValue === 'function') {
            value = body.getValue();
        }
        this.dispose();
        promise.resolve({
            button,
            isChecked: (_c = (_b = (_a = this._checkboxNode) === null || _a === void 0 ? void 0 : _a.querySelector('input')) === null || _b === void 0 ? void 0 : _b.checked) !== null && _c !== void 0 ? _c : null,
            value
        });
    }
}
/**
 * The namespace for Dialog class statics.
 */
(function (Dialog) {
    /**
     * Translator object.
     */
    Dialog.translator = lib_index_js_.nullTranslator;
    /**
     * Create a button item.
     */
    function createButton(value) {
        value.accept = value.accept !== false;
        const trans = Dialog.translator.load('jupyterlab');
        const defaultLabel = value.accept ? trans.__('Ok') : trans.__('Cancel');
        return {
            ariaLabel: value.ariaLabel || value.label || defaultLabel,
            label: value.label || defaultLabel,
            iconClass: value.iconClass || '',
            iconLabel: value.iconLabel || '',
            caption: value.caption || '',
            className: value.className || '',
            accept: value.accept,
            actions: value.actions || [],
            displayType: value.displayType || 'default'
        };
    }
    Dialog.createButton = createButton;
    /**
     * Create a reject button.
     */
    function cancelButton(options = {}) {
        options.accept = false;
        return createButton(options);
    }
    Dialog.cancelButton = cancelButton;
    /**
     * Create an accept button.
     */
    function okButton(options = {}) {
        options.accept = true;
        return createButton(options);
    }
    Dialog.okButton = okButton;
    /**
     * Create a warn button.
     */
    function warnButton(options = {}) {
        options.displayType = 'warn';
        return createButton(options);
    }
    Dialog.warnButton = warnButton;
    /**
     * Disposes all dialog instances.
     *
     * #### Notes
     * This function should only be used in tests or cases where application state
     * may be discarded.
     */
    function flush() {
        Dialog.tracker.forEach(dialog => {
            dialog.dispose();
        });
    }
    Dialog.flush = flush;
    /**
     * The default implementation of a dialog renderer.
     */
    class Renderer {
        /**
         * Create the header of the dialog.
         *
         * @param title - The title of the dialog.
         *
         * @returns A widget for the dialog header.
         */
        createHeader(title, reject = () => {
            /* empty */
        }, options = {}) {
            let header;
            const handleMouseDown = (event) => {
                // Fire action only when left button is pressed.
                if (event.button === 0) {
                    event.preventDefault();
                    reject();
                }
            };
            const handleKeyDown = (event) => {
                const { key } = event;
                if (key === 'Enter' || key === ' ') {
                    reject();
                }
            };
            if (typeof title === 'string') {
                const trans = Dialog.translator.load('jupyterlab');
                header = index_js_.ReactWidget.create(react_index_js_.createElement(react_index_js_.Fragment, null,
                    title,
                    options.hasClose && (react_index_js_.createElement(index_js_.Button, { className: "jp-Dialog-close-button", onMouseDown: handleMouseDown, onKeyDown: handleKeyDown, title: trans.__('Cancel'), minimal: true },
                        react_index_js_.createElement(index_js_.LabIcon.resolveReact, { icon: index_js_.closeIcon, tag: "span" })))));
            }
            else {
                header = index_js_.ReactWidget.create(title);
            }
            header.addClass('jp-Dialog-header');
            index_js_.Styling.styleNode(header.node);
            return header;
        }
        /**
         * Create the body of the dialog.
         *
         * @param value - The input value for the body.
         *
         * @returns A widget for the body.
         */
        createBody(value) {
            const styleReactWidget = (widget) => {
                if (widget.renderPromise !== undefined) {
                    widget.renderPromise
                        .then(() => {
                        index_js_.Styling.styleNode(widget.node);
                    })
                        .catch(() => {
                        console.error("Error while loading Dialog's body");
                    });
                }
                else {
                    index_js_.Styling.styleNode(widget.node);
                }
            };
            let body;
            if (typeof value === 'string') {
                body = new index_es6_js_.Widget({ node: document.createElement('span') });
                body.node.textContent = value;
            }
            else if (value instanceof index_es6_js_.Widget) {
                body = value;
                if (body instanceof index_js_.ReactWidget) {
                    styleReactWidget(body);
                }
                else {
                    index_js_.Styling.styleNode(body.node);
                }
            }
            else {
                body = index_js_.ReactWidget.create(value);
                // Immediately update the body even though it has not yet attached in
                // order to trigger a render of the DOM nodes from the React element.
                messaging_dist_index_es6_js_.MessageLoop.sendMessage(body, index_es6_js_.Widget.Msg.UpdateRequest);
                styleReactWidget(body);
            }
            body.addClass('jp-Dialog-body');
            return body;
        }
        /**
         * Create the footer of the dialog.
         *
         * @param buttons - The buttons nodes to add to the footer.
         * @param checkbox - The checkbox node to add to the footer.
         *
         * @returns A widget for the footer.
         */
        createFooter(buttons, checkbox) {
            const footer = new index_es6_js_.Widget();
            footer.addClass('jp-Dialog-footer');
            if (checkbox) {
                footer.node.appendChild(checkbox);
                footer.node.insertAdjacentHTML('beforeend', '<div class="jp-Dialog-spacer"></div>');
            }
            const footerButton = document.createElement('div');
            for (const button of buttons) {
                footerButton.appendChild(button);
            }
            footer.node.appendChild(footerButton);
            index_js_.Styling.styleNode(footer.node);
            return footer;
        }
        /**
         * Create a button node for the dialog.
         *
         * @param button - The button data.
         *
         * @returns A node for the button.
         */
        createButtonNode(button) {
            const e = document.createElement('button');
            e.className = this.createItemClass(button);
            e.appendChild(this.renderIcon(button));
            e.appendChild(this.renderLabel(button));
            return e;
        }
        /**
         * Create a checkbox node for the dialog.
         *
         * @param checkbox - The checkbox data.
         *
         * @returns A node for the checkbox.
         */
        createCheckboxNode(checkbox) {
            const e = document.createElement('label');
            e.className = 'jp-Dialog-checkbox';
            if (checkbox.className) {
                e.classList.add(checkbox.className);
            }
            e.title = checkbox.caption;
            e.textContent = checkbox.label;
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.checked = !!checkbox.checked;
            e.insertAdjacentElement('afterbegin', input);
            return e;
        }
        /**
         * Create the class name for the button.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the button.
         */
        createItemClass(data) {
            // Setup the initial class name.
            let name = 'jp-Dialog-button';
            // Add the other state classes.
            if (data.accept) {
                name += ' jp-mod-accept';
            }
            else {
                name += ' jp-mod-reject';
            }
            if (data.displayType === 'warn') {
                name += ' jp-mod-warn';
            }
            // Add the extra class.
            const extra = data.className;
            if (extra) {
                name += ` ${extra}`;
            }
            // Return the complete class name.
            return name;
        }
        /**
         * Render an icon element for a dialog item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns An HTML element representing the icon.
         */
        renderIcon(data) {
            const e = document.createElement('div');
            e.className = this.createIconClass(data);
            e.appendChild(document.createTextNode(data.iconLabel));
            return e;
        }
        /**
         * Create the class name for the button icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
            const name = 'jp-Dialog-buttonIcon';
            const extra = data.iconClass;
            return extra ? `${name} ${extra}` : name;
        }
        /**
         * Render the label element for a button.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns An HTML element representing the item label.
         */
        renderLabel(data) {
            const e = document.createElement('div');
            e.className = 'jp-Dialog-buttonLabel';
            e.title = data.caption;
            e.ariaLabel = data.ariaLabel;
            e.appendChild(document.createTextNode(data.label));
            return e;
        }
    }
    Dialog.Renderer = Renderer;
    /**
     * The default renderer instance.
     */
    Dialog.defaultRenderer = new Renderer();
    /**
     * The dialog widget tracker.
     */
    Dialog.tracker = new WidgetTracker({
        namespace: '@jupyterlab/apputils:Dialog'
    });
})(Dialog || (Dialog = {}));
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * The queue for launching dialogs.
     */
    Private.launchQueue = [];
    Private.errorMessagePromiseCache = new Map();
    /**
     * Handle the input options for a dialog.
     *
     * @param options - The input options.
     *
     * @returns A new options object with defaults applied.
     */
    function handleOptions(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const buttons = (_a = options.buttons) !== null && _a !== void 0 ? _a : [
            Dialog.cancelButton(),
            Dialog.okButton()
        ];
        return {
            title: (_b = options.title) !== null && _b !== void 0 ? _b : '',
            body: (_c = options.body) !== null && _c !== void 0 ? _c : '',
            host: (_d = options.host) !== null && _d !== void 0 ? _d : document.body,
            checkbox: (_e = options.checkbox) !== null && _e !== void 0 ? _e : null,
            buttons,
            defaultButton: (_f = options.defaultButton) !== null && _f !== void 0 ? _f : buttons.length - 1,
            renderer: (_g = options.renderer) !== null && _g !== void 0 ? _g : Dialog.defaultRenderer,
            focusNodeSelector: (_h = options.focusNodeSelector) !== null && _h !== void 0 ? _h : '',
            hasClose: (_j = options.hasClose) !== null && _j !== void 0 ? _j : true
        };
    }
    Private.handleOptions = handleOptions;
    /**
     *  Find the first focusable item in the dialog.
     */
    function findFirstFocusable(node) {
        const candidateSelectors = [
            'input',
            'select',
            'a[href]',
            'textarea',
            'button',
            '[tabindex]'
        ].join(',');
        return node.querySelectorAll(candidateSelectors)[0];
    }
    Private.findFirstFocusable = findFirstFocusable;
})(Private || (Private = {}));
//# sourceMappingURL=dialog.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/sessioncontext.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.








/**
 * The default implementation for a session context object.
 */
class SessionContext {
    /**
     * Construct a new session context.
     */
    constructor(options) {
        var _a, _b, _c, _d;
        this._path = '';
        this._name = '';
        this._type = '';
        this._prevKernelName = '';
        this._isDisposed = false;
        this._disposed = new signaling_dist_index_es6_js_.Signal(this);
        this._session = null;
        this._ready = new dist_index_js_.PromiseDelegate();
        this._initializing = false;
        this._initStarted = new dist_index_js_.PromiseDelegate();
        this._initPromise = new dist_index_js_.PromiseDelegate();
        this._isReady = false;
        this._isTerminating = false;
        this._isRestarting = false;
        this._kernelChanged = new signaling_dist_index_es6_js_.Signal(this);
        this._preferenceChanged = new signaling_dist_index_es6_js_.Signal(this);
        this._sessionChanged = new signaling_dist_index_es6_js_.Signal(this);
        this._statusChanged = new signaling_dist_index_es6_js_.Signal(this);
        this._connectionStatusChanged = new signaling_dist_index_es6_js_.Signal(this);
        this._pendingInput = false;
        this._iopubMessage = new signaling_dist_index_es6_js_.Signal(this);
        this._unhandledMessage = new signaling_dist_index_es6_js_.Signal(this);
        this._propertyChanged = new signaling_dist_index_es6_js_.Signal(this);
        this._dialog = null;
        this._busyDisposable = null;
        this._pendingKernelName = '';
        this._pendingSessionRequest = '';
        this.kernelManager = options.kernelManager;
        this.sessionManager = options.sessionManager;
        this.specsManager = options.specsManager;
        this.translator = options.translator || lib_index_js_.nullTranslator;
        this._trans = this.translator.load('jupyterlab');
        this._path = (_a = options.path) !== null && _a !== void 0 ? _a : dist_index_js_.UUID.uuid4();
        this._type = (_b = options.type) !== null && _b !== void 0 ? _b : '';
        this._name = (_c = options.name) !== null && _c !== void 0 ? _c : '';
        this._setBusy = options.setBusy;
        this._kernelPreference = (_d = options.kernelPreference) !== null && _d !== void 0 ? _d : {};
    }
    /**
     * The current session connection.
     */
    get session() {
        var _a;
        return (_a = this._session) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * The session path.
     *
     * #### Notes
     * Typically `.session.path` should be used. This attribute is useful if
     * there is no current session.
     */
    get path() {
        return this._path;
    }
    /**
     * The session type.
     *
     * #### Notes
     * Typically `.session.type` should be used. This attribute is useful if
     * there is no current session.
     */
    get type() {
        return this._type;
    }
    /**
     * The session name.
     *
     * #### Notes
     * Typically `.session.name` should be used. This attribute is useful if
     * there is no current session.
     */
    get name() {
        return this._name;
    }
    /**
     * A signal emitted when the kernel connection changes, proxied from the session connection.
     */
    get kernelChanged() {
        return this._kernelChanged;
    }
    /**
     * A signal emitted when the session connection changes.
     */
    get sessionChanged() {
        return this._sessionChanged;
    }
    /**
     * A signal emitted when the kernel status changes, proxied from the kernel.
     */
    get statusChanged() {
        return this._statusChanged;
    }
    /**
     * A flag indicating if the session has pending input, proxied from the kernel.
     */
    get pendingInput() {
        return this._pendingInput;
    }
    /**
     * A signal emitted when the kernel status changes, proxied from the kernel.
     */
    get connectionStatusChanged() {
        return this._connectionStatusChanged;
    }
    /**
     * A signal emitted for iopub kernel messages, proxied from the kernel.
     */
    get iopubMessage() {
        return this._iopubMessage;
    }
    /**
     * A signal emitted for an unhandled kernel message, proxied from the kernel.
     */
    get unhandledMessage() {
        return this._unhandledMessage;
    }
    /**
     * A signal emitted when a session property changes, proxied from the current session.
     */
    get propertyChanged() {
        return this._propertyChanged;
    }
    /**
     * The kernel preference of this client session.
     *
     * This is used when selecting a new kernel, and should reflect the sort of
     * kernel the activity prefers.
     */
    get kernelPreference() {
        return this._kernelPreference;
    }
    set kernelPreference(value) {
        if (!dist_index_js_.JSONExt.deepEqual(value, this._kernelPreference)) {
            const oldValue = this._kernelPreference;
            this._kernelPreference = value;
            this._preferenceChanged.emit({
                name: 'kernelPreference',
                oldValue,
                newValue: dist_index_js_.JSONExt.deepCopy(value)
            });
        }
    }
    /**
     * Signal emitted if the kernel preference changes.
     */
    get kernelPreferenceChanged() {
        return this._preferenceChanged;
    }
    /**
     * Whether the context is ready.
     */
    get isReady() {
        return this._isReady;
    }
    /**
     * A promise that is fulfilled when the context is ready.
     */
    get ready() {
        return this._ready.promise;
    }
    /**
     * Whether the context is terminating.
     */
    get isTerminating() {
        return this._isTerminating;
    }
    /**
     * Whether the context is restarting.
     */
    get isRestarting() {
        return this._isRestarting;
    }
    /**
     * Whether the kernel is "No Kernel" or not.
     *
     * #### Notes
     * As the displayed name is translated, this can be used directly.
     */
    get hasNoKernel() {
        return this.kernelDisplayName === this.noKernelName;
    }
    /**
     * The display name of the current kernel, or a sensible alternative.
     *
     * #### Notes
     * This is a convenience function to have a consistent sensible name for the
     * kernel.
     */
    get kernelDisplayName() {
        var _a, _b, _c, _d, _e, _f, _g;
        const kernel = (_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (this._pendingKernelName === this.noKernelName) {
            return this.noKernelName;
        }
        if (this._pendingKernelName) {
            return ((_d = (_c = (_b = this.specsManager.specs) === null || _b === void 0 ? void 0 : _b.kernelspecs[this._pendingKernelName]) === null || _c === void 0 ? void 0 : _c.display_name) !== null && _d !== void 0 ? _d : this._pendingKernelName);
        }
        if (!kernel) {
            return this.noKernelName;
        }
        return ((_g = (_f = (_e = this.specsManager.specs) === null || _e === void 0 ? void 0 : _e.kernelspecs[kernel.name]) === null || _f === void 0 ? void 0 : _f.display_name) !== null && _g !== void 0 ? _g : kernel.name);
    }
    /**
     * A sensible status to display
     *
     * #### Notes
     * This combines the status and connection status into a single status for
     * the user.
     */
    get kernelDisplayStatus() {
        var _a, _b;
        const kernel = (_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (this._isTerminating) {
            return 'terminating';
        }
        if (this._isRestarting) {
            return 'restarting';
        }
        if (this._pendingKernelName === this.noKernelName) {
            return 'unknown';
        }
        if (!kernel && this._pendingKernelName) {
            return 'initializing';
        }
        if (!kernel &&
            !this.isReady &&
            this.kernelPreference.canStart !== false &&
            this.kernelPreference.shouldStart !== false) {
            return 'initializing';
        }
        return ((_b = ((kernel === null || kernel === void 0 ? void 0 : kernel.connectionStatus) === 'connected'
            ? kernel === null || kernel === void 0 ? void 0 : kernel.status
            : kernel === null || kernel === void 0 ? void 0 : kernel.connectionStatus)) !== null && _b !== void 0 ? _b : 'unknown');
    }
    /**
     * The name of the previously started kernel.
     */
    get prevKernelName() {
        return this._prevKernelName;
    }
    /**
     * Test whether the context is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * A signal emitted when the poll is disposed.
     */
    get disposed() {
        return this._disposed;
    }
    /**
     * Get the constant displayed name for "No Kernel"
     */
    get noKernelName() {
        return this._trans.__('No Kernel');
    }
    /**
     * Dispose of the resources held by the context.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        if (this._session) {
            if (this.kernelPreference.shutdownOnDispose) {
                // Fire and forget the session shutdown request
                this.sessionManager.shutdown(this._session.id).catch(reason => {
                    console.error(`Kernel not shut down ${reason}`);
                });
            }
            // Dispose the session connection
            this._session.dispose();
            this._session = null;
        }
        if (this._dialog) {
            this._dialog.dispose();
        }
        if (this._busyDisposable) {
            this._busyDisposable.dispose();
            this._busyDisposable = null;
        }
        signaling_dist_index_es6_js_.Signal.clearData(this);
    }
    /**
     * Starts new Kernel.
     *
     * @returns Whether to ask the user to pick a kernel.
     */
    async startKernel() {
        const preference = this.kernelPreference;
        if (!preference.autoStartDefault && preference.shouldStart === false) {
            return true;
        }
        let options;
        if (preference.id) {
            options = { id: preference.id };
        }
        else {
            const name = sessioncontext_Private.getDefaultKernel({
                specs: this.specsManager.specs,
                sessions: this.sessionManager.running(),
                preference
            });
            if (name) {
                options = { name };
            }
        }
        if (options) {
            try {
                await this._changeKernel(options);
                return false;
            }
            catch (err) {
                /* no-op */
            }
        }
        // Always fall back to selecting a kernel
        return true;
    }
    /**
     * Restart the current Kernel.
     *
     * @returns A promise that resolves when the kernel is restarted.
     */
    async restartKernel() {
        var _a, _b, _c, _d, _e, _f;
        const kernel = ((_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel) || null;
        if (this._isRestarting) {
            return;
        }
        this._isRestarting = true;
        this._isReady = false;
        this._statusChanged.emit('restarting');
        try {
            await ((_c = (_b = this.session) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.restart());
            this._isReady = true;
        }
        catch (e) {
            console.error(e);
        }
        this._isRestarting = false;
        this._statusChanged.emit(((_e = (_d = this.session) === null || _d === void 0 ? void 0 : _d.kernel) === null || _e === void 0 ? void 0 : _e.status) || 'unknown');
        this._kernelChanged.emit({
            name: 'kernel',
            oldValue: kernel,
            newValue: ((_f = this.session) === null || _f === void 0 ? void 0 : _f.kernel) || null
        });
    }
    /**
     * Change the current kernel associated with the session.
     */
    async changeKernel(options = {}) {
        if (this.isDisposed) {
            throw new Error('Disposed');
        }
        // Wait for the initialization method to try
        // and start its kernel first to ensure consistent
        // ordering.
        await this._initStarted.promise;
        return this._changeKernel(options);
    }
    /**
     * Kill the kernel and shutdown the session.
     *
     * @returns A promise that resolves when the session is shut down.
     */
    async shutdown() {
        if (this.isDisposed || !this._initializing) {
            return;
        }
        await this._initStarted.promise;
        this._pendingSessionRequest = '';
        this._pendingKernelName = this.noKernelName;
        return this._shutdownSession();
    }
    /**
     * Initialize the session context
     *
     * @returns A promise that resolves with whether to ask the user to select a kernel.
     *
     * #### Notes
     * If a server session exists on the current path, we will connect to it.
     * If preferences include disabling `canStart` or `shouldStart`, no
     * server session will be started.
     * If a kernel id is given, we attempt to start a session with that id.
     * If a default kernel is available, we connect to it.
     * Otherwise we ask the user to select a kernel.
     */
    async initialize() {
        if (this._initializing) {
            return this._initPromise.promise;
        }
        this._initializing = true;
        const needsSelection = await this._initialize();
        if (!needsSelection) {
            this._isReady = true;
            this._ready.resolve(undefined);
        }
        if (!this._pendingSessionRequest) {
            this._initStarted.resolve(void 0);
        }
        this._initPromise.resolve(needsSelection);
        return needsSelection;
    }
    /**
     * Inner initialize function that doesn't handle promises.
     * This makes it easier to consolidate promise handling logic.
     */
    async _initialize() {
        const manager = this.sessionManager;
        await manager.ready;
        await manager.refreshRunning();
        const model = (0,dist_index_es6_js_.find)(manager.running(), item => {
            return item.path === this._path;
        });
        if (model) {
            try {
                const session = manager.connectTo({ model });
                this._handleNewSession(session);
            }
            catch (err) {
                void this._handleSessionError(err);
                return Promise.reject(err);
            }
        }
        return await this._startIfNecessary();
    }
    /**
     * Shut down the current session.
     */
    async _shutdownSession() {
        var _a;
        const session = this._session;
        // Capture starting values in case an error is raised.
        const isTerminating = this._isTerminating;
        const isReady = this._isReady;
        this._isTerminating = true;
        this._isReady = false;
        this._statusChanged.emit('terminating');
        try {
            await (session === null || session === void 0 ? void 0 : session.shutdown());
            this._isTerminating = false;
            session === null || session === void 0 ? void 0 : session.dispose();
            this._session = null;
            const kernel = (session === null || session === void 0 ? void 0 : session.kernel) || null;
            this._statusChanged.emit('unknown');
            this._kernelChanged.emit({
                name: 'kernel',
                oldValue: kernel,
                newValue: null
            });
            this._sessionChanged.emit({
                name: 'session',
                oldValue: session,
                newValue: null
            });
        }
        catch (err) {
            this._isTerminating = isTerminating;
            this._isReady = isReady;
            const status = (_a = session === null || session === void 0 ? void 0 : session.kernel) === null || _a === void 0 ? void 0 : _a.status;
            if (status === undefined) {
                this._statusChanged.emit('unknown');
            }
            else {
                this._statusChanged.emit(status);
            }
            throw err;
        }
        return;
    }
    /**
     * Start the session if necessary.
     *
     * @returns Whether to ask the user to pick a kernel.
     */
    async _startIfNecessary() {
        var _a;
        const preference = this.kernelPreference;
        if (this.isDisposed ||
            ((_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel) ||
            preference.shouldStart === false ||
            preference.canStart === false) {
            // Not necessary to start a kernel
            return false;
        }
        return this.startKernel();
    }
    /**
     * Change the kernel.
     */
    async _changeKernel(model = {}) {
        if (model.name) {
            this._pendingKernelName = model.name;
        }
        if (!this._session) {
            this._kernelChanged.emit({
                name: 'kernel',
                oldValue: null,
                newValue: null
            });
        }
        // Guarantee that the initialized kernel
        // will be started first.
        if (!this._pendingSessionRequest) {
            this._initStarted.resolve(void 0);
        }
        // If we already have a session, just change the kernel.
        if (this._session && !this._isTerminating) {
            try {
                await this._session.changeKernel(model);
                return this._session.kernel;
            }
            catch (err) {
                void this._handleSessionError(err);
                throw err;
            }
        }
        // Use a UUID for the path to overcome a race condition on the server
        // where it will re-use a session for a given path but only after
        // the kernel finishes starting.
        // We later switch to the real path below.
        // Use the correct directory so the kernel will be started in that directory.
        const dirName = coreutils_lib_index_js_.PathExt.dirname(this._path);
        const requestId = (this._pendingSessionRequest = coreutils_lib_index_js_.PathExt.join(dirName, dist_index_js_.UUID.uuid4()));
        try {
            this._statusChanged.emit('starting');
            const session = await this.sessionManager.startNew({
                path: requestId,
                type: this._type,
                name: this._name,
                kernel: model
            });
            // Handle a preempt.
            if (this._pendingSessionRequest !== session.path) {
                await session.shutdown();
                session.dispose();
                return null;
            }
            // Change to the real path.
            await session.setPath(this._path);
            // Update the name in case it has changed since we launched the session.
            await session.setName(this._name);
            if (this._session && !this._isTerminating) {
                await this._shutdownSession();
            }
            return this._handleNewSession(session);
        }
        catch (err) {
            void this._handleSessionError(err);
            throw err;
        }
    }
    /**
     * Handle a new session object.
     */
    _handleNewSession(session) {
        var _a, _b, _c;
        if (this.isDisposed) {
            throw Error('Disposed');
        }
        if (!this._isReady) {
            this._isReady = true;
            this._ready.resolve(undefined);
        }
        if (this._session) {
            this._session.dispose();
        }
        this._session = session;
        this._pendingKernelName = '';
        if (session) {
            this._prevKernelName = (_b = (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';
            session.disposed.connect(this._onSessionDisposed, this);
            session.propertyChanged.connect(this._onPropertyChanged, this);
            session.kernelChanged.connect(this._onKernelChanged, this);
            session.statusChanged.connect(this._onStatusChanged, this);
            session.connectionStatusChanged.connect(this._onConnectionStatusChanged, this);
            session.pendingInput.connect(this._onPendingInput, this);
            session.iopubMessage.connect(this._onIopubMessage, this);
            session.unhandledMessage.connect(this._onUnhandledMessage, this);
            if (session.path !== this._path) {
                this._onPropertyChanged(session, 'path');
            }
            if (session.name !== this._name) {
                this._onPropertyChanged(session, 'name');
            }
            if (session.type !== this._type) {
                this._onPropertyChanged(session, 'type');
            }
        }
        // Any existing session/kernel connection was disposed above when the session was
        // disposed, so the oldValue should be null.
        this._sessionChanged.emit({
            name: 'session',
            oldValue: null,
            newValue: session
        });
        this._kernelChanged.emit({
            oldValue: null,
            newValue: (session === null || session === void 0 ? void 0 : session.kernel) || null,
            name: 'kernel'
        });
        this._statusChanged.emit(((_c = session === null || session === void 0 ? void 0 : session.kernel) === null || _c === void 0 ? void 0 : _c.status) || 'unknown');
        return (session === null || session === void 0 ? void 0 : session.kernel) || null;
    }
    /**
     * Handle an error in session startup.
     */
    async _handleSessionError(err) {
        this._handleNewSession(null);
        let traceback = '';
        let message = '';
        try {
            traceback = err.traceback;
            message = err.message;
        }
        catch (err) {
            // no-op
        }
        await this._displayKernelError(message, traceback);
    }
    /**
     * Display kernel error
     */
    async _displayKernelError(message, traceback) {
        const body = (react_index_js_.createElement("div", null,
            message && react_index_js_.createElement("pre", null, message),
            traceback && (react_index_js_.createElement("details", { className: "jp-mod-wide" },
                react_index_js_.createElement("pre", null, traceback)))));
        const dialog = (this._dialog = new Dialog({
            title: this._trans.__('Error Starting Kernel'),
            body,
            buttons: [Dialog.okButton()]
        }));
        await dialog.launch();
        this._dialog = null;
    }
    /**
     * Handle a session termination.
     */
    _onSessionDisposed() {
        if (this._session) {
            const oldValue = this._session;
            this._session = null;
            const newValue = this._session;
            this._sessionChanged.emit({ name: 'session', oldValue, newValue });
        }
    }
    /**
     * Handle a change to a session property.
     */
    _onPropertyChanged(sender, property) {
        switch (property) {
            case 'path':
                this._path = sender.path;
                break;
            case 'name':
                this._name = sender.name;
                break;
            case 'type':
                this._type = sender.type;
                break;
            default:
                throw new Error(`unrecognized property ${property}`);
        }
        this._propertyChanged.emit(property);
    }
    /**
     * Handle a change to the kernel.
     */
    _onKernelChanged(sender, args) {
        this._kernelChanged.emit(args);
    }
    /**
     * Handle a change to the session status.
     */
    _onStatusChanged(sender, status) {
        var _a;
        if (status === 'dead') {
            const model = (_a = sender.kernel) === null || _a === void 0 ? void 0 : _a.model;
            if (model === null || model === void 0 ? void 0 : model.reason) {
                const traceback = model.traceback || '';
                void this._displayKernelError(model.reason, traceback);
            }
        }
        // Set that this kernel is busy, if we haven't already
        // If we have already, and now we aren't busy, dispose
        // of the busy disposable.
        if (this._setBusy) {
            if (status === 'busy') {
                if (!this._busyDisposable) {
                    this._busyDisposable = this._setBusy();
                }
            }
            else {
                if (this._busyDisposable) {
                    this._busyDisposable.dispose();
                    this._busyDisposable = null;
                }
            }
        }
        // Proxy the signal
        this._statusChanged.emit(status);
    }
    /**
     * Handle a change to the session status.
     */
    _onConnectionStatusChanged(sender, status) {
        // Proxy the signal
        this._connectionStatusChanged.emit(status);
    }
    /**
     * Handle a change to the pending input.
     */
    _onPendingInput(sender, value) {
        // Set the signal value
        this._pendingInput = value;
    }
    /**
     * Handle an iopub message.
     */
    _onIopubMessage(sender, message) {
        if (message.header.msg_type === 'shutdown_reply') {
            this.session.kernel.removeInputGuard();
        }
        this._iopubMessage.emit(message);
    }
    /**
     * Handle an unhandled message.
     */
    _onUnhandledMessage(sender, message) {
        this._unhandledMessage.emit(message);
    }
}
/**
 * A namespace for `SessionContext` statics.
 */
(function (SessionContext) {
    /**
     * Get the default kernel name given select options.
     */
    function getDefaultKernel(options) {
        const { preference } = options;
        const { shouldStart } = preference;
        if (shouldStart === false) {
            return null;
        }
        return sessioncontext_Private.getDefaultKernel(options);
    }
    SessionContext.getDefaultKernel = getDefaultKernel;
})(SessionContext || (SessionContext = {}));
/**
 * The default implementation of the client session dialog provider.
 */
class SessionContextDialogs {
    constructor(options = {}) {
        var _a;
        this._translator = (_a = options.translator) !== null && _a !== void 0 ? _a : lib_index_js_.nullTranslator;
        this._settingRegistry = options.settingRegistry || null;
    }
    /**
     * Select a kernel for the session.
     */
    async selectKernel(sessionContext) {
        if (sessionContext.isDisposed) {
            return Promise.resolve();
        }
        const translator = this._translator;
        const trans = translator.load('jupyterlab');
        // If there is no existing kernel, offer the option to keep no kernel.
        let label = trans.__('Cancel');
        if (sessionContext.hasNoKernel) {
            label = sessionContext.kernelDisplayName;
        }
        const buttons = [
            Dialog.cancelButton({ label }),
            Dialog.okButton({
                label: trans.__('Select'),
                ariaLabel: trans.__('Select Kernel')
            })
        ];
        const autoStartDefault = sessionContext.kernelPreference.autoStartDefault;
        const hasCheckbox = typeof autoStartDefault === 'boolean';
        const dialog = new Dialog({
            title: trans.__('Select Kernel'),
            body: sessioncontext_Private.createKernelSelector(sessionContext, translator),
            buttons,
            checkbox: hasCheckbox
                ? {
                    label: trans.__('Always start the preferred kernel'),
                    caption: trans.__('Remember my choice and always start the preferred kernel'),
                    checked: autoStartDefault
                }
                : null
        });
        const result = await dialog.launch();
        if (sessionContext.isDisposed || !result.button.accept) {
            return;
        }
        if (hasCheckbox && result.isChecked !== null) {
            sessionContext.kernelPreference = {
                ...sessionContext.kernelPreference,
                autoStartDefault: result.isChecked
            };
        }
        const model = result.value;
        if (model === null && !sessionContext.hasNoKernel) {
            return sessionContext.shutdown();
        }
        if (model) {
            await sessionContext.changeKernel(model);
        }
    }
    /**
     * Restart the session.
     *
     * @returns A promise that resolves with whether the kernel has restarted.
     *
     * #### Notes
     * If there is a running kernel, present a dialog.
     * If there is no kernel, we start a kernel with the last run
     * kernel name and resolves with `true`.
     */
    async restart(sessionContext) {
        var _a, _b, _c, _d, _e;
        const trans = this._translator.load('jupyterlab');
        await sessionContext.initialize();
        if (sessionContext.isDisposed) {
            throw new Error('session already disposed');
        }
        const kernel = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel && sessionContext.prevKernelName) {
            await sessionContext.changeKernel({
                name: sessionContext.prevKernelName
            });
            return true;
        }
        // Bail if there is no previous kernel to start.
        if (!kernel) {
            throw new Error('No kernel to restart');
        }
        // Skip the dialog and restart the kernel
        const kernelPluginId = '@jupyterlab/apputils-extension:sessionDialogs';
        const skipKernelRestartDialog = (_c = (_b = sessionContext.kernelPreference) === null || _b === void 0 ? void 0 : _b.skipKernelRestartDialog) !== null && _c !== void 0 ? _c : false;
        const skipKernelRestartDialogSetting = (_e = (await ((_d = this._settingRegistry) === null || _d === void 0 ? void 0 : _d.get(kernelPluginId, 'skipKernelRestartDialog')))) === null || _e === void 0 ? void 0 : _e.composite;
        if (skipKernelRestartDialogSetting || skipKernelRestartDialog) {
            await sessionContext.restartKernel();
            return true;
        }
        const restartBtn = Dialog.warnButton({
            label: trans.__('Restart'),
            ariaLabel: trans.__('Confirm Kernel Restart')
        });
        const result = await showDialog({
            title: trans.__('Restart Kernel?'),
            body: trans.__('Do you want to restart the kernel of %1? All variables will be lost.', sessionContext.name),
            buttons: [
                Dialog.cancelButton({ ariaLabel: trans.__('Cancel Kernel Restart') }),
                restartBtn
            ],
            checkbox: {
                label: trans.__('Do not ask me again.'),
                caption: trans.__('If checked, the kernel will restart without confirmation prompt in the future; you can change this back in the settings.')
            }
        });
        if (kernel.isDisposed) {
            return false;
        }
        if (result.button.accept) {
            if (typeof result.isChecked === 'boolean' && result.isChecked == true) {
                sessionContext.kernelPreference = {
                    ...sessionContext.kernelPreference,
                    skipKernelRestartDialog: true
                };
            }
            await sessionContext.restartKernel();
            return true;
        }
        return false;
    }
}
(function (SessionContextDialogs) {
    /**
     * Returns available kernel options grouped based on session context.
     *
     * #### Notes
     * If a language preference is set in the given session context, the options
     * returned are grouped with the language preference at the top:
     *
     *  - (Start %1 Kernel, language)
     *    - { all kernelspecs whose language matches in alphabetical order }
     *  - (Use No Kernel)
     *    - `No Kernel`
     *  - (Start Kernel)
     *    - { all other kernelspecs in alphabetical order }
     *  - (Connect to Existing %1 Kernel, language)
     *    - { all running kernels whose language matches in alphabetical order }
     *  - (Connect to Kernel)
     *    - { all other running kernels in alphabetical order }
     *
     * If no language preference is set, these groups and options are returned:
     *
     *  - (Start Kernel)
     *    - { all kernelspecs in alphabetical order }
     *  - (Use No Kernel)
     *    - `No Kernel`
     *  - (Connect to Existing Kernel)
     *    - { all running kernels in alphabetical order  }
     *
     * If the session has a kernel ID and a kernel exists with that id, its
     * corresponding option has `selected` set to `true`. Otherwise if the session
     * context language preference is set, the first kernelspec that matches it is
     * selected.
     */
    function kernelOptions(sessionContext, translator = null) {
        var _a, _b, _c, _d, _e, _f, _g;
        const options = { disabled: false, groups: [] };
        // Create mapping of sessions and kernel ids.
        const kernels = Array.from((_b = (_a = sessionContext.kernelManager) === null || _a === void 0 ? void 0 : _a.running()) !== null && _b !== void 0 ? _b : 
        // If kernel manager is unavailable use kernels from running sessions.
        // TODO: Remove this (next version) when kernel manager is guaranteed.
        Array.from(sessionContext.sessionManager.running())
            .filter(session => !!session.kernel)
            .map(session => session.kernel));
        const sessions = Array.from((_c = sessionContext.sessionManager.running()) !== null && _c !== void 0 ? _c : []).reduce((sessions, session) => {
            var _a;
            if ((_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id)
                sessions[session.kernel.id] = session;
            return sessions;
        }, {});
        const preference = {
            ...sessionContext.kernelPreference,
            id: (_e = (_d = sessionContext.session) === null || _d === void 0 ? void 0 : _d.kernel) === null || _e === void 0 ? void 0 : _e.id
        };
        const currentKernelDisplayName = !sessionContext.hasNoKernel
            ? sessionContext.kernelDisplayName
            : null;
        const specs = {
            default: '',
            kernelspecs: Object.create(null),
            ...sessionContext.specsManager.specs
        };
        // Create mapping of languages and kernel names.
        const sorted = [];
        const languages = Object.create(null);
        for (const name in specs.kernelspecs) {
            sorted.push(specs.kernelspecs[name]);
            languages[name] = specs.kernelspecs[name].language;
        }
        sorted.sort((a, b) => a.display_name.localeCompare(b.display_name));
        translator = translator || lib_index_js_.nullTranslator;
        const trans = translator.load('jupyterlab');
        const language = preference.language ||
            languages[preference.name] ||
            (preference.id ? languages[(_f = sessions[preference.id]) === null || _f === void 0 ? void 0 : _f.name] : '');
        const labels = {
            connectKernel: trans.__('Connect to Existing Kernel'),
            startPreferred: trans.__('Start %1 Kernel', language),
            startOther: trans.__('Start Kernel'),
            connectToPreferred: trans.__('Connect to Existing %1 Kernel', language),
            connectToOther: trans.__('Connect to Other Kernel'),
            noKernel: trans.__('No Kernel'),
            startKernel: trans.__('Start Kernel'),
            useNoKernel: trans.__('Use No Kernel')
        };
        const noKernel = {
            label: labels.useNoKernel,
            options: [
                {
                    text: labels.noKernel,
                    title: labels.noKernel,
                    value: JSON.stringify(null)
                }
            ]
        };
        const optionForKernel = (kernel, displayName, session) => {
            const sessionName = session
                ? session.name || coreutils_lib_index_js_.PathExt.basename(session.path)
                : kernel.name || trans.__('Unknown Kernel');
            return {
                text: `${sessionName} (${kernel.id.split('-')[0]})`,
                title: (session ? `${trans.__('Path: %1', session.path)}\n` : ``) +
                    `${trans.__('Name: %1', sessionName)}\n` +
                    `${trans.__('Kernel Name: %1', displayName !== null && displayName !== void 0 ? displayName : kernel.name)}\n` +
                    `${trans.__('Kernel Id: %1', kernel.id)}`,
                value: JSON.stringify({ id: kernel.id })
            };
        };
        const optionForSpec = (spec) => ({
            text: spec.display_name,
            value: JSON.stringify({ name: spec.name })
        });
        // If a kernel cannot be started, bail.
        if (preference.canStart === false) {
            options.disabled = true;
            options.groups.push(noKernel);
            return options;
        }
        // Create kernel option groups based on whether language preference exists.
        if (language) {
            // Add all kernelspecs, separating out the preferred language first.
            const preferred = {
                label: labels.startPreferred,
                options: []
            };
            const other = {
                label: labels.startOther,
                options: []
            };
            const preferredRunning = {
                label: labels.connectToPreferred,
                options: []
            };
            const otherRunning = {
                label: labels.connectToOther,
                options: []
            };
            for (const spec of sorted) {
                (spec.language === language ? preferred : other).options.push(optionForSpec(spec));
            }
            options.groups.push(preferred);
            options.groups.push(noKernel);
            options.groups.push(other);
            kernels
                .map(kernel => {
                var _a, _b;
                return ({
                    option: optionForKernel(kernel, (_b = (_a = specs.kernelspecs[kernel.name]) === null || _a === void 0 ? void 0 : _a.display_name) !== null && _b !== void 0 ? _b : '', sessions[kernel.id]),
                    language: languages[kernel.name]
                });
            })
                .sort((a, b) => a.option.text.localeCompare(b.option.text))
                .forEach(kernel => (language === kernel.language
                ? preferredRunning
                : otherRunning).options.push(kernel.option));
            if (preferredRunning.options.length)
                options.groups.push(preferredRunning);
            if (otherRunning.options.length)
                options.groups.push(otherRunning);
        }
        else {
            // Add kernelspecs first.
            options.groups.push({
                label: labels.startKernel,
                options: sorted.map(spec => optionForSpec(spec))
            });
            // Next add the no kernel option.
            options.groups.push(noKernel);
            // Add running kernels.
            options.groups.push({
                label: labels.connectKernel,
                options: kernels
                    .map(kernel => {
                    var _a, _b;
                    return optionForKernel(kernel, (_b = (_a = specs.kernelspecs[kernel.name]) === null || _a === void 0 ? void 0 : _a.display_name) !== null && _b !== void 0 ? _b : '', sessions[kernel.id]);
                })
                    .sort((a, b) => a.text.localeCompare(b.text))
            });
        }
        // Set the selected option.
        if (preference.id || currentKernelDisplayName || preference.name) {
            for (const group of options.groups) {
                for (const option of group.options) {
                    const choice = JSON.parse(option.value);
                    if (!choice)
                        continue;
                    if (preference.id) {
                        if (preference.id === choice.id) {
                            option.selected = true;
                            return options;
                        }
                        continue;
                    }
                    if (currentKernelDisplayName) {
                        if (currentKernelDisplayName ===
                            ((_g = specs.kernelspecs[choice.name]) === null || _g === void 0 ? void 0 : _g.display_name)) {
                            option.selected = true;
                            return options;
                        }
                        continue;
                    }
                    if (preference.name) {
                        if (preference.name === choice.name) {
                            option.selected = true;
                            return options;
                        }
                        continue;
                    }
                }
            }
        }
        return options;
    }
    SessionContextDialogs.kernelOptions = kernelOptions;
})(SessionContextDialogs || (SessionContextDialogs = {}));
/**
 * The namespace for module private data.
 */
var sessioncontext_Private;
(function (Private) {
    /**
     * Return a kernel selector widget.
     */
    Private.createKernelSelector = (sessionContext, translator) => new KernelSelector({
        node: createSelectorNode(sessionContext, translator)
    });
    /**
     * A widget that provides a kernel selection.
     */
    class KernelSelector extends index_es6_js_.Widget {
        /**
         * Get the value of the kernel selector widget.
         */
        getValue() {
            const selector = this.node.querySelector('select');
            return JSON.parse(selector.value);
        }
    }
    /**
     * Create an HTML node for a kernel selector widget.
     */
    function createSelectorNode(sessionContext, translator) {
        // Create the dialog body.
        translator = translator || lib_index_js_.nullTranslator;
        const trans = translator.load('jupyterlab');
        const body = document.createElement('div');
        const text = document.createElement('label');
        text.textContent = `${trans.__('Select kernel for:')} "${sessionContext.name}"`;
        body.appendChild(text);
        const select = document.createElement('select');
        const options = SessionContextDialogs.kernelOptions(sessionContext, translator);
        if (options.disabled)
            select.disabled = true;
        for (const group of options.groups) {
            const { label, options } = group;
            const optgroup = document.createElement('optgroup');
            optgroup.label = label;
            for (const { selected, text, title, value } of options) {
                const option = document.createElement('option');
                if (selected)
                    option.selected = true;
                if (title)
                    option.title = title;
                option.text = text;
                option.value = value;
                optgroup.appendChild(option);
            }
            select.appendChild(optgroup);
        }
        body.appendChild(select);
        return body;
    }
    /**
     * Get the default kernel name given select options.
     */
    function getDefaultKernel(options) {
        var _a;
        const { specs, preference } = options;
        const { name, language, canStart, autoStartDefault } = preference;
        if (!specs || canStart === false) {
            return null;
        }
        const defaultName = autoStartDefault ? specs.default : null;
        if (!name && !language) {
            return defaultName;
        }
        // Look for an exact match of a spec name.
        for (const specName in specs.kernelspecs) {
            if (specName === name) {
                return name;
            }
        }
        // Bail if there is no language.
        if (!language) {
            return defaultName;
        }
        // Check for a single kernel matching the language.
        const matches = [];
        for (const specName in specs.kernelspecs) {
            const kernelLanguage = (_a = specs.kernelspecs[specName]) === null || _a === void 0 ? void 0 : _a.language;
            if (language === kernelLanguage) {
                matches.push(specName);
            }
        }
        if (matches.length === 1) {
            const specName = matches[0];
            console.warn('No exact match found for ' +
                specName +
                ', using kernel ' +
                specName +
                ' that matches ' +
                'language=' +
                language);
            return specName;
        }
        // No matches found.
        return defaultName;
    }
    Private.getDefaultKernel = getDefaultKernel;
})(sessioncontext_Private || (sessioncontext_Private = {}));
//# sourceMappingURL=sessioncontext.js.map
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/statusbar@~4.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/statusbar/lib/index.js)
var statusbar_lib_index_js_ = __webpack_require__(98338);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/kernelstatuses.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





/**
 * Helper function to translate kernel statuses mapping by using
 * input translator.
 *
 * @param translator - Language translator.
 * @return The translated kernel status mapping.
 */
function translateKernelStatuses(translator) {
    translator = translator || lib_index_js_.nullTranslator;
    const trans = translator.load('jupyterlab');
    const translated = {
        unknown: trans.__('Unknown'),
        starting: trans.__('Starting'),
        idle: trans.__('Idle'),
        busy: trans.__('Busy'),
        terminating: trans.__('Terminating'),
        restarting: trans.__('Restarting'),
        autorestarting: trans.__('Autorestarting'),
        dead: trans.__('Dead'),
        connected: trans.__('Connected'),
        connecting: trans.__('Connecting'),
        disconnected: trans.__('Disconnected'),
        initializing: trans.__('Initializing'),
        '': ''
    };
    return translated;
}
/**
 * A pure functional component for rendering kernel status.
 */
function KernelStatusComponent(props) {
    const translator = props.translator || lib_index_js_.nullTranslator;
    const trans = translator.load('jupyterlab');
    let statusText = '';
    if (props.status) {
        statusText = ` | ${props.status}`;
    }
    return (react_index_js_default().createElement(statusbar_lib_index_js_.TextItem, { onClick: props.handleClick, onKeyDown: props.handleKeyDown, source: `${props.kernelName}${statusText}`, title: trans.__('Change kernel for %1', props.activityName), tabIndex: 0 }));
}
/**
 * A VDomRenderer widget for displaying the status of a kernel.
 */
class KernelStatus extends index_js_.VDomRenderer {
    /**
     * Construct the kernel status widget.
     */
    constructor(opts, translator) {
        super(new KernelStatus.Model(translator));
        this.translator = translator || lib_index_js_.nullTranslator;
        this._handleClick = opts.onClick;
        this._handleKeyDown = opts.onKeyDown;
        this.addClass('jp-mod-highlighted');
    }
    /**
     * Render the kernel status item.
     */
    render() {
        if (this.model === null) {
            return null;
        }
        else {
            return (react_index_js_default().createElement(KernelStatusComponent, { status: this.model.status, kernelName: this.model.kernelName, activityName: this.model.activityName, handleClick: this._handleClick, handleKeyDown: this._handleKeyDown, translator: this.translator }));
        }
    }
}
/**
 * A namespace for KernelStatus statics.
 */
(function (KernelStatus) {
    /**
     * A VDomModel for the kernel status indicator.
     */
    class Model extends index_js_.VDomModel {
        constructor(translator) {
            super();
            this._activityName = '';
            this._kernelName = '';
            this._kernelStatus = '';
            this._sessionContext = null;
            translator = translator !== null && translator !== void 0 ? translator : lib_index_js_.nullTranslator;
            this._trans = translator.load('jupyterlab');
            this._statusNames = translateKernelStatuses(translator);
        }
        /**
         * The name of the kernel.
         */
        get kernelName() {
            return this._kernelName;
        }
        /**
         * The current status of the kernel.
         */
        get status() {
            return this._kernelStatus
                ? this._statusNames[this._kernelStatus]
                : undefined;
        }
        /**
         * A display name for the activity.
         */
        get activityName() {
            return this._activityName;
        }
        set activityName(val) {
            const oldVal = this._activityName;
            if (oldVal === val) {
                return;
            }
            this._activityName = val;
            this.stateChanged.emit();
        }
        /**
         * The current client session associated with the kernel status indicator.
         */
        get sessionContext() {
            return this._sessionContext;
        }
        set sessionContext(sessionContext) {
            var _a, _b, _c, _d;
            (_a = this._sessionContext) === null || _a === void 0 ? void 0 : _a.statusChanged.disconnect(this._onKernelStatusChanged, this);
            (_b = this._sessionContext) === null || _b === void 0 ? void 0 : _b.connectionStatusChanged.disconnect(this._onKernelStatusChanged, this);
            (_c = this._sessionContext) === null || _c === void 0 ? void 0 : _c.kernelChanged.disconnect(this._onKernelChanged, this);
            const oldState = this._getAllState();
            this._sessionContext = sessionContext;
            this._kernelStatus = sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelDisplayStatus;
            this._kernelName =
                (_d = sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelDisplayName) !== null && _d !== void 0 ? _d : this._trans.__('No Kernel');
            sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.statusChanged.connect(this._onKernelStatusChanged, this);
            sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.connectionStatusChanged.connect(this._onKernelStatusChanged, this);
            sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelChanged.connect(this._onKernelChanged, this);
            this._triggerChange(oldState, this._getAllState());
        }
        /**
         * React to changes to the kernel status.
         */
        _onKernelStatusChanged() {
            var _a;
            this._kernelStatus = (_a = this._sessionContext) === null || _a === void 0 ? void 0 : _a.kernelDisplayStatus;
            this.stateChanged.emit(void 0);
        }
        /**
         * React to changes in the kernel.
         */
        _onKernelChanged(_sessionContext, change) {
            var _a;
            const oldState = this._getAllState();
            // sync setting of status and display name
            this._kernelStatus = (_a = this._sessionContext) === null || _a === void 0 ? void 0 : _a.kernelDisplayStatus;
            this._kernelName = _sessionContext.kernelDisplayName;
            this._triggerChange(oldState, this._getAllState());
        }
        _getAllState() {
            return [this._kernelName, this._kernelStatus, this._activityName];
        }
        _triggerChange(oldState, newState) {
            if (dist_index_js_.JSONExt.deepEqual(oldState, newState)) {
                this.stateChanged.emit(void 0);
            }
        }
    }
    KernelStatus.Model = Model;
})(KernelStatus || (KernelStatus = {}));
//# sourceMappingURL=kernelstatuses.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/toolbar/widget.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






/**
 * The class name added to toolbar kernel name text.
 */
const TOOLBAR_KERNEL_NAME_CLASS = 'jp-Toolbar-kernelName';
/**
 * The class name added to toolbar kernel status icon.
 */
const TOOLBAR_KERNEL_STATUS_CLASS = 'jp-Toolbar-kernelStatus';
/**
 * The namespace for Toolbar class statics.
 */
var widget_Toolbar;
(function (Toolbar) {
    /**
     * Create an interrupt toolbar item.
     *
     * @deprecated since version v3.2
     * This is dead code now.
     */
    function createInterruptButton(sessionContext, translator) {
        translator = translator || lib_index_js_.nullTranslator;
        const trans = translator.load('jupyterlab');
        return new index_js_.ToolbarButton({
            icon: index_js_.stopIcon,
            onClick: () => {
                var _a, _b;
                void ((_b = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.interrupt());
            },
            tooltip: trans.__('Interrupt the kernel')
        });
    }
    Toolbar.createInterruptButton = createInterruptButton;
    /**
     * Create a restart toolbar item.
     *
     * @deprecated since v3.2
     * This is dead code now.
     */
    function createRestartButton(sessionContext, dialogs, translator) {
        translator = translator !== null && translator !== void 0 ? translator : lib_index_js_.nullTranslator;
        const trans = translator.load('jupyterlab');
        return new index_js_.ToolbarButton({
            icon: index_js_.refreshIcon,
            onClick: () => {
                void (dialogs !== null && dialogs !== void 0 ? dialogs : new SessionContextDialogs({ translator })).restart(sessionContext);
            },
            tooltip: trans.__('Restart the kernel')
        });
    }
    Toolbar.createRestartButton = createRestartButton;
    /**
     * Create a kernel name indicator item.
     *
     * #### Notes
     * It will display the `'display_name`' of the session context. It can
     * handle a change in context or kernel.
     */
    function createKernelNameItem(sessionContext, dialogs, translator) {
        const el = index_js_.ReactWidget.create(react_index_js_.createElement(widget_Private.KernelNameComponent, { sessionContext: sessionContext, dialogs: dialogs !== null && dialogs !== void 0 ? dialogs : new SessionContextDialogs({ translator }), translator: translator }));
        el.addClass('jp-KernelName');
        return el;
    }
    Toolbar.createKernelNameItem = createKernelNameItem;
    /**
     * Create a kernel status indicator item.
     *
     * @deprecated since v3.5
     * The kernel status indicator is now replaced by the execution status indicator.
     *
     * #### Notes
     * It will show a busy status if the kernel status is busy.
     * It will show the current status in the node title.
     * It can handle a change to the context or the kernel.
     */
    function createKernelStatusItem(sessionContext, translator) {
        return new widget_Private.KernelStatus(sessionContext, translator);
    }
    Toolbar.createKernelStatusItem = createKernelStatusItem;
})(widget_Toolbar || (widget_Toolbar = {}));
/**
 * A namespace for private data.
 */
var widget_Private;
(function (Private) {
    /**
     * React component for a kernel name button.
     *
     * This wraps the ToolbarButtonComponent and watches the kernel
     * session for changes.
     */
    function KernelNameComponent(props) {
        const translator = props.translator || lib_index_js_.nullTranslator;
        const trans = translator.load('jupyterlab');
        const callback = () => {
            void props.dialogs.selectKernel(props.sessionContext);
        };
        return (react_index_js_.createElement(index_js_.UseSignal, { signal: props.sessionContext.kernelChanged, initialSender: props.sessionContext }, sessionContext => (react_index_js_.createElement(index_js_.ToolbarButtonComponent, { className: TOOLBAR_KERNEL_NAME_CLASS, onClick: callback, tooltip: trans.__('Switch kernel'), label: sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelDisplayName }))));
    }
    Private.KernelNameComponent = KernelNameComponent;
    /**
     * A toolbar item that displays kernel status.
     *
     * @deprecated This code is not use any longer and will be removed in JupyterLab 5
     */
    class KernelStatus extends index_es6_js_.Widget {
        /**
         * Construct a new kernel status widget.
         */
        constructor(sessionContext, translator) {
            super();
            this.translator = translator || lib_index_js_.nullTranslator;
            this._trans = this.translator.load('jupyterlab');
            this.addClass(TOOLBAR_KERNEL_STATUS_CLASS);
            this._statusNames = translateKernelStatuses(this.translator);
            this._onStatusChanged(sessionContext);
            sessionContext.statusChanged.connect(this._onStatusChanged, this);
            sessionContext.connectionStatusChanged.connect(this._onStatusChanged, this);
        }
        /**
         * Handle a status on a kernel.
         */
        _onStatusChanged(sessionContext) {
            if (this.isDisposed) {
                return;
            }
            const status = sessionContext.kernelDisplayStatus;
            const circleIconProps = {
                container: this.node,
                title: this._trans.__('Kernel %1', this._statusNames[status] || status),
                stylesheet: 'toolbarButton',
                alignSelf: 'normal',
                height: '24px'
            };
            // set the icon
            index_js_.LabIcon.remove(this.node);
            if (status === 'busy' ||
                status === 'starting' ||
                status === 'terminating' ||
                status === 'restarting' ||
                status === 'initializing') {
                index_js_.circleIcon.element(circleIconProps);
            }
            else if (status === 'connecting' ||
                status === 'disconnected' ||
                status === 'unknown') {
                index_js_.offlineBoltIcon.element(circleIconProps);
            }
            else {
                index_js_.circleEmptyIcon.element(circleIconProps);
            }
        }
    }
    Private.KernelStatus = KernelStatus;
})(widget_Private || (widget_Private = {}));
//# sourceMappingURL=widget.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/clipboard.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * The clipboard interface.
 */
var Clipboard;
(function (Clipboard) {
    /**
     * Get the application clipboard instance.
     */
    function getInstance() {
        return clipboard_Private.instance;
    }
    Clipboard.getInstance = getInstance;
    /**
     * Set the application clipboard instance.
     */
    function setInstance(value) {
        clipboard_Private.instance = value;
    }
    Clipboard.setInstance = setInstance;
    /**
     * Copy text to the system clipboard.
     *
     * #### Notes
     * This can only be called in response to a user input event.
     */
    function copyToSystem(clipboardData) {
        const node = document.body;
        const handler = (event) => {
            const data = event.clipboardData || window.clipboardData;
            if (typeof clipboardData === 'string') {
                data.setData('text', clipboardData);
            }
            else {
                clipboardData.types().map((mimeType) => {
                    data.setData(mimeType, clipboardData.getData(mimeType));
                });
            }
            event.preventDefault();
            node.removeEventListener('copy', handler);
        };
        node.addEventListener('copy', handler);
        generateEvent(node);
    }
    Clipboard.copyToSystem = copyToSystem;
    /**
     * Generate a clipboard event on a node.
     *
     * @param node - The element on which to generate the event.
     *
     * @param type - The type of event to generate.
     *   `'paste'` events cannot be programmatically generated.
     *
     * #### Notes
     * This can only be called in response to a user input event.
     */
    function generateEvent(node, type = 'copy') {
        // http://stackoverflow.com/a/5210367
        // Identify selected text.
        let sel = window.getSelection();
        // Save the current selection.
        const savedRanges = [];
        for (let i = 0, len = (sel === null || sel === void 0 ? void 0 : sel.rangeCount) || 0; i < len; ++i) {
            savedRanges[i] = sel.getRangeAt(i).cloneRange();
        }
        // Select the node content.
        const range = document.createRange();
        range.selectNodeContents(node);
        if (sel) {
            sel.removeAllRanges();
            sel.addRange(range);
        }
        // Execute the command.
        document.execCommand(type);
        // Restore the previous selection.
        sel = window.getSelection();
        if (sel) {
            sel.removeAllRanges();
            for (let i = 0, len = savedRanges.length; i < len; ++i) {
                sel.addRange(savedRanges[i]);
            }
        }
    }
    Clipboard.generateEvent = generateEvent;
})(Clipboard || (Clipboard = {}));
/**
 * The namespace for module private data.
 */
var clipboard_Private;
(function (Private) {
    /**
     * The application clipboard instance.
     */
    Private.instance = new dist_index_js_.MimeData();
})(clipboard_Private || (clipboard_Private = {}));
//# sourceMappingURL=clipboard.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/commandlinker.js
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * The command data attribute added to nodes that are connected.
 */
const COMMAND_ATTR = 'commandlinker-command';
/**
 * The args data attribute added to nodes that are connected.
 */
const ARGS_ATTR = 'commandlinker-args';
/**
 * A static class that provides helper methods to generate clickable nodes that
 * execute registered commands with pre-populated arguments.
 */
class CommandLinker {
    /**
     * Instantiate a new command linker.
     */
    constructor(options) {
        this._isDisposed = false;
        this._commands = options.commands;
        document.body.addEventListener('click', this);
    }
    /**
     * Test whether the linker is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Dispose of the resources held by the linker.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        document.body.removeEventListener('click', this);
    }
    /**
     * Connect a command/argument pair to a given node so that when it is clicked,
     * the command will execute.
     *
     * @param node - The node being connected.
     *
     * @param command - The command ID to execute upon click.
     *
     * @param args - The arguments with which to invoke the command.
     *
     * @returns The same node that was passed in, after it has been connected.
     *
     * #### Notes
     * Only `click` events will execute the command on a connected node. So, there
     * are two considerations that are relevant:
     * 1. If a node is connected, the default click action will be prevented.
     * 2. The `HTMLElement` passed in should be clickable.
     */
    connectNode(node, command, args) {
        node.setAttribute(`data-${COMMAND_ATTR}`, command);
        if (args !== void 0) {
            node.setAttribute(`data-${ARGS_ATTR}`, JSON.stringify(args));
        }
        return node;
    }
    /**
     * Disconnect a node that has been connected to execute a command on click.
     *
     * @param node - The node being disconnected.
     *
     * @returns The same node that was passed in, after it has been disconnected.
     *
     * #### Notes
     * This method is safe to call multiple times and is safe to call on nodes
     * that were never connected.
     *
     * This method can be called on rendered virtual DOM nodes that were populated
     * using the `populateVNodeDataset` method in order to disconnect them from
     * executing their command/argument pair.
     */
    disconnectNode(node) {
        node.removeAttribute(`data-${COMMAND_ATTR}`);
        node.removeAttribute(`data-${ARGS_ATTR}`);
        return node;
    }
    /**
     * Handle the DOM events for the command linker helper class.
     *
     * @param event - The DOM event sent to the class.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the panel's DOM node. It should
     * not be called directly by user code.
     */
    handleEvent(event) {
        switch (event.type) {
            case 'click':
                this._evtClick(event);
                break;
            default:
                return;
        }
    }
    /**
     * Populate the `dataset` attribute within the collection of attributes used
     * to instantiate a virtual DOM node with the values necessary for its
     * rendered DOM node to respond to clicks by executing a command/argument
     * pair.
     *
     * @param command - The command ID to execute upon click.
     *
     * @param args - The arguments with which to invoke the command.
     *
     * @returns A `dataset` collection for use within virtual node attributes.
     *
     * #### Notes
     * The return value can be used on its own as the value for the `dataset`
     * attribute of a virtual element, or it can be added to an existing `dataset`
     * as in the example below.
     *
     * #### Example
     * ```typescript
     * let command = 'some:command-id';
     * let args = { alpha: 'beta' };
     * let anchor = h.a({
     *   className: 'some-class',
     *   dataset: {
     *     foo: '1',
     *     bar: '2',
     *     ../...linker.populateVNodeDataset(command, args)
     *   }
     * }, 'some text');
     * ```
     */
    populateVNodeDataset(command, args) {
        let dataset;
        if (args !== void 0) {
            dataset = { [ARGS_ATTR]: JSON.stringify(args), [COMMAND_ATTR]: command };
        }
        else {
            dataset = { [COMMAND_ATTR]: command };
        }
        return dataset;
    }
    /**
     * The global click handler that deploys commands/argument pairs that are
     * attached to the node being clicked.
     */
    _evtClick(event) {
        let target = event.target;
        while (target && target.parentElement) {
            if (target.hasAttribute(`data-${COMMAND_ATTR}`)) {
                event.preventDefault();
                const command = target.getAttribute(`data-${COMMAND_ATTR}`);
                if (!command) {
                    return;
                }
                const argsValue = target.getAttribute(`data-${ARGS_ATTR}`);
                let args = dist_index_js_.JSONExt.emptyObject;
                if (argsValue) {
                    args = JSON.parse(argsValue);
                }
                void this._commands.execute(command, args);
                return;
            }
            target = target.parentElement;
        }
    }
}
//# sourceMappingURL=commandlinker.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/commandpalette.js
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/


/**
 * Class name identifying the input group with search icon.
 */
const SEARCH_ICON_GROUP_CLASS = 'jp-SearchIconGroup';
/**
 * Wrap the command palette in a modal to make it more usable.
 */
class ModalCommandPalette extends index_es6_js_.Panel {
    constructor(options) {
        super();
        this.addClass('jp-ModalCommandPalette');
        this.addClass('jp-ThemedContainer');
        this.id = 'modal-command-palette';
        this.palette = options.commandPalette;
        this._commandPalette.commands.commandExecuted.connect(() => {
            if (this.isAttached && this.isVisible) {
                this.hideAndReset();
            }
        });
        // required to properly receive blur and focus events;
        // selection of items with mouse may not work without this.
        this.node.tabIndex = 0;
    }
    get palette() {
        return this._commandPalette;
    }
    set palette(value) {
        this._commandPalette = value;
        if (!this.searchIconGroup) {
            this._commandPalette.inputNode.insertAdjacentElement('afterend', this.createSearchIconGroup());
        }
        this.addWidget(value);
        this.hideAndReset();
    }
    attach() {
        index_es6_js_.Widget.attach(this, document.body);
    }
    detach() {
        index_es6_js_.Widget.detach(this);
    }
    /**
     * Hide the modal command palette and reset its search.
     */
    hideAndReset() {
        this.hide();
        this._commandPalette.inputNode.value = '';
        this._commandPalette.refresh();
    }
    /**
     * Handle incoming events.
     */
    handleEvent(event) {
        switch (event.type) {
            case 'keydown':
                this._evtKeydown(event);
                break;
            case 'blur': {
                // if the focus shifted outside of this DOM element, hide and reset.
                if (
                // focus went away from child element
                this.node.contains(event.target) &&
                    // and it did NOT go to another child element but someplace else
                    !this.node.contains(event.relatedTarget)) {
                    event.stopPropagation();
                    this.hideAndReset();
                }
                break;
            }
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
            default:
                break;
        }
    }
    /**
     * Find the element with search icon group.
     */
    get searchIconGroup() {
        return this._commandPalette.node.getElementsByClassName(SEARCH_ICON_GROUP_CLASS)[0];
    }
    /**
     * Create element with search icon group.
     */
    createSearchIconGroup() {
        const inputGroup = document.createElement('div');
        inputGroup.classList.add(SEARCH_ICON_GROUP_CLASS);
        index_js_.searchIcon.render(inputGroup);
        return inputGroup;
    }
    /**
     *  A message handler invoked on an `'after-attach'` message.
     */
    onAfterAttach(msg) {
        this.node.addEventListener('keydown', this, true);
        this.node.addEventListener('contextmenu', this, true);
    }
    /**
     *  A message handler invoked on an `'after-detach'` message.
     */
    onAfterDetach(msg) {
        this.node.removeEventListener('keydown', this, true);
        this.node.removeEventListener('contextmenu', this, true);
    }
    onBeforeHide(msg) {
        document.removeEventListener('blur', this, true);
    }
    onAfterShow(msg) {
        document.addEventListener('blur', this, true);
    }
    /**
     * A message handler invoked on an `'activate-request'` message.
     */
    onActivateRequest(msg) {
        if (this.isAttached) {
            this.show();
            this._commandPalette.activate();
        }
    }
    /**
     * Handle the `'keydown'` event for the widget.
     */
    _evtKeydown(event) {
        // Check for escape key
        switch (event.keyCode) {
            case 27: // Escape.
                event.stopPropagation();
                event.preventDefault();
                this.hideAndReset();
                break;
            default:
                break;
        }
    }
}
//# sourceMappingURL=commandpalette.js.map
// EXTERNAL MODULE: consume shared module (default) @lumino/domutils@~2.0.3 (singleton) (fallback: ../node_modules/@lumino/domutils/dist/index.es6.js)
var domutils_dist_index_es6_js_ = __webpack_require__(23738);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/domutils.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * The namespace for DOM utilities.
 */
var DOMUtils;
(function (DOMUtils) {
    /**
     * Get the index of the node at a client position, or `-1`.
     */
    function hitTestNodes(nodes, x, y) {
        return dist_index_es6_js_.ArrayExt.findFirstIndex(nodes, node => {
            return domutils_dist_index_es6_js_.ElementExt.hitTest(node, x, y);
        });
    }
    DOMUtils.hitTestNodes = hitTestNodes;
    /**
     * Find the first element matching a class name.
     * Only use this function when the element existence is guaranteed.
     */
    function findElement(parent, className) {
        return parent.querySelector(`.${className}`);
    }
    DOMUtils.findElement = findElement;
    /**
     * Find the first element matching a class name.
     */
    function findElements(parent, className) {
        return parent.getElementsByClassName(className);
    }
    DOMUtils.findElements = findElements;
    /**
     * Create a DOM id with prefix "id-" to solve bug for UUIDs beginning with numbers.
     */
    function createDomID() {
        return `id-${dist_index_js_.UUID.uuid4()}`;
    }
    DOMUtils.createDomID = createDomID;
    /**
     * Check whether the active element descendant from given parent is editable.
     * When checking active elements it includes elements in the open shadow DOM.
     */
    function hasActiveEditableElement(parent, root = document) {
        const element = root.activeElement;
        return !!(element &&
            parent.contains(element) &&
            (element.matches(':read-write') ||
                (element.shadowRoot &&
                    hasActiveEditableElement(element.shadowRoot, element.shadowRoot))));
    }
    DOMUtils.hasActiveEditableElement = hasActiveEditableElement;
})(DOMUtils || (DOMUtils = {}));
//# sourceMappingURL=domutils.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/inputdialog.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


const INPUT_DIALOG_CLASS = 'jp-Input-Dialog';
const INPUT_BOOLEAN_DIALOG_CLASS = 'jp-Input-Boolean-Dialog';
/**
 * Namespace for input dialogs
 */
var InputDialog;
(function (InputDialog) {
    /**
     * Create and show a input dialog for a boolean.
     *
     * @param options - The dialog setup options.
     *
     * @returns A promise that resolves with whether the dialog was accepted
     */
    function getBoolean(options) {
        return showDialog({
            ...options,
            body: new InputBooleanDialog(options),
            buttons: [
                Dialog.cancelButton({ label: options.cancelLabel }),
                Dialog.okButton({ label: options.okLabel })
            ],
            focusNodeSelector: 'input'
        });
    }
    InputDialog.getBoolean = getBoolean;
    /**
     * Create and show a input dialog for a number.
     *
     * @param options - The dialog setup options.
     *
     * @returns A promise that resolves with whether the dialog was accepted
     */
    function getNumber(options) {
        return showDialog({
            ...options,
            body: new InputNumberDialog(options),
            buttons: [
                Dialog.cancelButton({ label: options.cancelLabel }),
                Dialog.okButton({ label: options.okLabel })
            ],
            focusNodeSelector: 'input'
        });
    }
    InputDialog.getNumber = getNumber;
    /**
     * Create and show a input dialog for a choice.
     *
     * @param options - The dialog setup options.
     *
     * @returns A promise that resolves with whether the dialog was accepted
     */
    function getItem(options) {
        return showDialog({
            ...options,
            body: new InputItemsDialog(options),
            buttons: [
                Dialog.cancelButton({ label: options.cancelLabel }),
                Dialog.okButton({ label: options.okLabel })
            ],
            focusNodeSelector: options.editable ? 'input' : 'select'
        });
    }
    InputDialog.getItem = getItem;
    /**
     * Create and show a input dialog for a choice.
     *
     * @param options - The dialog setup options.
     *
     * @returns A promise that resolves with whether the dialog was accepted
     */
    function getMultipleItems(options) {
        return showDialog({
            ...options,
            body: new InputMultipleItemsDialog(options),
            buttons: [
                Dialog.cancelButton({ label: options.cancelLabel }),
                Dialog.okButton({ label: options.okLabel })
            ]
        });
    }
    InputDialog.getMultipleItems = getMultipleItems;
    /**
     * Create and show a input dialog for a text.
     *
     * @param options - The dialog setup options.
     *
     * @returns A promise that resolves with whether the dialog was accepted
     */
    function getText(options) {
        return showDialog({
            ...options,
            body: new InputTextDialog(options),
            buttons: [
                Dialog.cancelButton({ label: options.cancelLabel }),
                Dialog.okButton({ label: options.okLabel })
            ],
            focusNodeSelector: 'input'
        });
    }
    InputDialog.getText = getText;
    /**
     * Create and show a input dialog for a password.
     *
     * @param options - The dialog setup options.
     *
     * @returns A promise that resolves with whether the dialog was accepted
     */
    function getPassword(options) {
        return showDialog({
            ...options,
            body: new InputPasswordDialog(options),
            buttons: [
                Dialog.cancelButton({ label: options.cancelLabel }),
                Dialog.okButton({ label: options.okLabel })
            ],
            focusNodeSelector: 'input'
        });
    }
    InputDialog.getPassword = getPassword;
})(InputDialog || (InputDialog = {}));
/**
 * Base widget for input dialog body
 */
class InputDialogBase extends index_es6_js_.Widget {
    /**
     * InputDialog constructor
     *
     * @param label Input field label
     */
    constructor(options) {
        super();
        this.addClass(INPUT_DIALOG_CLASS);
        this._input = document.createElement('input');
        this._input.classList.add('jp-mod-styled');
        this._input.id = 'jp-dialog-input-id';
        if (options.label !== undefined) {
            const labelElement = document.createElement('label');
            labelElement.textContent = options.label;
            labelElement.htmlFor = this._input.id;
            // Initialize the node
            this.node.appendChild(labelElement);
        }
        const wrapper = document.createElement('div');
        wrapper.className = 'jp-InputDialog-inputWrapper';
        if (options.prefix) {
            const prefix = document.createElement('span');
            prefix.className = 'jp-InputDialog-inputPrefix';
            prefix.textContent = options.prefix;
            // Both US WDS (https://designsystem.digital.gov/components/input-prefix-suffix/)
            // and UK DS (https://design-system.service.gov.uk/components/text-input/) recommend
            // hiding prefixes and suffixes from screen readers.
            prefix.ariaHidden = 'true';
            wrapper.appendChild(prefix);
        }
        wrapper.appendChild(this._input);
        if (options.suffix) {
            const suffix = document.createElement('span');
            suffix.className = 'jp-InputDialog-inputSuffix';
            suffix.textContent = options.suffix;
            suffix.ariaHidden = 'true';
            wrapper.appendChild(suffix);
        }
        this.node.appendChild(wrapper);
    }
}
/**
 * Widget body for input boolean dialog
 */
class InputBooleanDialog extends InputDialogBase {
    /**
     * InputBooleanDialog constructor
     *
     * @param options Constructor options
     */
    constructor(options) {
        super(options);
        this.addClass(INPUT_BOOLEAN_DIALOG_CLASS);
        this._input.type = 'checkbox';
        this._input.checked = options.value ? true : false;
    }
    /**
     * Get the text specified by the user
     */
    getValue() {
        return this._input.checked;
    }
}
/**
 * Widget body for input number dialog
 */
class InputNumberDialog extends InputDialogBase {
    /**
     * InputNumberDialog constructor
     *
     * @param options Constructor options
     */
    constructor(options) {
        super(options);
        this._input.type = 'number';
        this._input.value = options.value ? options.value.toString() : '0';
    }
    /**
     * Get the number specified by the user.
     */
    getValue() {
        if (this._input.value) {
            return Number(this._input.value);
        }
        else {
            return Number.NaN;
        }
    }
}
/**
 * Base widget body for input text/password/email dialog
 */
class InputDialogTextBase extends InputDialogBase {
    /**
     * InputDialogTextBase constructor
     *
     * @param options Constructor options
     */
    constructor(options) {
        super(options);
        this._input.value = options.text ? options.text : '';
        if (options.placeholder) {
            this._input.placeholder = options.placeholder;
        }
        if (options.pattern) {
            this._input.pattern = options.pattern;
        }
        if (options.required) {
            this._input.required = options.required;
        }
    }
    /**
     * Get the text specified by the user
     */
    getValue() {
        return this._input.value;
    }
}
/**
 * Widget body for input text dialog
 */
class InputTextDialog extends InputDialogTextBase {
    /**
     * InputTextDialog constructor
     *
     * @param options Constructor options
     */
    constructor(options) {
        var _a;
        super(options);
        this._input.type = 'text';
        this._initialSelectionRange = Math.min(this._input.value.length, Math.max(0, (_a = options.selectionRange) !== null && _a !== void 0 ? _a : this._input.value.length));
    }
    /**
     *  A message handler invoked on an `'after-attach'` message.
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        if (this._initialSelectionRange > 0 && this._input.value) {
            this._input.setSelectionRange(0, this._initialSelectionRange);
        }
    }
}
/**
 * Widget body for input password dialog
 */
class InputPasswordDialog extends InputDialogTextBase {
    /**
     * InputPasswordDialog constructor
     *
     * @param options Constructor options
     */
    constructor(options) {
        super(options);
        this._input.type = 'password';
    }
    /**
     *  A message handler invoked on an `'after-attach'` message.
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        if (this._input.value) {
            this._input.select();
        }
    }
}
/**
 * Widget body for input list dialog
 */
class InputItemsDialog extends InputDialogBase {
    /**
     * InputItemsDialog constructor
     *
     * @param options Constructor options
     */
    constructor(options) {
        super(options);
        this._editable = options.editable || false;
        let current = options.current || 0;
        let defaultIndex;
        if (typeof current === 'number') {
            defaultIndex = Math.max(0, Math.min(current, options.items.length - 1));
            current = '';
        }
        this._list = document.createElement('select');
        options.items.forEach((item, index) => {
            const option = document.createElement('option');
            if (index === defaultIndex) {
                option.selected = true;
                current = item;
            }
            option.value = item;
            option.textContent = item;
            this._list.appendChild(option);
        });
        if (options.editable) {
            /* Use of list and datalist */
            const data = document.createElement('datalist');
            data.id = 'input-dialog-items';
            data.appendChild(this._list);
            this._input.type = 'list';
            this._input.value = current;
            this._input.setAttribute('list', data.id);
            if (options.placeholder) {
                this._input.placeholder = options.placeholder;
            }
            this.node.appendChild(data);
        }
        else {
            /* Use select directly */
            this._input.parentElement.replaceChild(this._list, this._input);
        }
    }
    /**
     * Get the user choice
     */
    getValue() {
        if (this._editable) {
            return this._input.value;
        }
        else {
            return this._list.value;
        }
    }
}
/**
 * Widget body for input list dialog
 */
class InputMultipleItemsDialog extends InputDialogBase {
    /**
     * InputMultipleItemsDialog constructor
     *
     * @param options Constructor options
     */
    constructor(options) {
        super(options);
        let defaults = options.defaults || [];
        this._list = document.createElement('select');
        this._list.setAttribute('multiple', '');
        options.items.forEach(item => {
            const option = document.createElement('option');
            option.value = item;
            option.textContent = item;
            this._list.appendChild(option);
        });
        // use the select
        this._input.remove();
        this.node.appendChild(this._list);
        // select the current ones
        const htmlOptions = this._list.options;
        for (let i = 0; i < htmlOptions.length; i++) {
            const option = htmlOptions[i];
            if (defaults.includes(option.value)) {
                option.selected = true;
            }
            else {
                option.selected = false;
            }
        }
    }
    /**
     * Get the user choices
     */
    getValue() {
        let result = [];
        for (let opt of this._list.options) {
            if (opt.selected && !opt.classList.contains('hidden')) {
                result.push(opt.value || opt.text);
            }
        }
        return result;
    }
}
//# sourceMappingURL=inputdialog.js.map
// EXTERNAL MODULE: consume shared module (default) @jupyterlab/services@~7.4.3 (singleton) (fallback: ../node_modules/@jupyterlab/services/lib/index.js)
var services_lib_index_js_ = __webpack_require__(43234);
// EXTERNAL MODULE: consume shared module (default) @lumino/virtualdom@~2.0.3 (singleton) (fallback: ../node_modules/@lumino/virtualdom/dist/index.es6.js)
var virtualdom_dist_index_es6_js_ = __webpack_require__(67458);
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/licenses.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







const FILTER_SECTION_TITLE_CLASS = 'jp-Licenses-Filters-title';
/**
 * A license viewer
 */
class Licenses extends index_es6_js_.SplitPanel {
    constructor(options) {
        super();
        this.addClass('jp-Licenses');
        this.model = options.model;
        this.initLeftPanel();
        this.initFilters();
        this.initBundles();
        this.initGrid();
        this.initLicenseText();
        this.setRelativeSizes([1, 2, 3]);
        void this.model.initLicenses().then(() => this._updateBundles());
        this.model.trackerDataChanged.connect(() => {
            this.title.label = this.model.title;
        });
    }
    /**
     * Handle disposing of the widget
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._bundles.currentChanged.disconnect(this.onBundleSelected, this);
        this.model.dispose();
        super.dispose();
    }
    /**
     * Initialize the left area for filters and bundles
     */
    initLeftPanel() {
        this._leftPanel = new index_es6_js_.Panel();
        this._leftPanel.addClass('jp-Licenses-FormArea');
        this.addWidget(this._leftPanel);
        index_es6_js_.SplitPanel.setStretch(this._leftPanel, 1);
    }
    /**
     * Initialize the filters
     */
    initFilters() {
        this._filters = new Licenses.Filters(this.model);
        index_es6_js_.SplitPanel.setStretch(this._filters, 1);
        this._leftPanel.addWidget(this._filters);
    }
    /**
     * Initialize the listing of available bundles
     */
    initBundles() {
        this._bundles = new index_es6_js_.TabBar({
            orientation: 'vertical',
            renderer: new Licenses.BundleTabRenderer(this.model)
        });
        this._bundles.addClass('jp-Licenses-Bundles');
        index_es6_js_.SplitPanel.setStretch(this._bundles, 1);
        this._leftPanel.addWidget(this._bundles);
        this._bundles.currentChanged.connect(this.onBundleSelected, this);
        this.model.stateChanged.connect(() => this._bundles.update());
    }
    /**
     * Initialize the listing of packages within the current bundle
     */
    initGrid() {
        this._grid = new Licenses.Grid(this.model);
        index_es6_js_.SplitPanel.setStretch(this._grid, 1);
        this.addWidget(this._grid);
    }
    /**
     * Initialize the full text of the current package
     */
    initLicenseText() {
        this._licenseText = new Licenses.FullText(this.model);
        index_es6_js_.SplitPanel.setStretch(this._grid, 1);
        this.addWidget(this._licenseText);
    }
    /**
     * Event handler for updating the model with the current bundle
     */
    onBundleSelected() {
        var _a;
        if ((_a = this._bundles.currentTitle) === null || _a === void 0 ? void 0 : _a.label) {
            this.model.currentBundleName = this._bundles.currentTitle.label;
        }
    }
    /**
     * Update the bundle tabs.
     */
    _updateBundles() {
        this._bundles.clearTabs();
        let i = 0;
        const { currentBundleName } = this.model;
        let currentIndex = 0;
        for (const bundle of this.model.bundleNames) {
            const tab = new index_es6_js_.Widget();
            tab.title.label = bundle;
            if (bundle === currentBundleName) {
                currentIndex = i;
            }
            this._bundles.insertTab(++i, tab.title);
        }
        this._bundles.currentIndex = currentIndex;
    }
}
/** A namespace for license components */
(function (Licenses) {
    /**
     * License report formats understood by the server (once lower-cased)
     */
    Licenses.REPORT_FORMATS = {
        markdown: {
            id: 'markdown',
            title: 'Markdown',
            icon: index_js_.markdownIcon
        },
        csv: {
            id: 'csv',
            title: 'CSV',
            icon: index_js_.spreadsheetIcon
        },
        json: {
            id: 'json',
            title: 'JSON',
            icon: index_js_.jsonIcon
        }
    };
    /**
     * The default format (most human-readable)
     */
    Licenses.DEFAULT_FORMAT = 'markdown';
    /**
     * A class used for fetching licenses from the server.
     */
    class LicensesClient {
        /**
         * Create a new license client.
         */
        constructor(options = {}) {
            var _a;
            this._licensesUrl = options.licensesUrl || '';
            this._serverSettings =
                (_a = options.serverSettings) !== null && _a !== void 0 ? _a : services_lib_index_js_.ServerConnection.makeSettings();
        }
        /**
         * Download the licenses in the requested format.
         */
        async download(options) {
            const url = `${this._licensesUrl}?format=${options.format}&download=1`;
            const element = document.createElement('a');
            element.href = url;
            element.download = '';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
            URL.revokeObjectURL(url);
            return void 0;
        }
        /**
         * Fetch the license bundles from the server.
         */
        async getBundles() {
            const response = await services_lib_index_js_.ServerConnection.makeRequest(this._licensesUrl, {}, this._serverSettings);
            return response.json();
        }
    }
    Licenses.LicensesClient = LicensesClient;
    /**
     * A model for license data
     */
    class Model extends index_js_.VDomModel {
        constructor(options) {
            super();
            this._selectedPackageChanged = new signaling_dist_index_es6_js_.Signal(this);
            this._trackerDataChanged = new signaling_dist_index_es6_js_.Signal(this);
            this._currentPackageIndex = 0;
            this._licensesReady = new dist_index_js_.PromiseDelegate();
            this._packageFilter = {};
            this._trans = options.trans;
            this._client = options.client;
            if (options.currentBundleName) {
                this._currentBundleName = options.currentBundleName;
            }
            if (options.packageFilter) {
                this._packageFilter = options.packageFilter;
            }
            if (options.currentPackageIndex) {
                this._currentPackageIndex = options.currentPackageIndex;
            }
        }
        /**
         * Handle the initial request for the licenses from the server.
         */
        async initLicenses() {
            try {
                this._serverResponse = await this._client.getBundles();
                this._licensesReady.resolve();
                this.stateChanged.emit(void 0);
            }
            catch (err) {
                this._licensesReady.reject(err);
            }
        }
        /**
         * Download the licenses in the requested format.
         */
        async download(options) {
            return this._client.download(options);
        }
        /**
         * A promise that resolves when the licenses from the server change
         */
        get selectedPackageChanged() {
            return this._selectedPackageChanged;
        }
        /**
         * A promise that resolves when the trackable data changes
         */
        get trackerDataChanged() {
            return this._trackerDataChanged;
        }
        /**
         * The names of the license bundles available
         */
        get bundleNames() {
            var _a;
            return Object.keys(((_a = this._serverResponse) === null || _a === void 0 ? void 0 : _a.bundles) || {});
        }
        /**
         * The current license bundle
         */
        get currentBundleName() {
            if (this._currentBundleName) {
                return this._currentBundleName;
            }
            if (this.bundleNames.length) {
                return this.bundleNames[0];
            }
            return null;
        }
        /**
         * Set the current license bundle, and reset the selected index
         */
        set currentBundleName(currentBundleName) {
            if (this._currentBundleName !== currentBundleName) {
                this._currentBundleName = currentBundleName;
                this.stateChanged.emit(void 0);
                this._trackerDataChanged.emit(void 0);
            }
        }
        /**
         * A promise that resolves when the licenses are available from the server
         */
        get licensesReady() {
            return this._licensesReady.promise;
        }
        /**
         * All the license bundles, keyed by the distributing packages
         */
        get bundles() {
            var _a;
            return ((_a = this._serverResponse) === null || _a === void 0 ? void 0 : _a.bundles) || {};
        }
        /**
         * The index of the currently-selected package within its license bundle
         */
        get currentPackageIndex() {
            return this._currentPackageIndex;
        }
        /**
         * Update the currently-selected package within its license bundle
         */
        set currentPackageIndex(currentPackageIndex) {
            if (this._currentPackageIndex === currentPackageIndex) {
                return;
            }
            this._currentPackageIndex = currentPackageIndex;
            this._selectedPackageChanged.emit(void 0);
            this.stateChanged.emit(void 0);
            this._trackerDataChanged.emit(void 0);
        }
        /**
         * The license data for the currently-selected package
         */
        get currentPackage() {
            var _a;
            if (this.currentBundleName &&
                this.bundles &&
                this._currentPackageIndex != null) {
                return this.getFilteredPackages(((_a = this.bundles[this.currentBundleName]) === null || _a === void 0 ? void 0 : _a.packages) || [])[this._currentPackageIndex];
            }
            return null;
        }
        /**
         * A translation bundle
         */
        get trans() {
            return this._trans;
        }
        get title() {
            return `${this._currentBundleName || ''} ${this._trans.__('Licenses')}`.trim();
        }
        /**
         * The current package filter
         */
        get packageFilter() {
            return this._packageFilter;
        }
        set packageFilter(packageFilter) {
            this._packageFilter = packageFilter;
            this.stateChanged.emit(void 0);
            this._trackerDataChanged.emit(void 0);
        }
        /**
         * Get filtered packages from current bundle where at least one token of each
         * key is present.
         */
        getFilteredPackages(allRows) {
            let rows = [];
            let filters = Object.entries(this._packageFilter)
                .filter(([k, v]) => v && `${v}`.trim().length)
                .map(([k, v]) => [k, `${v}`.toLowerCase().trim().split(' ')]);
            for (const row of allRows) {
                let keyHits = 0;
                for (const [key, bits] of filters) {
                    let bitHits = 0;
                    let rowKeyValue = `${row[key]}`.toLowerCase();
                    for (const bit of bits) {
                        if (rowKeyValue.includes(bit)) {
                            bitHits += 1;
                        }
                    }
                    if (bitHits) {
                        keyHits += 1;
                    }
                }
                if (keyHits === filters.length) {
                    rows.push(row);
                }
            }
            return Object.values(rows);
        }
    }
    Licenses.Model = Model;
    /**
     * A filter form for limiting the packages displayed
     */
    class Filters extends index_js_.VDomRenderer {
        constructor(model) {
            super(model);
            /**
             * Render a filter input
             */
            this.renderFilter = (key) => {
                const value = this.model.packageFilter[key] || '';
                return (react_index_js_.createElement("input", { type: "text", name: key, defaultValue: value, className: "jp-mod-styled", onInput: this.onFilterInput }));
            };
            /**
             * Handle a filter input changing
             */
            this.onFilterInput = (evt) => {
                const input = evt.currentTarget;
                const { name, value } = input;
                this.model.packageFilter = { ...this.model.packageFilter, [name]: value };
            };
            this.addClass('jp-Licenses-Filters');
            this.addClass('jp-RenderedHTMLCommon');
        }
        render() {
            const { trans } = this.model;
            return (react_index_js_.createElement("div", null,
                react_index_js_.createElement("label", null,
                    react_index_js_.createElement("strong", { className: FILTER_SECTION_TITLE_CLASS }, trans.__('Filter Licenses By'))),
                react_index_js_.createElement("ul", null,
                    react_index_js_.createElement("li", null,
                        react_index_js_.createElement("label", null, trans.__('Package')),
                        this.renderFilter('name')),
                    react_index_js_.createElement("li", null,
                        react_index_js_.createElement("label", null, trans.__('Version')),
                        this.renderFilter('versionInfo')),
                    react_index_js_.createElement("li", null,
                        react_index_js_.createElement("label", null, trans.__('License')),
                        this.renderFilter('licenseId'))),
                react_index_js_.createElement("label", null,
                    react_index_js_.createElement("strong", { className: FILTER_SECTION_TITLE_CLASS }, trans.__('Distributions')))));
        }
    }
    Licenses.Filters = Filters;
    /**
     * A fancy bundle renderer with the package count
     */
    class BundleTabRenderer extends index_es6_js_.TabBar.Renderer {
        constructor(model) {
            super();
            this.closeIconSelector = '.lm-TabBar-tabCloseIcon';
            this.model = model;
        }
        /**
         * Render a full bundle
         */
        renderTab(data) {
            let title = data.title.caption;
            let key = this.createTabKey(data);
            let style = this.createTabStyle(data);
            let className = this.createTabClass(data);
            let dataset = this.createTabDataset(data);
            return virtualdom_dist_index_es6_js_.h.li({ key, className, title, style, dataset }, this.renderIcon(data), this.renderLabel(data), this.renderCountBadge(data));
        }
        /**
         * Render the package count
         */
        renderCountBadge(data) {
            const bundle = data.title.label;
            const { bundles } = this.model;
            const packages = this.model.getFilteredPackages((bundles && bundle ? bundles[bundle].packages : []) || []);
            return virtualdom_dist_index_es6_js_.h.label({}, `${packages.length}`);
        }
    }
    Licenses.BundleTabRenderer = BundleTabRenderer;
    /**
     * A grid of licenses
     */
    class Grid extends index_js_.VDomRenderer {
        constructor(model) {
            super(model);
            /**
             * Render a single package's license information
             */
            this.renderRow = (row, index) => {
                const selected = index === this.model.currentPackageIndex;
                const onCheck = () => (this.model.currentPackageIndex = index);
                return (react_index_js_.createElement("tr", { key: row.name, className: selected ? 'jp-mod-selected' : '', onClick: onCheck },
                    react_index_js_.createElement("td", null,
                        react_index_js_.createElement("input", { type: "radio", name: "show-package-license", value: index, onChange: onCheck, checked: selected })),
                    react_index_js_.createElement("th", null, row.name),
                    react_index_js_.createElement("td", null,
                        react_index_js_.createElement("code", null, row.versionInfo)),
                    react_index_js_.createElement("td", null,
                        react_index_js_.createElement("code", null, row.licenseId))));
            };
            this.addClass('jp-Licenses-Grid');
            this.addClass('jp-RenderedHTMLCommon');
        }
        /**
         * Render a grid of package license information
         */
        render() {
            var _a;
            const { bundles, currentBundleName, trans } = this.model;
            const filteredPackages = this.model.getFilteredPackages(bundles && currentBundleName
                ? ((_a = bundles[currentBundleName]) === null || _a === void 0 ? void 0 : _a.packages) || []
                : []);
            if (!filteredPackages.length) {
                return (react_index_js_.createElement("blockquote", null,
                    react_index_js_.createElement("em", null, trans.__('No Packages found'))));
            }
            return (react_index_js_.createElement("form", null,
                react_index_js_.createElement("table", null,
                    react_index_js_.createElement("thead", null,
                        react_index_js_.createElement("tr", null,
                            react_index_js_.createElement("td", null),
                            react_index_js_.createElement("th", null, trans.__('Package')),
                            react_index_js_.createElement("th", null, trans.__('Version')),
                            react_index_js_.createElement("th", null, trans.__('License')))),
                    react_index_js_.createElement("tbody", null, filteredPackages.map(this.renderRow)))));
        }
    }
    Licenses.Grid = Grid;
    /**
     * A package's full license text
     */
    class FullText extends index_js_.VDomRenderer {
        constructor(model) {
            super(model);
            this.addClass('jp-Licenses-Text');
            this.addClass('jp-RenderedHTMLCommon');
            this.addClass('jp-RenderedMarkdown');
        }
        /**
         * Render the license text, or a null state if no package is selected
         */
        render() {
            const { currentPackage, trans } = this.model;
            let head = '';
            let quote = trans.__('No Package selected');
            let code = '';
            if (currentPackage) {
                const { name, versionInfo, licenseId, extractedText } = currentPackage;
                head = `${name} v${versionInfo}`;
                quote = `${trans.__('License')}: ${licenseId || trans.__('No License ID found')}`;
                code = extractedText || trans.__('No License Text found');
            }
            return [
                react_index_js_.createElement("h1", { key: "h1" }, head),
                react_index_js_.createElement("blockquote", { key: "quote" },
                    react_index_js_.createElement("em", null, quote)),
                react_index_js_.createElement("code", { key: "code" }, code)
            ];
        }
    }
    Licenses.FullText = FullText;
})(Licenses || (Licenses = {}));
//# sourceMappingURL=licenses.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/printing.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * Any object is "printable" if it implements the `IPrintable` interface.
 *
 * To do this it, it must have a method called `Printing.symbol` which returns either a function
 * to print the object or null if it cannot be printed.
 *
 * One way of printing is to use the `printWidget` function, which creates a hidden iframe
 * and copies the DOM nodes from your widget to that iframe and printing just that iframe.
 *
 * Another way to print is to use the `printURL` function, which takes a URL and prints that page.
 */
var Printing;
(function (Printing) {
    /**
     * Symbol to use for a method that returns a function to print an object.
     */
    Printing.symbol = Symbol('printable');
    /**
     * Returns whether an object implements a print method.
     */
    function isPrintable(a) {
        if (typeof a !== 'object' || !a) {
            return false;
        }
        return Printing.symbol in a;
    }
    Printing.isPrintable = isPrintable;
    /**
     * Returns the print function for an object, or null if it does not provide a handler.
     */
    function getPrintFunction(val) {
        if (isPrintable(val)) {
            return val[Printing.symbol]();
        }
        return null;
    }
    Printing.getPrintFunction = getPrintFunction;
    /**
     * Prints a widget by copying it's DOM node
     * to a hidden iframe and printing that iframe.
     */
    function printWidget(widget) {
        return printContent(widget.node);
    }
    Printing.printWidget = printWidget;
    /**
     * Prints a URL by loading it into an iframe.
     *
     * @param url URL to load into an iframe.
     */
    async function printURL(url) {
        const settings = services_lib_index_js_.ServerConnection.makeSettings();
        const text = await (await services_lib_index_js_.ServerConnection.makeRequest(url, {}, settings)).text();
        return printContent(text);
    }
    Printing.printURL = printURL;
    /**
     * Prints a URL or an element in an iframe and then removes the iframe after printing.
     */
    async function printContent(textOrEl) {
        const isText = typeof textOrEl === 'string';
        const iframe = createIFrame();
        const parent = window.document.body;
        parent.appendChild(iframe);
        if (isText) {
            iframe.srcdoc = textOrEl;
            await resolveWhenLoaded(iframe);
        }
        else {
            iframe.src = 'about:blank';
            await resolveWhenLoaded(iframe);
            setIFrameNode(iframe, textOrEl);
        }
        const printed = resolveAfterEvent();
        launchPrint(iframe.contentWindow);
        // Once the print dialog has been dismissed, we regain event handling,
        // and it should be safe to discard the hidden iframe.
        await printed;
        parent.removeChild(iframe);
    }
    /**
     * Creates a new hidden iframe and appends it to the document
     *
     * Modified from
     * https://github.com/joseluisq/printd/blob/eb7948d602583c055ab6dee3ee294b6a421da4b6/src/index.ts#L24
     */
    function createIFrame() {
        const el = window.document.createElement('iframe');
        // We need both allow-modals and allow-same-origin to be able to
        // call print in the iframe.
        // We intentionally do not allow scripts:
        // https://github.com/jupyterlab/jupyterlab/pull/5850#pullrequestreview-230899790
        el.setAttribute('sandbox', 'allow-modals allow-same-origin');
        const css = 'visibility:hidden;width:0;height:0;position:absolute;z-index:-9999;bottom:0;';
        el.setAttribute('style', css);
        el.setAttribute('width', '0');
        el.setAttribute('height', '0');
        return el;
    }
    /**
     * Copies a node from the base document to the iframe.
     */
    function setIFrameNode(iframe, node) {
        iframe.contentDocument.body.appendChild(node.cloneNode(true));
        iframe.contentDocument.close();
    }
    /**
     * Promise that resolves when all resources are loaded in the window.
     */
    function resolveWhenLoaded(iframe) {
        return new Promise(resolve => {
            iframe.onload = () => resolve();
        });
    }
    /**
     * A promise that resolves after the next mousedown, mousemove, or
     * keydown event. We use this as a proxy for determining when the
     * main window has regained control after the print dialog is removed.
     *
     * We can't use the usual window.onafterprint handler because we
     * disallow Javascript execution in the print iframe.
     */
    function resolveAfterEvent() {
        return new Promise(resolve => {
            const onEvent = () => {
                document.removeEventListener('mousemove', onEvent, true);
                document.removeEventListener('mousedown', onEvent, true);
                document.removeEventListener('keydown', onEvent, true);
                resolve();
            };
            document.addEventListener('mousemove', onEvent, true);
            document.addEventListener('mousedown', onEvent, true);
            document.addEventListener('keydown', onEvent, true);
        });
    }
    /**
     * Prints a content window.
     */
    function launchPrint(contentWindow) {
        const result = contentWindow.document.execCommand('print', false);
        // execCommand won't work in firefox so we call the `print` method instead if it fails
        // https://github.com/joseluisq/printd/blob/eb7948d602583c055ab6dee3ee294b6a421da4b6/src/index.ts#L148
        if (!result) {
            contentWindow.print();
        }
    }
})(Printing || (Printing = {}));
//# sourceMappingURL=printing.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/mainareawidget.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






/**
 * A flag to indicate that event handlers are caught in the capture phase.
 */
const USE_CAPTURE = true;
/**
 * A widget meant to be contained in the JupyterLab main area.
 *
 * #### Notes
 * Mirrors all of the `title` attributes of the content.
 * This widget is `closable` by default.
 * This widget is automatically disposed when closed.
 * This widget ensures its own focus when activated.
 */
class MainAreaWidget extends index_es6_js_.Widget {
    /**
     * Construct a new main area widget.
     *
     * @param options - The options for initializing the widget.
     */
    constructor(options) {
        super(options);
        this._changeGuard = false;
        this._spinner = new index_js_.Spinner();
        this._isRevealed = false;
        this._evtMouseDown = () => {
            if (!this.node.contains(document.activeElement)) {
                this._focusContent();
            }
        };
        this.addClass('jp-MainAreaWidget');
        // Set contain=strict to avoid many forced layout rendering while adding cells.
        // Don't forget to remove the CSS class when your remove the spinner to allow
        // the content to be rendered.
        // @see https://github.com/jupyterlab/jupyterlab/issues/9381
        this.addClass('jp-MainAreaWidget-ContainStrict');
        this.id = DOMUtils.createDomID();
        const trans = (options.translator || lib_index_js_.nullTranslator).load('jupyterlab');
        const content = (this._content = options.content);
        content.node.setAttribute('role', 'region');
        content.node.setAttribute('aria-label', trans.__('main area content'));
        const toolbar = (this._toolbar =
            options.toolbar || new index_js_.ReactiveToolbar({ noFocusOnClick: true }));
        toolbar.node.setAttribute('role', 'toolbar');
        toolbar.node.setAttribute('aria-label', trans.__('main area toolbar'));
        const contentHeader = (this._contentHeader =
            options.contentHeader ||
                new index_es6_js_.BoxPanel({
                    direction: 'top-to-bottom',
                    spacing: 0
                }));
        const layout = (this.layout = new index_es6_js_.BoxLayout({ spacing: 0 }));
        layout.direction = 'top-to-bottom';
        index_es6_js_.BoxLayout.setStretch(toolbar, 0);
        index_es6_js_.BoxLayout.setStretch(contentHeader, 0);
        index_es6_js_.BoxLayout.setStretch(content, 1);
        layout.addWidget(toolbar);
        layout.addWidget(contentHeader);
        layout.addWidget(content);
        if (!content.id) {
            content.id = DOMUtils.createDomID();
        }
        content.node.tabIndex = -1;
        this._updateTitle();
        content.title.changed.connect(this._updateTitle, this);
        this.title.closable = true;
        this.title.changed.connect(this._updateContentTitle, this);
        if (options.reveal) {
            this.node.appendChild(this._spinner.node);
            this._revealed = options.reveal
                .then(() => {
                if (content.isDisposed) {
                    this.dispose();
                    return;
                }
                content.disposed.connect(() => this.dispose());
                const active = document.activeElement === this._spinner.node;
                this._disposeSpinner();
                this._isRevealed = true;
                if (active) {
                    this._focusContent();
                }
            })
                .catch(e => {
                // Show a revealed promise error.
                const error = new index_es6_js_.Widget();
                error.addClass('jp-MainAreaWidget-error');
                // Show the error to the user.
                const pre = document.createElement('pre');
                pre.textContent = String(e);
                error.node.appendChild(pre);
                index_es6_js_.BoxLayout.setStretch(error, 1);
                this._disposeSpinner();
                content.dispose();
                this._content = null;
                toolbar.dispose();
                this._toolbar = null;
                layout.addWidget(error);
                this._isRevealed = true;
                throw error;
            });
        }
        else {
            // Handle no reveal promise.
            this._spinner.dispose();
            this.removeClass('jp-MainAreaWidget-ContainStrict');
            content.disposed.connect(() => this.dispose());
            this._isRevealed = true;
            this._revealed = Promise.resolve(undefined);
        }
    }
    /**
     * Print method. Deferred to content.
     */
    [Printing.symbol]() {
        if (!this._content) {
            return null;
        }
        return Printing.getPrintFunction(this._content);
    }
    /**
     * The content hosted by the widget.
     */
    get content() {
        return this._content;
    }
    /**
     * The toolbar hosted by the widget.
     */
    get toolbar() {
        return this._toolbar;
    }
    /**
     * A panel for widgets that sit between the toolbar and the content.
     * Imagine a formatting toolbar, notification headers, etc.
     */
    get contentHeader() {
        return this._contentHeader;
    }
    /**
     * Whether the content widget or an error is revealed.
     */
    get isRevealed() {
        return this._isRevealed;
    }
    /**
     * A promise that resolves when the widget is revealed.
     */
    get revealed() {
        return this._revealed;
    }
    /**
     * Handle `'activate-request'` messages.
     */
    onActivateRequest(msg) {
        if (this._isRevealed) {
            this._focusContent();
        }
        else {
            this._spinner.node.focus();
        }
    }
    /**
     * Handle `after-attach` messages for the widget.
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        // Focus content in capture phase to ensure relevant commands operate on the
        // current main area widget.
        // Add the event listener directly instead of using `handleEvent` in order
        // to save sub-classes from needing to reason about calling it as well.
        this.node.addEventListener('mousedown', this._evtMouseDown, USE_CAPTURE);
    }
    /**
     * Handle `before-detach` messages for the widget.
     */
    onBeforeDetach(msg) {
        this.node.removeEventListener('mousedown', this._evtMouseDown, USE_CAPTURE);
        super.onBeforeDetach(msg);
    }
    /**
     * Handle `'close-request'` messages.
     */
    onCloseRequest(msg) {
        this.dispose();
    }
    /**
     * Handle `'update-request'` messages by forwarding them to the content.
     */
    onUpdateRequest(msg) {
        if (this._content) {
            messaging_dist_index_es6_js_.MessageLoop.sendMessage(this._content, msg);
        }
    }
    _disposeSpinner() {
        this.node.removeChild(this._spinner.node);
        this._spinner.dispose();
        this.removeClass('jp-MainAreaWidget-ContainStrict');
    }
    /**
     * Update the title based on the attributes of the child widget.
     */
    _updateTitle() {
        if (this._changeGuard || !this.content) {
            return;
        }
        this._changeGuard = true;
        const content = this.content;
        this.title.label = content.title.label;
        this.title.mnemonic = content.title.mnemonic;
        this.title.icon = content.title.icon;
        this.title.iconClass = content.title.iconClass;
        this.title.iconLabel = content.title.iconLabel;
        this.title.caption = content.title.caption;
        this.title.className = content.title.className;
        this.title.dataset = content.title.dataset;
        this._changeGuard = false;
    }
    /**
     * Update the content title based on attributes of the main widget.
     */
    _updateContentTitle() {
        if (this._changeGuard || !this.content) {
            return;
        }
        this._changeGuard = true;
        const content = this.content;
        content.title.label = this.title.label;
        content.title.mnemonic = this.title.mnemonic;
        content.title.icon = this.title.icon;
        content.title.iconClass = this.title.iconClass;
        content.title.iconLabel = this.title.iconLabel;
        content.title.caption = this.title.caption;
        content.title.className = this.title.className;
        content.title.dataset = this.title.dataset;
        this._changeGuard = false;
    }
    /**
     * Give focus to the content.
     */
    _focusContent() {
        if (!this.content) {
            return;
        }
        // Focus the content node if we aren't already focused on it or a
        // descendent.
        if (!this.content.node.contains(document.activeElement)) {
            this.content.node.focus();
        }
        // Activate the content asynchronously (which may change the focus).
        this.content.activate();
    }
}
//# sourceMappingURL=mainareawidget.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/menufactory.js
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */



/**
 * Helper functions to build a menu from the settings
 */
var MenuFactory;
(function (MenuFactory) {
    /**
     * Create menus from their description
     *
     * @param data Menubar description
     * @param menuFactory Factory for empty menu
     */
    function createMenus(data, menuFactory) {
        return data
            .filter(item => !item.disabled)
            .sort((a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b.rank) !== null && _b !== void 0 ? _b : Infinity); })
            .map(menuItem => {
            return dataToMenu(menuItem, menuFactory);
        });
    }
    MenuFactory.createMenus = createMenus;
    /**
     * Convert a menu description in a JupyterLabMenu object
     *
     * @param item Menu description
     * @param menuFactory Empty menu factory
     * @returns The menu widget
     */
    function dataToMenu(item, menuFactory) {
        var _a, _b;
        const menu = menuFactory(item);
        menu.id = item.id;
        // Set the label in case the menu factory did not.
        if (!menu.title.label) {
            menu.title.label = (_a = item.label) !== null && _a !== void 0 ? _a : coreutils_lib_index_js_.Text.titleCase(menu.id.trim());
        }
        if (item.icon) {
            menu.title.icon = index_js_.LabIcon.resolve({ icon: item.icon });
        }
        if (item.mnemonic !== undefined) {
            menu.title.mnemonic = item.mnemonic;
        }
        (_b = item.items) === null || _b === void 0 ? void 0 : _b.filter(item => !item.disabled).sort((a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b.rank) !== null && _b !== void 0 ? _b : Infinity); }).map(item => {
            addItem(item, menu, menuFactory);
        });
        return menu;
    }
    /**
     * Convert an item description in a context menu item object
     *
     * @param item Context menu item
     * @param menu Context menu to populate
     * @param menuFactory Empty menu factory
     */
    function addContextItem(item, menu, menuFactory) {
        const { submenu, ...newItem } = item;
        // Commands may not have been registered yet; so we don't force it to exist
        menu.addItem({
            ...newItem,
            submenu: submenu ? dataToMenu(submenu, menuFactory) : null
        });
    }
    MenuFactory.addContextItem = addContextItem;
    /**
     * Convert an item description in a menu item object
     *
     * @param item Menu item
     * @param menu Menu to populate
     * @param menuFactory Empty menu factory
     */
    function addItem(item, menu, menuFactory) {
        const { submenu, ...newItem } = item;
        // Commands may not have been registered yet; so we don't force it to exist
        menu.addItem({
            ...newItem,
            submenu: submenu ? dataToMenu(submenu, menuFactory) : null
        });
    }
    /**
     * Update an existing list of menu and returns
     * the new elements.
     *
     * #### Note
     * New elements are added to the current menu list.
     *
     * @param menus Current menus
     * @param data New description to take into account
     * @param menuFactory Empty menu factory
     * @returns Newly created menus
     */
    function updateMenus(menus, data, menuFactory) {
        const newMenus = [];
        data.forEach(item => {
            const menu = menus.find(menu => menu.id === item.id);
            if (menu) {
                mergeMenus(item, menu, menuFactory);
            }
            else {
                if (!item.disabled) {
                    newMenus.push(dataToMenu(item, menuFactory));
                }
            }
        });
        menus.push(...newMenus);
        return newMenus;
    }
    MenuFactory.updateMenus = updateMenus;
    function mergeMenus(item, menu, menuFactory) {
        var _a;
        if (item.disabled) {
            menu.dispose();
        }
        else {
            (_a = item.items) === null || _a === void 0 ? void 0 : _a.forEach(entry => {
                var _a, _b;
                const existingItem = menu === null || menu === void 0 ? void 0 : menu.items.find((i, idx) => {
                    var _a, _b, _c;
                    return i.type === entry.type &&
                        i.command === ((_a = entry.command) !== null && _a !== void 0 ? _a : '') &&
                        ((_b = i.submenu) === null || _b === void 0 ? void 0 : _b.id) === ((_c = entry.submenu) === null || _c === void 0 ? void 0 : _c.id);
                });
                if (existingItem && entry.type !== 'separator') {
                    if (entry.disabled) {
                        menu.removeItem(existingItem);
                    }
                    else {
                        switch ((_a = entry.type) !== null && _a !== void 0 ? _a : 'command') {
                            case 'command':
                                if (entry.command) {
                                    if (!dist_index_js_.JSONExt.deepEqual(existingItem.args, (_b = entry.args) !== null && _b !== void 0 ? _b : {})) {
                                        addItem(entry, menu, menuFactory);
                                    }
                                }
                                break;
                            case 'submenu':
                                if (entry.submenu) {
                                    mergeMenus(entry.submenu, existingItem.submenu, menuFactory);
                                }
                        }
                    }
                }
                else {
                    addItem(entry, menu, menuFactory);
                }
            });
        }
    }
})(MenuFactory || (MenuFactory = {}));
//# sourceMappingURL=menufactory.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/notification.js
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */


/**
 * Notification manager
 */
class NotificationManager {
    constructor() {
        this._isDisposed = false;
        this._queue = [];
        this._changed = new signaling_dist_index_es6_js_.Signal(this);
    }
    /**
     * Signal emitted whenever a notification changes.
     */
    get changed() {
        return this._changed;
    }
    /**
     * Total number of notifications.
     */
    get count() {
        return this._queue.length;
    }
    /**
     * Whether the manager is disposed or not.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * The list of notifications.
     */
    get notifications() {
        return this._queue.slice();
    }
    /**
     * Dismiss one notification (specified by its id) or all if no id provided.
     *
     * @param id Notification id
     */
    dismiss(id) {
        if (typeof id === 'undefined') {
            const q = this._queue.slice();
            this._queue.length = 0;
            for (const notification of q) {
                this._changed.emit({
                    type: 'removed',
                    notification
                });
            }
        }
        else {
            const notificationIndex = this._queue.findIndex(n => n.id === id);
            if (notificationIndex > -1) {
                const notification = this._queue.splice(notificationIndex, 1)[0];
                this._changed.emit({
                    type: 'removed',
                    notification
                });
            }
        }
    }
    /**
     * Dispose the manager.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        signaling_dist_index_es6_js_.Signal.clearData(this);
    }
    /**
     * Test whether a notification exists or not.
     *
     * @param id Notification id
     * @returns Notification status
     */
    has(id) {
        return this._queue.findIndex(n => n.id === id) > -1;
    }
    /**
     * Add a new notification.
     *
     * This will trigger the `changed` signal with an `added` event.
     *
     * @param message Notification message
     * @param type Notification type
     * @param options Notification option
     * @returns Notification unique id
     */
    notify(message, type, options) {
        const now = Date.now();
        const { progress, ...othersOptions } = options;
        const notification = Object.freeze({
            id: dist_index_js_.UUID.uuid4(),
            createdAt: now,
            modifiedAt: now,
            message,
            type,
            options: {
                // By default notification will be silent
                autoClose: 0,
                progress: typeof progress === 'number'
                    ? Math.min(Math.max(0, progress), 1)
                    : progress,
                ...othersOptions
            }
        });
        this._queue.unshift(notification);
        this._changed.emit({
            type: 'added',
            notification
        });
        return notification.id;
    }
    /**
     * Update an existing notification.
     *
     * If the notification does not exists this won't do anything.
     *
     * Once updated the notification will be moved at the begin
     * of the notification stack.
     *
     * @param args Update options
     * @returns Whether the update was successful or not.
     */
    update(args) {
        const { id, message, actions, autoClose, data, progress, type } = args;
        const newProgress = typeof progress === 'number'
            ? Math.min(Math.max(0, progress), 1)
            : progress;
        const notificationIndex = this._queue.findIndex(n => n.id === id);
        if (notificationIndex > -1) {
            const oldNotification = this._queue[notificationIndex];
            // We need to create a new object as notification are frozen; i.e. cannot be edited
            const notification = Object.freeze({
                ...oldNotification,
                message: message !== null && message !== void 0 ? message : oldNotification.message,
                type: type !== null && type !== void 0 ? type : oldNotification.type,
                options: {
                    actions: actions !== null && actions !== void 0 ? actions : oldNotification.options.actions,
                    autoClose: autoClose !== null && autoClose !== void 0 ? autoClose : oldNotification.options.autoClose,
                    data: data !== null && data !== void 0 ? data : oldNotification.options.data,
                    progress: newProgress !== null && newProgress !== void 0 ? newProgress : oldNotification.options.progress
                },
                modifiedAt: Date.now()
            });
            this._queue.splice(notificationIndex, 1);
            this._queue.unshift(notification);
            this._changed.emit({
                type: 'updated',
                notification
            });
            return true;
        }
        return false;
    }
}
/**
 * Notification namespace
 */
var Notification;
(function (Notification) {
    /**
     * The global notification manager.
     */
    Notification.manager = new NotificationManager();
    /**
     * Dismiss one notification (specified by its id) or all if no id provided
     *
     * @param id notification id
     */
    function dismiss(id) {
        Notification.manager.dismiss(id);
    }
    Notification.dismiss = dismiss;
    /**
     * Helper function to emit a notification.
     *
     * #### Notes
     * The message will be truncated if longer than 140 characters.
     *
     * @param message Notification message
     * @param type Notification type
     * @param options Options for the error notification
     * @returns Notification unique id
     */
    function emit(message, type = 'default', options = {}) {
        return Notification.manager.notify(message, type, options);
    }
    Notification.emit = emit;
    /**
     * Helper function to emit an error notification.
     *
     * #### Notes
     * The message will be truncated if longer than 140 characters.
     *
     * @param message Notification message
     * @param options Options for the error notification
     * @returns Notification unique id
     */
    function error(message, options = {}) {
        return Notification.manager.notify(message, 'error', options);
    }
    Notification.error = error;
    /**
     * Helper function to emit an info notification.
     *
     * #### Notes
     * The message will be truncated if longer than 140 characters.
     *
     * @param message Notification message
     * @param options Options for the info notification
     * @returns Notification unique id
     */
    function info(message, options = {}) {
        return Notification.manager.notify(message, 'info', options);
    }
    Notification.info = info;
    /**
     * Helper function to show an in-progress notification.
     *
     * #### Notes
     * The message will be truncated if longer than 140 characters.
     *
     * @param promise Promise to wait for
     * @param options Options for the in-progress notification
     * @returns Notification unique id
     */
    function promise(promise, options) {
        var _a;
        const { pending, error, success } = options;
        const id = Notification.manager.notify(pending.message, 'in-progress', (_a = pending.options) !== null && _a !== void 0 ? _a : {});
        promise
            .then(result => {
            var _a, _b, _c;
            Notification.manager.update({
                id,
                message: success.message(result, (_a = success.options) === null || _a === void 0 ? void 0 : _a.data),
                type: 'success',
                ...success.options,
                data: (_c = (_b = success.options) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : result
            });
        })
            .catch(reason => {
            var _a, _b, _c;
            Notification.manager.update({
                id,
                message: error.message(reason, (_a = error.options) === null || _a === void 0 ? void 0 : _a.data),
                type: 'error',
                ...error.options,
                data: (_c = (_b = error.options) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : reason
            });
        });
        return id;
    }
    Notification.promise = promise;
    /**
     * Helper function to emit a success notification.
     *
     * #### Notes
     * The message will be truncated if longer than 140 characters.
     *
     * @param message Notification message
     * @param options Options for the success notification
     * @returns Notification unique id
     */
    function success(message, options = {}) {
        return Notification.manager.notify(message, 'success', options);
    }
    Notification.success = success;
    /**
     * Helper function to update a notification.
     *
     * If the notification does not exists, nothing will happen.
     *
     * Once updated the notification will be moved at the begin
     * of the notification stack.
     *
     * #### Notes
     * The message will be truncated if longer than 140 characters.
     *
     * @param args Update options
     * @returns Whether the update was successful or not.
     */
    function update(args) {
        return Notification.manager.update(args);
    }
    Notification.update = update;
    /**
     * Helper function to emit a warning notification.
     *
     * #### Notes
     * The message will be truncated if longer than 140 characters.
     *
     * @param message Notification message
     * @param options Options for the warning notification
     * @returns Notification unique id
     */
    function warning(message, options = {}) {
        return Notification.manager.notify(message, 'warning', options);
    }
    Notification.warning = warning;
})(Notification || (Notification = {}));
//# sourceMappingURL=notification.js.map
;// CONCATENATED MODULE: ../node_modules/@jupyterlab/apputils/lib/runningSessions.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/**
 * Half spacing between subitems in a status item, in pixels.
 */
const HALF_SPACING = 4;
/**
 * A pure functional component for rendering kernel and terminal sessions.
 *
 * @param props the props for the component.
 *
 * @returns a tsx component for the running sessions.
 */
function RunningSessionsComponent(props) {
    var _a, _b;
    const showKernels = (_a = props.showKernels) !== null && _a !== void 0 ? _a : true;
    const showTerminals = (_b = props.showTerminals) !== null && _b !== void 0 ? _b : props.terminals > 0;
    return (react_index_js_default().createElement(statusbar_lib_index_js_.GroupItem, { tabIndex: 0, spacing: HALF_SPACING, onClick: props.handleClick, onKeyDown: props.handleKeyDown, style: { cursor: 'pointer' } },
        showTerminals ? (react_index_js_default().createElement(statusbar_lib_index_js_.GroupItem, { spacing: HALF_SPACING },
            react_index_js_default().createElement(statusbar_lib_index_js_.TextItem, { source: props.terminals }),
            react_index_js_default().createElement(index_js_.terminalIcon.react, { verticalAlign: "middle", stylesheet: "statusBar" }))) : null,
        showKernels ? (react_index_js_default().createElement(statusbar_lib_index_js_.GroupItem, { spacing: HALF_SPACING },
            react_index_js_default().createElement(statusbar_lib_index_js_.TextItem, { source: props.sessions }),
            react_index_js_default().createElement(index_js_.kernelIcon.react, { verticalAlign: "middle", stylesheet: "statusBar" }))) : null));
}
/**
 * A VDomRenderer for a RunningSessions status item.
 */
class RunningSessions extends index_js_.VDomRenderer {
    /**
     * Create a new RunningSessions widget.
     */
    constructor(opts) {
        super(new RunningSessions.Model());
        this._serviceManager = opts.serviceManager;
        this._handleClick = opts.onClick;
        this._handleKeyDown = opts.onKeyDown;
        this.translator = opts.translator || lib_index_js_.nullTranslator;
        this._showKernels = opts.showKernels;
        this._showTerminals = opts.showTerminals;
        this._trans = this.translator.load('jupyterlab');
        this._serviceManager.sessions.runningChanged.connect(this._onSessionsRunningChanged, this);
        this._serviceManager.terminals.runningChanged.connect(this._onTerminalsRunningChanged, this);
        this.addClass('jp-mod-highlighted');
    }
    /**
     * Render the running sessions widget.
     */
    render() {
        if (!this.model) {
            return null;
        }
        // TODO-TRANS: Should probably be handled differently.
        // This is more localizable friendly: "Terminals: %1 | Kernels: %2"
        // Generate a localized caption for the tooltip
        const caption = this._trans.__('%1 Terminals, %2 Kernel sessions', this.model.terminals, this.model.sessions);
        // Explicitly synchronize the title attribute with the Lumino widget's DOM
        // This ensures the tooltip displays correctly when hovering over the widget
        this.node.title = caption;
        return (react_index_js_default().createElement(RunningSessionsComponent, { sessions: this.model.sessions, terminals: this.model.terminals, handleClick: this._handleClick, handleKeyDown: this._handleKeyDown, showKernels: this._showKernels, showTerminals: this._showTerminals }));
    }
    /**
     * Dispose of the status item.
     */
    dispose() {
        super.dispose();
        this._serviceManager.sessions.runningChanged.disconnect(this._onSessionsRunningChanged, this);
        this._serviceManager.terminals.runningChanged.disconnect(this._onTerminalsRunningChanged, this);
    }
    /**
     * Set the number of kernel sessions when the list changes.
     */
    _onSessionsRunningChanged(manager, sessions) {
        this.model.sessions = sessions.length;
    }
    /**
     * Set the number of termin